
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Paper
 * 
 */
export type Paper = $Result.DefaultSelection<Prisma.$PaperPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model Ebook
 * 
 */
export type Ebook = $Result.DefaultSelection<Prisma.$EbookPayload>
/**
 * Model EbookFile
 * 
 */
export type EbookFile = $Result.DefaultSelection<Prisma.$EbookFilePayload>
/**
 * Model Certificate
 * 
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>
/**
 * Model Library
 * 
 */
export type Library = $Result.DefaultSelection<Prisma.$LibraryPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model BlogTag
 * 
 */
export type BlogTag = $Result.DefaultSelection<Prisma.$BlogTagPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Like
 * 
 */
export type Like = $Result.DefaultSelection<Prisma.$LikePayload>
/**
 * Model CollaboratorApplication
 * 
 */
export type CollaboratorApplication = $Result.DefaultSelection<Prisma.$CollaboratorApplicationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model LegalDocument
 * 
 */
export type LegalDocument = $Result.DefaultSelection<Prisma.$LegalDocumentPayload>
/**
 * Model MessageTemplate
 * 
 */
export type MessageTemplate = $Result.DefaultSelection<Prisma.$MessageTemplatePayload>
/**
 * Model DownloadTracking
 * 
 */
export type DownloadTracking = $Result.DefaultSelection<Prisma.$DownloadTrackingPayload>
/**
 * Model CustomPaper
 * 
 */
export type CustomPaper = $Result.DefaultSelection<Prisma.$CustomPaperPayload>
/**
 * Model CustomPaperMessage
 * 
 */
export type CustomPaperMessage = $Result.DefaultSelection<Prisma.$CustomPaperMessagePayload>
/**
 * Model CourseModule
 * 
 */
export type CourseModule = $Result.DefaultSelection<Prisma.$CourseModulePayload>
/**
 * Model CourseLesson
 * 
 */
export type CourseLesson = $Result.DefaultSelection<Prisma.$CourseLessonPayload>
/**
 * Model CourseProgress
 * 
 */
export type CourseProgress = $Result.DefaultSelection<Prisma.$CourseProgressPayload>
/**
 * Model CourseEnrollment
 * 
 */
export type CourseEnrollment = $Result.DefaultSelection<Prisma.$CourseEnrollmentPayload>
/**
 * Model PostAnalytics
 * 
 */
export type PostAnalytics = $Result.DefaultSelection<Prisma.$PostAnalyticsPayload>
/**
 * Model NewsletterSubscriber
 * 
 */
export type NewsletterSubscriber = $Result.DefaultSelection<Prisma.$NewsletterSubscriberPayload>
/**
 * Model NewsletterSubscription
 * 
 */
export type NewsletterSubscription = $Result.DefaultSelection<Prisma.$NewsletterSubscriptionPayload>
/**
 * Model PostNotification
 * 
 */
export type PostNotification = $Result.DefaultSelection<Prisma.$PostNotificationPayload>
/**
 * Model Evaluation
 * 
 */
export type Evaluation = $Result.DefaultSelection<Prisma.$EvaluationPayload>
/**
 * Model Note
 * 
 */
export type Note = $Result.DefaultSelection<Prisma.$NotePayload>
/**
 * Model Interview
 * 
 */
export type Interview = $Result.DefaultSelection<Prisma.$InterviewPayload>
/**
 * Model ApiIntegration
 * 
 */
export type ApiIntegration = $Result.DefaultSelection<Prisma.$ApiIntegrationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  STUDENT: 'STUDENT',
  COLLABORATOR: 'COLLABORATOR'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const OrderStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  CANCELED: 'CANCELED',
  INTERESTED: 'INTERESTED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentMethod: {
  PIX: 'PIX',
  BOLETO: 'BOLETO',
  CREDIT_CARD: 'CREDIT_CARD',
  DEBIT_CARD: 'DEBIT_CARD'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  PAID: 'PAID',
  CONFIRMED: 'CONFIRMED',
  OVERDUE: 'OVERDUE',
  REFUNDED: 'REFUNDED',
  FAILED: 'FAILED',
  CANCELED: 'CANCELED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PaperType: {
  ARTICLE: 'ARTICLE',
  REVIEW: 'REVIEW',
  THESIS: 'THESIS',
  DISSERTATION: 'DISSERTATION',
  PROJECT: 'PROJECT',
  ESSAY: 'ESSAY',
  SUMMARY: 'SUMMARY',
  MONOGRAPHY: 'MONOGRAPHY',
  CASE_STUDY: 'CASE_STUDY',
  OTHER: 'OTHER'
};

export type PaperType = (typeof PaperType)[keyof typeof PaperType]


export const AcademicArea: {
  ADMINISTRATION: 'ADMINISTRATION',
  LAW: 'LAW',
  EDUCATION: 'EDUCATION',
  ENGINEERING: 'ENGINEERING',
  PSYCHOLOGY: 'PSYCHOLOGY',
  HEALTH: 'HEALTH',
  ACCOUNTING: 'ACCOUNTING',
  ARTS: 'ARTS',
  ECONOMICS: 'ECONOMICS',
  SOCIAL_SCIENCES: 'SOCIAL_SCIENCES',
  OTHER: 'OTHER',
  EXACT_SCIENCES: 'EXACT_SCIENCES',
  BIOLOGICAL_SCIENCES: 'BIOLOGICAL_SCIENCES',
  HEALTH_SCIENCES: 'HEALTH_SCIENCES',
  APPLIED_SOCIAL_SCIENCES: 'APPLIED_SOCIAL_SCIENCES',
  HUMANITIES: 'HUMANITIES',
  LANGUAGES: 'LANGUAGES',
  AGRICULTURAL_SCIENCES: 'AGRICULTURAL_SCIENCES',
  MULTIDISCIPLINARY: 'MULTIDISCIPLINARY'
};

export type AcademicArea = (typeof AcademicArea)[keyof typeof AcademicArea]


export const CourseLevel: {
  BEGINNER: 'BEGINNER',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED'
};

export type CourseLevel = (typeof CourseLevel)[keyof typeof CourseLevel]


export const CourseStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type CourseStatus = (typeof CourseStatus)[keyof typeof CourseStatus]


export const LibraryItemType: {
  PAPER: 'PAPER',
  EBOOK: 'EBOOK',
  COURSE_MATERIAL: 'COURSE_MATERIAL'
};

export type LibraryItemType = (typeof LibraryItemType)[keyof typeof LibraryItemType]


export const PostStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type PostStatus = (typeof PostStatus)[keyof typeof PostStatus]


export const ApplicationStatus: {
  PENDING: 'PENDING',
  INTERVIEWING: 'INTERVIEWING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ApplicationStatus = (typeof ApplicationStatus)[keyof typeof ApplicationStatus]


export const ApplicationStage: {
  RECEIVED: 'RECEIVED',
  SCREENING: 'SCREENING',
  INTERVIEW: 'INTERVIEW',
  TECHNICAL_TEST: 'TECHNICAL_TEST',
  FINAL_REVIEW: 'FINAL_REVIEW',
  OFFER: 'OFFER',
  HIRED: 'HIRED'
};

export type ApplicationStage = (typeof ApplicationStage)[keyof typeof ApplicationStage]


export const MessageStatus: {
  UNREAD: 'UNREAD',
  READ: 'READ',
  ARCHIVED: 'ARCHIVED'
};

export type MessageStatus = (typeof MessageStatus)[keyof typeof MessageStatus]


export const Priority: {
  LOW: 'LOW',
  NORMAL: 'NORMAL',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const LegalType: {
  TERMS_OF_SERVICE: 'TERMS_OF_SERVICE',
  PRIVACY_POLICY: 'PRIVACY_POLICY',
  COOKIES_POLICY: 'COOKIES_POLICY',
  LGPD_COMPLIANCE: 'LGPD_COMPLIANCE'
};

export type LegalType = (typeof LegalType)[keyof typeof LegalType]


export const CustomPaperUrgency: {
  NORMAL: 'NORMAL',
  URGENT: 'URGENT',
  VERY_URGENT: 'VERY_URGENT'
};

export type CustomPaperUrgency = (typeof CustomPaperUrgency)[keyof typeof CustomPaperUrgency]


export const CustomPaperStatus: {
  REQUESTED: 'REQUESTED',
  QUOTED: 'QUOTED',
  APPROVED: 'APPROVED',
  IN_PROGRESS: 'IN_PROGRESS',
  REVIEW: 'REVIEW',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  REJECTED: 'REJECTED'
};

export type CustomPaperStatus = (typeof CustomPaperStatus)[keyof typeof CustomPaperStatus]


export const EvaluationRecommendation: {
  STRONG_HIRE: 'STRONG_HIRE',
  HIRE: 'HIRE',
  MAYBE: 'MAYBE',
  NO_HIRE: 'NO_HIRE',
  STRONG_NO_HIRE: 'STRONG_NO_HIRE'
};

export type EvaluationRecommendation = (typeof EvaluationRecommendation)[keyof typeof EvaluationRecommendation]


export const InterviewType: {
  PHONE_SCREENING: 'PHONE_SCREENING',
  TECHNICAL: 'TECHNICAL',
  BEHAVIORAL: 'BEHAVIORAL',
  FINAL: 'FINAL'
};

export type InterviewType = (typeof InterviewType)[keyof typeof InterviewType]


export const InterviewStatus: {
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW'
};

export type InterviewStatus = (typeof InterviewStatus)[keyof typeof InterviewStatus]


export const InterviewResult: {
  PASS: 'PASS',
  FAIL: 'FAIL',
  UNDECIDED: 'UNDECIDED'
};

export type InterviewResult = (typeof InterviewResult)[keyof typeof InterviewResult]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PaperType = $Enums.PaperType

export const PaperType: typeof $Enums.PaperType

export type AcademicArea = $Enums.AcademicArea

export const AcademicArea: typeof $Enums.AcademicArea

export type CourseLevel = $Enums.CourseLevel

export const CourseLevel: typeof $Enums.CourseLevel

export type CourseStatus = $Enums.CourseStatus

export const CourseStatus: typeof $Enums.CourseStatus

export type LibraryItemType = $Enums.LibraryItemType

export const LibraryItemType: typeof $Enums.LibraryItemType

export type PostStatus = $Enums.PostStatus

export const PostStatus: typeof $Enums.PostStatus

export type ApplicationStatus = $Enums.ApplicationStatus

export const ApplicationStatus: typeof $Enums.ApplicationStatus

export type ApplicationStage = $Enums.ApplicationStage

export const ApplicationStage: typeof $Enums.ApplicationStage

export type MessageStatus = $Enums.MessageStatus

export const MessageStatus: typeof $Enums.MessageStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type LegalType = $Enums.LegalType

export const LegalType: typeof $Enums.LegalType

export type CustomPaperUrgency = $Enums.CustomPaperUrgency

export const CustomPaperUrgency: typeof $Enums.CustomPaperUrgency

export type CustomPaperStatus = $Enums.CustomPaperStatus

export const CustomPaperStatus: typeof $Enums.CustomPaperStatus

export type EvaluationRecommendation = $Enums.EvaluationRecommendation

export const EvaluationRecommendation: typeof $Enums.EvaluationRecommendation

export type InterviewType = $Enums.InterviewType

export const InterviewType: typeof $Enums.InterviewType

export type InterviewStatus = $Enums.InterviewStatus

export const InterviewStatus: typeof $Enums.InterviewStatus

export type InterviewResult = $Enums.InterviewResult

export const InterviewResult: typeof $Enums.InterviewResult

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs>;

  /**
   * `prisma.paper`: Exposes CRUD operations for the **Paper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Papers
    * const papers = await prisma.paper.findMany()
    * ```
    */
  get paper(): Prisma.PaperDelegate<ExtArgs>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs>;

  /**
   * `prisma.ebook`: Exposes CRUD operations for the **Ebook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ebooks
    * const ebooks = await prisma.ebook.findMany()
    * ```
    */
  get ebook(): Prisma.EbookDelegate<ExtArgs>;

  /**
   * `prisma.ebookFile`: Exposes CRUD operations for the **EbookFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EbookFiles
    * const ebookFiles = await prisma.ebookFile.findMany()
    * ```
    */
  get ebookFile(): Prisma.EbookFileDelegate<ExtArgs>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificate.findMany()
    * ```
    */
  get certificate(): Prisma.CertificateDelegate<ExtArgs>;

  /**
   * `prisma.library`: Exposes CRUD operations for the **Library** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Libraries
    * const libraries = await prisma.library.findMany()
    * ```
    */
  get library(): Prisma.LibraryDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs>;

  /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs>;

  /**
   * `prisma.blogTag`: Exposes CRUD operations for the **BlogTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogTags
    * const blogTags = await prisma.blogTag.findMany()
    * ```
    */
  get blogTag(): Prisma.BlogTagDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.like`: Exposes CRUD operations for the **Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): Prisma.LikeDelegate<ExtArgs>;

  /**
   * `prisma.collaboratorApplication`: Exposes CRUD operations for the **CollaboratorApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollaboratorApplications
    * const collaboratorApplications = await prisma.collaboratorApplication.findMany()
    * ```
    */
  get collaboratorApplication(): Prisma.CollaboratorApplicationDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.legalDocument`: Exposes CRUD operations for the **LegalDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LegalDocuments
    * const legalDocuments = await prisma.legalDocument.findMany()
    * ```
    */
  get legalDocument(): Prisma.LegalDocumentDelegate<ExtArgs>;

  /**
   * `prisma.messageTemplate`: Exposes CRUD operations for the **MessageTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageTemplates
    * const messageTemplates = await prisma.messageTemplate.findMany()
    * ```
    */
  get messageTemplate(): Prisma.MessageTemplateDelegate<ExtArgs>;

  /**
   * `prisma.downloadTracking`: Exposes CRUD operations for the **DownloadTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DownloadTrackings
    * const downloadTrackings = await prisma.downloadTracking.findMany()
    * ```
    */
  get downloadTracking(): Prisma.DownloadTrackingDelegate<ExtArgs>;

  /**
   * `prisma.customPaper`: Exposes CRUD operations for the **CustomPaper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomPapers
    * const customPapers = await prisma.customPaper.findMany()
    * ```
    */
  get customPaper(): Prisma.CustomPaperDelegate<ExtArgs>;

  /**
   * `prisma.customPaperMessage`: Exposes CRUD operations for the **CustomPaperMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomPaperMessages
    * const customPaperMessages = await prisma.customPaperMessage.findMany()
    * ```
    */
  get customPaperMessage(): Prisma.CustomPaperMessageDelegate<ExtArgs>;

  /**
   * `prisma.courseModule`: Exposes CRUD operations for the **CourseModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseModules
    * const courseModules = await prisma.courseModule.findMany()
    * ```
    */
  get courseModule(): Prisma.CourseModuleDelegate<ExtArgs>;

  /**
   * `prisma.courseLesson`: Exposes CRUD operations for the **CourseLesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseLessons
    * const courseLessons = await prisma.courseLesson.findMany()
    * ```
    */
  get courseLesson(): Prisma.CourseLessonDelegate<ExtArgs>;

  /**
   * `prisma.courseProgress`: Exposes CRUD operations for the **CourseProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseProgresses
    * const courseProgresses = await prisma.courseProgress.findMany()
    * ```
    */
  get courseProgress(): Prisma.CourseProgressDelegate<ExtArgs>;

  /**
   * `prisma.courseEnrollment`: Exposes CRUD operations for the **CourseEnrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseEnrollments
    * const courseEnrollments = await prisma.courseEnrollment.findMany()
    * ```
    */
  get courseEnrollment(): Prisma.CourseEnrollmentDelegate<ExtArgs>;

  /**
   * `prisma.postAnalytics`: Exposes CRUD operations for the **PostAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostAnalytics
    * const postAnalytics = await prisma.postAnalytics.findMany()
    * ```
    */
  get postAnalytics(): Prisma.PostAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.newsletterSubscriber`: Exposes CRUD operations for the **NewsletterSubscriber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsletterSubscribers
    * const newsletterSubscribers = await prisma.newsletterSubscriber.findMany()
    * ```
    */
  get newsletterSubscriber(): Prisma.NewsletterSubscriberDelegate<ExtArgs>;

  /**
   * `prisma.newsletterSubscription`: Exposes CRUD operations for the **NewsletterSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsletterSubscriptions
    * const newsletterSubscriptions = await prisma.newsletterSubscription.findMany()
    * ```
    */
  get newsletterSubscription(): Prisma.NewsletterSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.postNotification`: Exposes CRUD operations for the **PostNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostNotifications
    * const postNotifications = await prisma.postNotification.findMany()
    * ```
    */
  get postNotification(): Prisma.PostNotificationDelegate<ExtArgs>;

  /**
   * `prisma.evaluation`: Exposes CRUD operations for the **Evaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evaluations
    * const evaluations = await prisma.evaluation.findMany()
    * ```
    */
  get evaluation(): Prisma.EvaluationDelegate<ExtArgs>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.note.findMany()
    * ```
    */
  get note(): Prisma.NoteDelegate<ExtArgs>;

  /**
   * `prisma.interview`: Exposes CRUD operations for the **Interview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interviews
    * const interviews = await prisma.interview.findMany()
    * ```
    */
  get interview(): Prisma.InterviewDelegate<ExtArgs>;

  /**
   * `prisma.apiIntegration`: Exposes CRUD operations for the **ApiIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiIntegrations
    * const apiIntegrations = await prisma.apiIntegration.findMany()
    * ```
    */
  get apiIntegration(): Prisma.ApiIntegrationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Order: 'Order',
    OrderItem: 'OrderItem',
    Paper: 'Paper',
    Course: 'Course',
    Ebook: 'Ebook',
    EbookFile: 'EbookFile',
    Certificate: 'Certificate',
    Library: 'Library',
    Category: 'Category',
    Tag: 'Tag',
    BlogPost: 'BlogPost',
    BlogTag: 'BlogTag',
    Comment: 'Comment',
    Like: 'Like',
    CollaboratorApplication: 'CollaboratorApplication',
    Message: 'Message',
    LegalDocument: 'LegalDocument',
    MessageTemplate: 'MessageTemplate',
    DownloadTracking: 'DownloadTracking',
    CustomPaper: 'CustomPaper',
    CustomPaperMessage: 'CustomPaperMessage',
    CourseModule: 'CourseModule',
    CourseLesson: 'CourseLesson',
    CourseProgress: 'CourseProgress',
    CourseEnrollment: 'CourseEnrollment',
    PostAnalytics: 'PostAnalytics',
    NewsletterSubscriber: 'NewsletterSubscriber',
    NewsletterSubscription: 'NewsletterSubscription',
    PostNotification: 'PostNotification',
    Evaluation: 'Evaluation',
    Note: 'Note',
    Interview: 'Interview',
    ApiIntegration: 'ApiIntegration'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "order" | "orderItem" | "paper" | "course" | "ebook" | "ebookFile" | "certificate" | "library" | "category" | "tag" | "blogPost" | "blogTag" | "comment" | "like" | "collaboratorApplication" | "message" | "legalDocument" | "messageTemplate" | "downloadTracking" | "customPaper" | "customPaperMessage" | "courseModule" | "courseLesson" | "courseProgress" | "courseEnrollment" | "postAnalytics" | "newsletterSubscriber" | "newsletterSubscription" | "postNotification" | "evaluation" | "note" | "interview" | "apiIntegration"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Paper: {
        payload: Prisma.$PaperPayload<ExtArgs>
        fields: Prisma.PaperFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaperFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaperFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperPayload>
          }
          findFirst: {
            args: Prisma.PaperFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaperFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperPayload>
          }
          findMany: {
            args: Prisma.PaperFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperPayload>[]
          }
          create: {
            args: Prisma.PaperCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperPayload>
          }
          createMany: {
            args: Prisma.PaperCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaperCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperPayload>[]
          }
          delete: {
            args: Prisma.PaperDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperPayload>
          }
          update: {
            args: Prisma.PaperUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperPayload>
          }
          deleteMany: {
            args: Prisma.PaperDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaperUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaperUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperPayload>
          }
          aggregate: {
            args: Prisma.PaperAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaper>
          }
          groupBy: {
            args: Prisma.PaperGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaperGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaperCountArgs<ExtArgs>
            result: $Utils.Optional<PaperCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Ebook: {
        payload: Prisma.$EbookPayload<ExtArgs>
        fields: Prisma.EbookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EbookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EbookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookPayload>
          }
          findFirst: {
            args: Prisma.EbookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EbookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookPayload>
          }
          findMany: {
            args: Prisma.EbookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookPayload>[]
          }
          create: {
            args: Prisma.EbookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookPayload>
          }
          createMany: {
            args: Prisma.EbookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EbookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookPayload>[]
          }
          delete: {
            args: Prisma.EbookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookPayload>
          }
          update: {
            args: Prisma.EbookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookPayload>
          }
          deleteMany: {
            args: Prisma.EbookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EbookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EbookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookPayload>
          }
          aggregate: {
            args: Prisma.EbookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEbook>
          }
          groupBy: {
            args: Prisma.EbookGroupByArgs<ExtArgs>
            result: $Utils.Optional<EbookGroupByOutputType>[]
          }
          count: {
            args: Prisma.EbookCountArgs<ExtArgs>
            result: $Utils.Optional<EbookCountAggregateOutputType> | number
          }
        }
      }
      EbookFile: {
        payload: Prisma.$EbookFilePayload<ExtArgs>
        fields: Prisma.EbookFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EbookFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EbookFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookFilePayload>
          }
          findFirst: {
            args: Prisma.EbookFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EbookFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookFilePayload>
          }
          findMany: {
            args: Prisma.EbookFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookFilePayload>[]
          }
          create: {
            args: Prisma.EbookFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookFilePayload>
          }
          createMany: {
            args: Prisma.EbookFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EbookFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookFilePayload>[]
          }
          delete: {
            args: Prisma.EbookFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookFilePayload>
          }
          update: {
            args: Prisma.EbookFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookFilePayload>
          }
          deleteMany: {
            args: Prisma.EbookFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EbookFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EbookFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EbookFilePayload>
          }
          aggregate: {
            args: Prisma.EbookFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEbookFile>
          }
          groupBy: {
            args: Prisma.EbookFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<EbookFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.EbookFileCountArgs<ExtArgs>
            result: $Utils.Optional<EbookFileCountAggregateOutputType> | number
          }
        }
      }
      Certificate: {
        payload: Prisma.$CertificatePayload<ExtArgs>
        fields: Prisma.CertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findFirst: {
            args: Prisma.CertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findMany: {
            args: Prisma.CertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          create: {
            args: Prisma.CertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          createMany: {
            args: Prisma.CertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          delete: {
            args: Prisma.CertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          update: {
            args: Prisma.CertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          deleteMany: {
            args: Prisma.CertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate>
          }
          groupBy: {
            args: Prisma.CertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateCountAggregateOutputType> | number
          }
        }
      }
      Library: {
        payload: Prisma.$LibraryPayload<ExtArgs>
        fields: Prisma.LibraryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LibraryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LibraryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryPayload>
          }
          findFirst: {
            args: Prisma.LibraryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LibraryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryPayload>
          }
          findMany: {
            args: Prisma.LibraryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryPayload>[]
          }
          create: {
            args: Prisma.LibraryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryPayload>
          }
          createMany: {
            args: Prisma.LibraryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LibraryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryPayload>[]
          }
          delete: {
            args: Prisma.LibraryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryPayload>
          }
          update: {
            args: Prisma.LibraryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryPayload>
          }
          deleteMany: {
            args: Prisma.LibraryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LibraryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LibraryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryPayload>
          }
          aggregate: {
            args: Prisma.LibraryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLibrary>
          }
          groupBy: {
            args: Prisma.LibraryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LibraryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LibraryCountArgs<ExtArgs>
            result: $Utils.Optional<LibraryCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      BlogTag: {
        payload: Prisma.$BlogTagPayload<ExtArgs>
        fields: Prisma.BlogTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          findFirst: {
            args: Prisma.BlogTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          findMany: {
            args: Prisma.BlogTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>[]
          }
          create: {
            args: Prisma.BlogTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          createMany: {
            args: Prisma.BlogTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>[]
          }
          delete: {
            args: Prisma.BlogTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          update: {
            args: Prisma.BlogTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          deleteMany: {
            args: Prisma.BlogTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlogTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          aggregate: {
            args: Prisma.BlogTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogTag>
          }
          groupBy: {
            args: Prisma.BlogTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogTagCountArgs<ExtArgs>
            result: $Utils.Optional<BlogTagCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Like: {
        payload: Prisma.$LikePayload<ExtArgs>
        fields: Prisma.LikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findFirst: {
            args: Prisma.LikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findMany: {
            args: Prisma.LikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          create: {
            args: Prisma.LikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          createMany: {
            args: Prisma.LikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          delete: {
            args: Prisma.LikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          update: {
            args: Prisma.LikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          deleteMany: {
            args: Prisma.LikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          aggregate: {
            args: Prisma.LikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLike>
          }
          groupBy: {
            args: Prisma.LikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeCountArgs<ExtArgs>
            result: $Utils.Optional<LikeCountAggregateOutputType> | number
          }
        }
      }
      CollaboratorApplication: {
        payload: Prisma.$CollaboratorApplicationPayload<ExtArgs>
        fields: Prisma.CollaboratorApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollaboratorApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaboratorApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollaboratorApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaboratorApplicationPayload>
          }
          findFirst: {
            args: Prisma.CollaboratorApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaboratorApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollaboratorApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaboratorApplicationPayload>
          }
          findMany: {
            args: Prisma.CollaboratorApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaboratorApplicationPayload>[]
          }
          create: {
            args: Prisma.CollaboratorApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaboratorApplicationPayload>
          }
          createMany: {
            args: Prisma.CollaboratorApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollaboratorApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaboratorApplicationPayload>[]
          }
          delete: {
            args: Prisma.CollaboratorApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaboratorApplicationPayload>
          }
          update: {
            args: Prisma.CollaboratorApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaboratorApplicationPayload>
          }
          deleteMany: {
            args: Prisma.CollaboratorApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollaboratorApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CollaboratorApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaboratorApplicationPayload>
          }
          aggregate: {
            args: Prisma.CollaboratorApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollaboratorApplication>
          }
          groupBy: {
            args: Prisma.CollaboratorApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollaboratorApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollaboratorApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<CollaboratorApplicationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      LegalDocument: {
        payload: Prisma.$LegalDocumentPayload<ExtArgs>
        fields: Prisma.LegalDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LegalDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LegalDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalDocumentPayload>
          }
          findFirst: {
            args: Prisma.LegalDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LegalDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalDocumentPayload>
          }
          findMany: {
            args: Prisma.LegalDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalDocumentPayload>[]
          }
          create: {
            args: Prisma.LegalDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalDocumentPayload>
          }
          createMany: {
            args: Prisma.LegalDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LegalDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalDocumentPayload>[]
          }
          delete: {
            args: Prisma.LegalDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalDocumentPayload>
          }
          update: {
            args: Prisma.LegalDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalDocumentPayload>
          }
          deleteMany: {
            args: Prisma.LegalDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LegalDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LegalDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalDocumentPayload>
          }
          aggregate: {
            args: Prisma.LegalDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLegalDocument>
          }
          groupBy: {
            args: Prisma.LegalDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LegalDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LegalDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<LegalDocumentCountAggregateOutputType> | number
          }
        }
      }
      MessageTemplate: {
        payload: Prisma.$MessageTemplatePayload<ExtArgs>
        fields: Prisma.MessageTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          findFirst: {
            args: Prisma.MessageTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          findMany: {
            args: Prisma.MessageTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>[]
          }
          create: {
            args: Prisma.MessageTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          createMany: {
            args: Prisma.MessageTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>[]
          }
          delete: {
            args: Prisma.MessageTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          update: {
            args: Prisma.MessageTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          deleteMany: {
            args: Prisma.MessageTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
          }
          aggregate: {
            args: Prisma.MessageTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageTemplate>
          }
          groupBy: {
            args: Prisma.MessageTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<MessageTemplateCountAggregateOutputType> | number
          }
        }
      }
      DownloadTracking: {
        payload: Prisma.$DownloadTrackingPayload<ExtArgs>
        fields: Prisma.DownloadTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DownloadTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DownloadTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadTrackingPayload>
          }
          findFirst: {
            args: Prisma.DownloadTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DownloadTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadTrackingPayload>
          }
          findMany: {
            args: Prisma.DownloadTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadTrackingPayload>[]
          }
          create: {
            args: Prisma.DownloadTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadTrackingPayload>
          }
          createMany: {
            args: Prisma.DownloadTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DownloadTrackingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadTrackingPayload>[]
          }
          delete: {
            args: Prisma.DownloadTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadTrackingPayload>
          }
          update: {
            args: Prisma.DownloadTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadTrackingPayload>
          }
          deleteMany: {
            args: Prisma.DownloadTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DownloadTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DownloadTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadTrackingPayload>
          }
          aggregate: {
            args: Prisma.DownloadTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDownloadTracking>
          }
          groupBy: {
            args: Prisma.DownloadTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<DownloadTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.DownloadTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<DownloadTrackingCountAggregateOutputType> | number
          }
        }
      }
      CustomPaper: {
        payload: Prisma.$CustomPaperPayload<ExtArgs>
        fields: Prisma.CustomPaperFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomPaperFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomPaperFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperPayload>
          }
          findFirst: {
            args: Prisma.CustomPaperFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomPaperFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperPayload>
          }
          findMany: {
            args: Prisma.CustomPaperFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperPayload>[]
          }
          create: {
            args: Prisma.CustomPaperCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperPayload>
          }
          createMany: {
            args: Prisma.CustomPaperCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomPaperCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperPayload>[]
          }
          delete: {
            args: Prisma.CustomPaperDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperPayload>
          }
          update: {
            args: Prisma.CustomPaperUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperPayload>
          }
          deleteMany: {
            args: Prisma.CustomPaperDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomPaperUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomPaperUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperPayload>
          }
          aggregate: {
            args: Prisma.CustomPaperAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomPaper>
          }
          groupBy: {
            args: Prisma.CustomPaperGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomPaperGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomPaperCountArgs<ExtArgs>
            result: $Utils.Optional<CustomPaperCountAggregateOutputType> | number
          }
        }
      }
      CustomPaperMessage: {
        payload: Prisma.$CustomPaperMessagePayload<ExtArgs>
        fields: Prisma.CustomPaperMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomPaperMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomPaperMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperMessagePayload>
          }
          findFirst: {
            args: Prisma.CustomPaperMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomPaperMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperMessagePayload>
          }
          findMany: {
            args: Prisma.CustomPaperMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperMessagePayload>[]
          }
          create: {
            args: Prisma.CustomPaperMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperMessagePayload>
          }
          createMany: {
            args: Prisma.CustomPaperMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomPaperMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperMessagePayload>[]
          }
          delete: {
            args: Prisma.CustomPaperMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperMessagePayload>
          }
          update: {
            args: Prisma.CustomPaperMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperMessagePayload>
          }
          deleteMany: {
            args: Prisma.CustomPaperMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomPaperMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomPaperMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomPaperMessagePayload>
          }
          aggregate: {
            args: Prisma.CustomPaperMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomPaperMessage>
          }
          groupBy: {
            args: Prisma.CustomPaperMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomPaperMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomPaperMessageCountArgs<ExtArgs>
            result: $Utils.Optional<CustomPaperMessageCountAggregateOutputType> | number
          }
        }
      }
      CourseModule: {
        payload: Prisma.$CourseModulePayload<ExtArgs>
        fields: Prisma.CourseModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          findFirst: {
            args: Prisma.CourseModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          findMany: {
            args: Prisma.CourseModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
          }
          create: {
            args: Prisma.CourseModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          createMany: {
            args: Prisma.CourseModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
          }
          delete: {
            args: Prisma.CourseModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          update: {
            args: Prisma.CourseModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          deleteMany: {
            args: Prisma.CourseModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          aggregate: {
            args: Prisma.CourseModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseModule>
          }
          groupBy: {
            args: Prisma.CourseModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseModuleCountArgs<ExtArgs>
            result: $Utils.Optional<CourseModuleCountAggregateOutputType> | number
          }
        }
      }
      CourseLesson: {
        payload: Prisma.$CourseLessonPayload<ExtArgs>
        fields: Prisma.CourseLessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseLessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseLessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLessonPayload>
          }
          findFirst: {
            args: Prisma.CourseLessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseLessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLessonPayload>
          }
          findMany: {
            args: Prisma.CourseLessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLessonPayload>[]
          }
          create: {
            args: Prisma.CourseLessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLessonPayload>
          }
          createMany: {
            args: Prisma.CourseLessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseLessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLessonPayload>[]
          }
          delete: {
            args: Prisma.CourseLessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLessonPayload>
          }
          update: {
            args: Prisma.CourseLessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLessonPayload>
          }
          deleteMany: {
            args: Prisma.CourseLessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseLessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseLessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLessonPayload>
          }
          aggregate: {
            args: Prisma.CourseLessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseLesson>
          }
          groupBy: {
            args: Prisma.CourseLessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseLessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseLessonCountArgs<ExtArgs>
            result: $Utils.Optional<CourseLessonCountAggregateOutputType> | number
          }
        }
      }
      CourseProgress: {
        payload: Prisma.$CourseProgressPayload<ExtArgs>
        fields: Prisma.CourseProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>
          }
          findFirst: {
            args: Prisma.CourseProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>
          }
          findMany: {
            args: Prisma.CourseProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>[]
          }
          create: {
            args: Prisma.CourseProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>
          }
          createMany: {
            args: Prisma.CourseProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>[]
          }
          delete: {
            args: Prisma.CourseProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>
          }
          update: {
            args: Prisma.CourseProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>
          }
          deleteMany: {
            args: Prisma.CourseProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseProgressPayload>
          }
          aggregate: {
            args: Prisma.CourseProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseProgress>
          }
          groupBy: {
            args: Prisma.CourseProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseProgressCountArgs<ExtArgs>
            result: $Utils.Optional<CourseProgressCountAggregateOutputType> | number
          }
        }
      }
      CourseEnrollment: {
        payload: Prisma.$CourseEnrollmentPayload<ExtArgs>
        fields: Prisma.CourseEnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseEnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseEnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          findFirst: {
            args: Prisma.CourseEnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseEnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          findMany: {
            args: Prisma.CourseEnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>[]
          }
          create: {
            args: Prisma.CourseEnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          createMany: {
            args: Prisma.CourseEnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseEnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>[]
          }
          delete: {
            args: Prisma.CourseEnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          update: {
            args: Prisma.CourseEnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.CourseEnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseEnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseEnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          aggregate: {
            args: Prisma.CourseEnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseEnrollment>
          }
          groupBy: {
            args: Prisma.CourseEnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseEnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseEnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<CourseEnrollmentCountAggregateOutputType> | number
          }
        }
      }
      PostAnalytics: {
        payload: Prisma.$PostAnalyticsPayload<ExtArgs>
        fields: Prisma.PostAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.PostAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          findMany: {
            args: Prisma.PostAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>[]
          }
          create: {
            args: Prisma.PostAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          createMany: {
            args: Prisma.PostAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.PostAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          update: {
            args: Prisma.PostAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.PostAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.PostAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostAnalytics>
          }
          groupBy: {
            args: Prisma.PostAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<PostAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      NewsletterSubscriber: {
        payload: Prisma.$NewsletterSubscriberPayload<ExtArgs>
        fields: Prisma.NewsletterSubscriberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsletterSubscriberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsletterSubscriberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
          }
          findFirst: {
            args: Prisma.NewsletterSubscriberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsletterSubscriberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
          }
          findMany: {
            args: Prisma.NewsletterSubscriberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>[]
          }
          create: {
            args: Prisma.NewsletterSubscriberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
          }
          createMany: {
            args: Prisma.NewsletterSubscriberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsletterSubscriberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>[]
          }
          delete: {
            args: Prisma.NewsletterSubscriberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
          }
          update: {
            args: Prisma.NewsletterSubscriberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
          }
          deleteMany: {
            args: Prisma.NewsletterSubscriberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsletterSubscriberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsletterSubscriberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriberPayload>
          }
          aggregate: {
            args: Prisma.NewsletterSubscriberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsletterSubscriber>
          }
          groupBy: {
            args: Prisma.NewsletterSubscriberGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsletterSubscriberGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsletterSubscriberCountArgs<ExtArgs>
            result: $Utils.Optional<NewsletterSubscriberCountAggregateOutputType> | number
          }
        }
      }
      NewsletterSubscription: {
        payload: Prisma.$NewsletterSubscriptionPayload<ExtArgs>
        fields: Prisma.NewsletterSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsletterSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsletterSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.NewsletterSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsletterSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          findMany: {
            args: Prisma.NewsletterSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>[]
          }
          create: {
            args: Prisma.NewsletterSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          createMany: {
            args: Prisma.NewsletterSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsletterSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.NewsletterSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          update: {
            args: Prisma.NewsletterSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.NewsletterSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsletterSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsletterSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.NewsletterSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsletterSubscription>
          }
          groupBy: {
            args: Prisma.NewsletterSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsletterSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsletterSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<NewsletterSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      PostNotification: {
        payload: Prisma.$PostNotificationPayload<ExtArgs>
        fields: Prisma.PostNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostNotificationPayload>
          }
          findFirst: {
            args: Prisma.PostNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostNotificationPayload>
          }
          findMany: {
            args: Prisma.PostNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostNotificationPayload>[]
          }
          create: {
            args: Prisma.PostNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostNotificationPayload>
          }
          createMany: {
            args: Prisma.PostNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostNotificationPayload>[]
          }
          delete: {
            args: Prisma.PostNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostNotificationPayload>
          }
          update: {
            args: Prisma.PostNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostNotificationPayload>
          }
          deleteMany: {
            args: Prisma.PostNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostNotificationPayload>
          }
          aggregate: {
            args: Prisma.PostNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostNotification>
          }
          groupBy: {
            args: Prisma.PostNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<PostNotificationCountAggregateOutputType> | number
          }
        }
      }
      Evaluation: {
        payload: Prisma.$EvaluationPayload<ExtArgs>
        fields: Prisma.EvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          findFirst: {
            args: Prisma.EvaluationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          findMany: {
            args: Prisma.EvaluationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>[]
          }
          create: {
            args: Prisma.EvaluationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          createMany: {
            args: Prisma.EvaluationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>[]
          }
          delete: {
            args: Prisma.EvaluationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          update: {
            args: Prisma.EvaluationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvaluationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          aggregate: {
            args: Prisma.EvaluationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluation>
          }
          groupBy: {
            args: Prisma.EvaluationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluationCountAggregateOutputType> | number
          }
        }
      }
      Note: {
        payload: Prisma.$NotePayload<ExtArgs>
        fields: Prisma.NoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findFirst: {
            args: Prisma.NoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findMany: {
            args: Prisma.NoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          create: {
            args: Prisma.NoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          createMany: {
            args: Prisma.NoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          delete: {
            args: Prisma.NoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          update: {
            args: Prisma.NoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          deleteMany: {
            args: Prisma.NoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          aggregate: {
            args: Prisma.NoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNote>
          }
          groupBy: {
            args: Prisma.NoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteCountArgs<ExtArgs>
            result: $Utils.Optional<NoteCountAggregateOutputType> | number
          }
        }
      }
      Interview: {
        payload: Prisma.$InterviewPayload<ExtArgs>
        fields: Prisma.InterviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          findFirst: {
            args: Prisma.InterviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          findMany: {
            args: Prisma.InterviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>[]
          }
          create: {
            args: Prisma.InterviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          createMany: {
            args: Prisma.InterviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>[]
          }
          delete: {
            args: Prisma.InterviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          update: {
            args: Prisma.InterviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          deleteMany: {
            args: Prisma.InterviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InterviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          aggregate: {
            args: Prisma.InterviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterview>
          }
          groupBy: {
            args: Prisma.InterviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterviewCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewCountAggregateOutputType> | number
          }
        }
      }
      ApiIntegration: {
        payload: Prisma.$ApiIntegrationPayload<ExtArgs>
        fields: Prisma.ApiIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiIntegrationPayload>
          }
          findFirst: {
            args: Prisma.ApiIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiIntegrationPayload>
          }
          findMany: {
            args: Prisma.ApiIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiIntegrationPayload>[]
          }
          create: {
            args: Prisma.ApiIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiIntegrationPayload>
          }
          createMany: {
            args: Prisma.ApiIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiIntegrationPayload>[]
          }
          delete: {
            args: Prisma.ApiIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiIntegrationPayload>
          }
          update: {
            args: Prisma.ApiIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.ApiIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiIntegrationPayload>
          }
          aggregate: {
            args: Prisma.ApiIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiIntegration>
          }
          groupBy: {
            args: Prisma.ApiIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<ApiIntegrationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    orders: number
    collaboratorApplications: number
    reviewedApplications: number
    evaluations: number
    notes: number
    interviews: number
    certificates: number
    library: number
    customPapers: number
    customPaperMessages: number
    courseProgress: number
    courseEnrollments: number
    blogPosts: number
    comments: number
    likes: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    collaboratorApplications?: boolean | UserCountOutputTypeCountCollaboratorApplicationsArgs
    reviewedApplications?: boolean | UserCountOutputTypeCountReviewedApplicationsArgs
    evaluations?: boolean | UserCountOutputTypeCountEvaluationsArgs
    notes?: boolean | UserCountOutputTypeCountNotesArgs
    interviews?: boolean | UserCountOutputTypeCountInterviewsArgs
    certificates?: boolean | UserCountOutputTypeCountCertificatesArgs
    library?: boolean | UserCountOutputTypeCountLibraryArgs
    customPapers?: boolean | UserCountOutputTypeCountCustomPapersArgs
    customPaperMessages?: boolean | UserCountOutputTypeCountCustomPaperMessagesArgs
    courseProgress?: boolean | UserCountOutputTypeCountCourseProgressArgs
    courseEnrollments?: boolean | UserCountOutputTypeCountCourseEnrollmentsArgs
    blogPosts?: boolean | UserCountOutputTypeCountBlogPostsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    likes?: boolean | UserCountOutputTypeCountLikesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCollaboratorApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollaboratorApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewedApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollaboratorApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInterviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLibraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LibraryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCustomPapersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomPaperWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCustomPaperMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomPaperMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCourseProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCourseEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseEnrollmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type PaperCountOutputType
   */

  export type PaperCountOutputType = {
    orderItems: number
  }

  export type PaperCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | PaperCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * PaperCountOutputType without action
   */
  export type PaperCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaperCountOutputType
     */
    select?: PaperCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaperCountOutputType without action
   */
  export type PaperCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    orderItems: number
    certificates: number
    modules: number
    enrollments: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | CourseCountOutputTypeCountOrderItemsArgs
    certificates?: boolean | CourseCountOutputTypeCountCertificatesArgs
    modules?: boolean | CourseCountOutputTypeCountModulesArgs
    enrollments?: boolean | CourseCountOutputTypeCountEnrollmentsArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseModuleWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseEnrollmentWhereInput
  }


  /**
   * Count Type EbookCountOutputType
   */

  export type EbookCountOutputType = {
    files: number
    orderItems: number
  }

  export type EbookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | EbookCountOutputTypeCountFilesArgs
    orderItems?: boolean | EbookCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * EbookCountOutputType without action
   */
  export type EbookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EbookCountOutputType
     */
    select?: EbookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EbookCountOutputType without action
   */
  export type EbookCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EbookFileWhereInput
  }

  /**
   * EbookCountOutputType without action
   */
  export type EbookCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    posts: number
    subscribers: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | CategoryCountOutputTypeCountPostsArgs
    subscribers?: boolean | CategoryCountOutputTypeCountSubscribersArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSubscribersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsletterSubscriptionWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    posts: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | TagCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogTagWhereInput
  }


  /**
   * Count Type BlogPostCountOutputType
   */

  export type BlogPostCountOutputType = {
    tags: number
    comments: number
    likes: number
    analytics: number
    notifications: number
  }

  export type BlogPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | BlogPostCountOutputTypeCountTagsArgs
    comments?: boolean | BlogPostCountOutputTypeCountCommentsArgs
    likes?: boolean | BlogPostCountOutputTypeCountLikesArgs
    analytics?: boolean | BlogPostCountOutputTypeCountAnalyticsArgs
    notifications?: boolean | BlogPostCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostCountOutputType
     */
    select?: BlogPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogTagWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostAnalyticsWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostNotificationWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type CollaboratorApplicationCountOutputType
   */

  export type CollaboratorApplicationCountOutputType = {
    evaluations: number
    notes: number
    interviews: number
  }

  export type CollaboratorApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | CollaboratorApplicationCountOutputTypeCountEvaluationsArgs
    notes?: boolean | CollaboratorApplicationCountOutputTypeCountNotesArgs
    interviews?: boolean | CollaboratorApplicationCountOutputTypeCountInterviewsArgs
  }

  // Custom InputTypes
  /**
   * CollaboratorApplicationCountOutputType without action
   */
  export type CollaboratorApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorApplicationCountOutputType
     */
    select?: CollaboratorApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollaboratorApplicationCountOutputType without action
   */
  export type CollaboratorApplicationCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }

  /**
   * CollaboratorApplicationCountOutputType without action
   */
  export type CollaboratorApplicationCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * CollaboratorApplicationCountOutputType without action
   */
  export type CollaboratorApplicationCountOutputTypeCountInterviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewWhereInput
  }


  /**
   * Count Type CustomPaperCountOutputType
   */

  export type CustomPaperCountOutputType = {
    messages: number
  }

  export type CustomPaperCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | CustomPaperCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * CustomPaperCountOutputType without action
   */
  export type CustomPaperCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaperCountOutputType
     */
    select?: CustomPaperCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomPaperCountOutputType without action
   */
  export type CustomPaperCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomPaperMessageWhereInput
  }


  /**
   * Count Type CourseModuleCountOutputType
   */

  export type CourseModuleCountOutputType = {
    lessons: number
  }

  export type CourseModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | CourseModuleCountOutputTypeCountLessonsArgs
  }

  // Custom InputTypes
  /**
   * CourseModuleCountOutputType without action
   */
  export type CourseModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModuleCountOutputType
     */
    select?: CourseModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseModuleCountOutputType without action
   */
  export type CourseModuleCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseLessonWhereInput
  }


  /**
   * Count Type CourseLessonCountOutputType
   */

  export type CourseLessonCountOutputType = {
    progress: number
  }

  export type CourseLessonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progress?: boolean | CourseLessonCountOutputTypeCountProgressArgs
  }

  // Custom InputTypes
  /**
   * CourseLessonCountOutputType without action
   */
  export type CourseLessonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLessonCountOutputType
     */
    select?: CourseLessonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseLessonCountOutputType without action
   */
  export type CourseLessonCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseProgressWhereInput
  }


  /**
   * Count Type NewsletterSubscriberCountOutputType
   */

  export type NewsletterSubscriberCountOutputType = {
    subscriptions: number
  }

  export type NewsletterSubscriberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | NewsletterSubscriberCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * NewsletterSubscriberCountOutputType without action
   */
  export type NewsletterSubscriberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriberCountOutputType
     */
    select?: NewsletterSubscriberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NewsletterSubscriberCountOutputType without action
   */
  export type NewsletterSubscriberCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsletterSubscriptionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    verified: boolean | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    phone: string | null
    birthDate: string | null
    profession: string | null
    profileImageUrl: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    verified: boolean | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    phone: string | null
    birthDate: string | null
    profession: string | null
    profileImageUrl: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    verified: number
    resetToken: number
    resetTokenExpiry: number
    createdAt: number
    updatedAt: number
    phone: number
    birthDate: number
    profession: number
    profileImageUrl: number
    address: number
    city: number
    state: number
    zipCode: number
    country: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    verified?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
    phone?: true
    birthDate?: true
    profession?: true
    profileImageUrl?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    verified?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
    phone?: true
    birthDate?: true
    profession?: true
    profileImageUrl?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    verified?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
    phone?: true
    birthDate?: true
    profession?: true
    profileImageUrl?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    role: $Enums.UserRole
    verified: boolean
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date
    updatedAt: Date
    phone: string | null
    birthDate: string | null
    profession: string | null
    profileImageUrl: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    verified?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phone?: boolean
    birthDate?: boolean
    profession?: boolean
    profileImageUrl?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    orders?: boolean | User$ordersArgs<ExtArgs>
    collaboratorApplications?: boolean | User$collaboratorApplicationsArgs<ExtArgs>
    reviewedApplications?: boolean | User$reviewedApplicationsArgs<ExtArgs>
    evaluations?: boolean | User$evaluationsArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    interviews?: boolean | User$interviewsArgs<ExtArgs>
    certificates?: boolean | User$certificatesArgs<ExtArgs>
    library?: boolean | User$libraryArgs<ExtArgs>
    customPapers?: boolean | User$customPapersArgs<ExtArgs>
    customPaperMessages?: boolean | User$customPaperMessagesArgs<ExtArgs>
    courseProgress?: boolean | User$courseProgressArgs<ExtArgs>
    courseEnrollments?: boolean | User$courseEnrollmentsArgs<ExtArgs>
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    verified?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phone?: boolean
    birthDate?: boolean
    profession?: boolean
    profileImageUrl?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    verified?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phone?: boolean
    birthDate?: boolean
    profession?: boolean
    profileImageUrl?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | User$ordersArgs<ExtArgs>
    collaboratorApplications?: boolean | User$collaboratorApplicationsArgs<ExtArgs>
    reviewedApplications?: boolean | User$reviewedApplicationsArgs<ExtArgs>
    evaluations?: boolean | User$evaluationsArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    interviews?: boolean | User$interviewsArgs<ExtArgs>
    certificates?: boolean | User$certificatesArgs<ExtArgs>
    library?: boolean | User$libraryArgs<ExtArgs>
    customPapers?: boolean | User$customPapersArgs<ExtArgs>
    customPaperMessages?: boolean | User$customPaperMessagesArgs<ExtArgs>
    courseProgress?: boolean | User$courseProgressArgs<ExtArgs>
    courseEnrollments?: boolean | User$courseEnrollmentsArgs<ExtArgs>
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
      collaboratorApplications: Prisma.$CollaboratorApplicationPayload<ExtArgs>[]
      reviewedApplications: Prisma.$CollaboratorApplicationPayload<ExtArgs>[]
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
      interviews: Prisma.$InterviewPayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
      library: Prisma.$LibraryPayload<ExtArgs>[]
      customPapers: Prisma.$CustomPaperPayload<ExtArgs>[]
      customPaperMessages: Prisma.$CustomPaperMessagePayload<ExtArgs>[]
      courseProgress: Prisma.$CourseProgressPayload<ExtArgs>[]
      courseEnrollments: Prisma.$CourseEnrollmentPayload<ExtArgs>[]
      blogPosts: Prisma.$BlogPostPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      role: $Enums.UserRole
      verified: boolean
      resetToken: string | null
      resetTokenExpiry: Date | null
      createdAt: Date
      updatedAt: Date
      phone: string | null
      birthDate: string | null
      profession: string | null
      profileImageUrl: string | null
      address: string | null
      city: string | null
      state: string | null
      zipCode: string | null
      country: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    collaboratorApplications<T extends User$collaboratorApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$collaboratorApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollaboratorApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    reviewedApplications<T extends User$reviewedApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewedApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollaboratorApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    evaluations<T extends User$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, User$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findMany"> | Null>
    notes<T extends User$notesArgs<ExtArgs> = {}>(args?: Subset<T, User$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany"> | Null>
    interviews<T extends User$interviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$interviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findMany"> | Null>
    certificates<T extends User$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, User$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany"> | Null>
    library<T extends User$libraryArgs<ExtArgs> = {}>(args?: Subset<T, User$libraryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryPayload<ExtArgs>, T, "findMany"> | Null>
    customPapers<T extends User$customPapersArgs<ExtArgs> = {}>(args?: Subset<T, User$customPapersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomPaperPayload<ExtArgs>, T, "findMany"> | Null>
    customPaperMessages<T extends User$customPaperMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$customPaperMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomPaperMessagePayload<ExtArgs>, T, "findMany"> | Null>
    courseProgress<T extends User$courseProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$courseProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "findMany"> | Null>
    courseEnrollments<T extends User$courseEnrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$courseEnrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findMany"> | Null>
    blogPosts<T extends User$blogPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$blogPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    likes<T extends User$likesArgs<ExtArgs> = {}>(args?: Subset<T, User$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly verified: FieldRef<"User", 'Boolean'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly phone: FieldRef<"User", 'String'>
    readonly birthDate: FieldRef<"User", 'String'>
    readonly profession: FieldRef<"User", 'String'>
    readonly profileImageUrl: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly state: FieldRef<"User", 'String'>
    readonly zipCode: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.collaboratorApplications
   */
  export type User$collaboratorApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorApplication
     */
    select?: CollaboratorApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaboratorApplicationInclude<ExtArgs> | null
    where?: CollaboratorApplicationWhereInput
    orderBy?: CollaboratorApplicationOrderByWithRelationInput | CollaboratorApplicationOrderByWithRelationInput[]
    cursor?: CollaboratorApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollaboratorApplicationScalarFieldEnum | CollaboratorApplicationScalarFieldEnum[]
  }

  /**
   * User.reviewedApplications
   */
  export type User$reviewedApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorApplication
     */
    select?: CollaboratorApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaboratorApplicationInclude<ExtArgs> | null
    where?: CollaboratorApplicationWhereInput
    orderBy?: CollaboratorApplicationOrderByWithRelationInput | CollaboratorApplicationOrderByWithRelationInput[]
    cursor?: CollaboratorApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollaboratorApplicationScalarFieldEnum | CollaboratorApplicationScalarFieldEnum[]
  }

  /**
   * User.evaluations
   */
  export type User$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * User.notes
   */
  export type User$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * User.interviews
   */
  export type User$interviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    where?: InterviewWhereInput
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    cursor?: InterviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * User.certificates
   */
  export type User$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * User.library
   */
  export type User$libraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryInclude<ExtArgs> | null
    where?: LibraryWhereInput
    orderBy?: LibraryOrderByWithRelationInput | LibraryOrderByWithRelationInput[]
    cursor?: LibraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LibraryScalarFieldEnum | LibraryScalarFieldEnum[]
  }

  /**
   * User.customPapers
   */
  export type User$customPapersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaper
     */
    select?: CustomPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperInclude<ExtArgs> | null
    where?: CustomPaperWhereInput
    orderBy?: CustomPaperOrderByWithRelationInput | CustomPaperOrderByWithRelationInput[]
    cursor?: CustomPaperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomPaperScalarFieldEnum | CustomPaperScalarFieldEnum[]
  }

  /**
   * User.customPaperMessages
   */
  export type User$customPaperMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaperMessage
     */
    select?: CustomPaperMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperMessageInclude<ExtArgs> | null
    where?: CustomPaperMessageWhereInput
    orderBy?: CustomPaperMessageOrderByWithRelationInput | CustomPaperMessageOrderByWithRelationInput[]
    cursor?: CustomPaperMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomPaperMessageScalarFieldEnum | CustomPaperMessageScalarFieldEnum[]
  }

  /**
   * User.courseProgress
   */
  export type User$courseProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    where?: CourseProgressWhereInput
    orderBy?: CourseProgressOrderByWithRelationInput | CourseProgressOrderByWithRelationInput[]
    cursor?: CourseProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseProgressScalarFieldEnum | CourseProgressScalarFieldEnum[]
  }

  /**
   * User.courseEnrollments
   */
  export type User$courseEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    where?: CourseEnrollmentWhereInput
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    cursor?: CourseEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseEnrollmentScalarFieldEnum | CourseEnrollmentScalarFieldEnum[]
  }

  /**
   * User.blogPosts
   */
  export type User$blogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.likes
   */
  export type User$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    totalAmount: number | null
  }

  export type OrderSumAggregateOutputType = {
    totalAmount: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    totalAmount: number | null
    status: $Enums.OrderStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentStatus: $Enums.PaymentStatus | null
    customerName: string | null
    customerEmail: string | null
    customerCpfCnpj: string | null
    customerPhone: string | null
    pixCode: string | null
    boletoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    totalAmount: number | null
    status: $Enums.OrderStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentStatus: $Enums.PaymentStatus | null
    customerName: string | null
    customerEmail: string | null
    customerCpfCnpj: string | null
    customerPhone: string | null
    pixCode: string | null
    boletoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    userId: number
    totalAmount: number
    status: number
    paymentMethod: number
    paymentStatus: number
    customerName: number
    customerEmail: number
    customerCpfCnpj: number
    customerPhone: number
    pixCode: number
    boletoUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    totalAmount?: true
  }

  export type OrderSumAggregateInputType = {
    totalAmount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
    status?: true
    paymentMethod?: true
    paymentStatus?: true
    customerName?: true
    customerEmail?: true
    customerCpfCnpj?: true
    customerPhone?: true
    pixCode?: true
    boletoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
    status?: true
    paymentMethod?: true
    paymentStatus?: true
    customerName?: true
    customerEmail?: true
    customerCpfCnpj?: true
    customerPhone?: true
    pixCode?: true
    boletoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
    status?: true
    paymentMethod?: true
    paymentStatus?: true
    customerName?: true
    customerEmail?: true
    customerCpfCnpj?: true
    customerPhone?: true
    pixCode?: true
    boletoUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    userId: string | null
    totalAmount: number
    status: $Enums.OrderStatus
    paymentMethod: $Enums.PaymentMethod | null
    paymentStatus: $Enums.PaymentStatus
    customerName: string
    customerEmail: string
    customerCpfCnpj: string
    customerPhone: string | null
    pixCode: string | null
    boletoUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalAmount?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerCpfCnpj?: boolean
    customerPhone?: boolean
    pixCode?: boolean
    boletoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Order$userArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    customPaper?: boolean | Order$customPaperArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalAmount?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerCpfCnpj?: boolean
    customerPhone?: boolean
    pixCode?: boolean
    boletoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Order$userArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    userId?: boolean
    totalAmount?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerCpfCnpj?: boolean
    customerPhone?: boolean
    pixCode?: boolean
    boletoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Order$userArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    customPaper?: boolean | Order$customPaperArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Order$userArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      customPaper: Prisma.$CustomPaperPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      totalAmount: number
      status: $Enums.OrderStatus
      paymentMethod: $Enums.PaymentMethod | null
      paymentStatus: $Enums.PaymentStatus
      customerName: string
      customerEmail: string
      customerCpfCnpj: string
      customerPhone: string | null
      pixCode: string | null
      boletoUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Order$userArgs<ExtArgs> = {}>(args?: Subset<T, Order$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    customPaper<T extends Order$customPaperArgs<ExtArgs> = {}>(args?: Subset<T, Order$customPaperArgs<ExtArgs>>): Prisma__CustomPaperClient<$Result.GetResult<Prisma.$CustomPaperPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly totalAmount: FieldRef<"Order", 'Int'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly paymentMethod: FieldRef<"Order", 'PaymentMethod'>
    readonly paymentStatus: FieldRef<"Order", 'PaymentStatus'>
    readonly customerName: FieldRef<"Order", 'String'>
    readonly customerEmail: FieldRef<"Order", 'String'>
    readonly customerCpfCnpj: FieldRef<"Order", 'String'>
    readonly customerPhone: FieldRef<"Order", 'String'>
    readonly pixCode: FieldRef<"Order", 'String'>
    readonly boletoUrl: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.user
   */
  export type Order$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.customPaper
   */
  export type Order$customPaperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaper
     */
    select?: CustomPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperInclude<ExtArgs> | null
    where?: CustomPaperWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    price: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    price: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    title: string | null
    description: string | null
    price: number | null
    paperId: string | null
    courseId: string | null
    ebookId: string | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    title: string | null
    description: string | null
    price: number | null
    paperId: string | null
    courseId: string | null
    ebookId: string | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    title: number
    description: number
    price: number
    paperId: number
    courseId: number
    ebookId: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    price?: true
  }

  export type OrderItemSumAggregateInputType = {
    price?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    title?: true
    description?: true
    price?: true
    paperId?: true
    courseId?: true
    ebookId?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    title?: true
    description?: true
    price?: true
    paperId?: true
    courseId?: true
    ebookId?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    title?: true
    description?: true
    price?: true
    paperId?: true
    courseId?: true
    ebookId?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    title: string
    description: string | null
    price: number
    paperId: string | null
    courseId: string | null
    ebookId: string | null
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    paperId?: boolean
    courseId?: boolean
    ebookId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    paper?: boolean | OrderItem$paperArgs<ExtArgs>
    course?: boolean | OrderItem$courseArgs<ExtArgs>
    ebook?: boolean | OrderItem$ebookArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    paperId?: boolean
    courseId?: boolean
    ebookId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    paper?: boolean | OrderItem$paperArgs<ExtArgs>
    course?: boolean | OrderItem$courseArgs<ExtArgs>
    ebook?: boolean | OrderItem$ebookArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    paperId?: boolean
    courseId?: boolean
    ebookId?: boolean
  }

  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    paper?: boolean | OrderItem$paperArgs<ExtArgs>
    course?: boolean | OrderItem$courseArgs<ExtArgs>
    ebook?: boolean | OrderItem$ebookArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    paper?: boolean | OrderItem$paperArgs<ExtArgs>
    course?: boolean | OrderItem$courseArgs<ExtArgs>
    ebook?: boolean | OrderItem$ebookArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      paper: Prisma.$PaperPayload<ExtArgs> | null
      course: Prisma.$CoursePayload<ExtArgs> | null
      ebook: Prisma.$EbookPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      title: string
      description: string | null
      price: number
      paperId: string | null
      courseId: string | null
      ebookId: string | null
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    paper<T extends OrderItem$paperArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$paperArgs<ExtArgs>>): Prisma__PaperClient<$Result.GetResult<Prisma.$PaperPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    course<T extends OrderItem$courseArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ebook<T extends OrderItem$ebookArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$ebookArgs<ExtArgs>>): Prisma__EbookClient<$Result.GetResult<Prisma.$EbookPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */ 
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly title: FieldRef<"OrderItem", 'String'>
    readonly description: FieldRef<"OrderItem", 'String'>
    readonly price: FieldRef<"OrderItem", 'Int'>
    readonly paperId: FieldRef<"OrderItem", 'String'>
    readonly courseId: FieldRef<"OrderItem", 'String'>
    readonly ebookId: FieldRef<"OrderItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem.paper
   */
  export type OrderItem$paperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paper
     */
    select?: PaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperInclude<ExtArgs> | null
    where?: PaperWhereInput
  }

  /**
   * OrderItem.course
   */
  export type OrderItem$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * OrderItem.ebook
   */
  export type OrderItem$ebookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ebook
     */
    select?: EbookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookInclude<ExtArgs> | null
    where?: EbookWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Paper
   */

  export type AggregatePaper = {
    _count: PaperCountAggregateOutputType | null
    _avg: PaperAvgAggregateOutputType | null
    _sum: PaperSumAggregateOutputType | null
    _min: PaperMinAggregateOutputType | null
    _max: PaperMaxAggregateOutputType | null
  }

  export type PaperAvgAggregateOutputType = {
    price: number | null
    pageCount: number | null
  }

  export type PaperSumAggregateOutputType = {
    price: number | null
    pageCount: number | null
  }

  export type PaperMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    paperType: $Enums.PaperType | null
    academicArea: $Enums.AcademicArea | null
    price: number | null
    pageCount: number | null
    authorName: string | null
    language: string | null
    keywords: string | null
    previewUrl: string | null
    fileUrl: string | null
    thumbnailUrl: string | null
    isFree: boolean | null
    createdAt: Date | null
  }

  export type PaperMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    paperType: $Enums.PaperType | null
    academicArea: $Enums.AcademicArea | null
    price: number | null
    pageCount: number | null
    authorName: string | null
    language: string | null
    keywords: string | null
    previewUrl: string | null
    fileUrl: string | null
    thumbnailUrl: string | null
    isFree: boolean | null
    createdAt: Date | null
  }

  export type PaperCountAggregateOutputType = {
    id: number
    title: number
    description: number
    paperType: number
    academicArea: number
    price: number
    pageCount: number
    authorName: number
    language: number
    keywords: number
    previewUrl: number
    fileUrl: number
    thumbnailUrl: number
    isFree: number
    createdAt: number
    _all: number
  }


  export type PaperAvgAggregateInputType = {
    price?: true
    pageCount?: true
  }

  export type PaperSumAggregateInputType = {
    price?: true
    pageCount?: true
  }

  export type PaperMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    paperType?: true
    academicArea?: true
    price?: true
    pageCount?: true
    authorName?: true
    language?: true
    keywords?: true
    previewUrl?: true
    fileUrl?: true
    thumbnailUrl?: true
    isFree?: true
    createdAt?: true
  }

  export type PaperMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    paperType?: true
    academicArea?: true
    price?: true
    pageCount?: true
    authorName?: true
    language?: true
    keywords?: true
    previewUrl?: true
    fileUrl?: true
    thumbnailUrl?: true
    isFree?: true
    createdAt?: true
  }

  export type PaperCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    paperType?: true
    academicArea?: true
    price?: true
    pageCount?: true
    authorName?: true
    language?: true
    keywords?: true
    previewUrl?: true
    fileUrl?: true
    thumbnailUrl?: true
    isFree?: true
    createdAt?: true
    _all?: true
  }

  export type PaperAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paper to aggregate.
     */
    where?: PaperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Papers to fetch.
     */
    orderBy?: PaperOrderByWithRelationInput | PaperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Papers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Papers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Papers
    **/
    _count?: true | PaperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaperMaxAggregateInputType
  }

  export type GetPaperAggregateType<T extends PaperAggregateArgs> = {
        [P in keyof T & keyof AggregatePaper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaper[P]>
      : GetScalarType<T[P], AggregatePaper[P]>
  }




  export type PaperGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaperWhereInput
    orderBy?: PaperOrderByWithAggregationInput | PaperOrderByWithAggregationInput[]
    by: PaperScalarFieldEnum[] | PaperScalarFieldEnum
    having?: PaperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaperCountAggregateInputType | true
    _avg?: PaperAvgAggregateInputType
    _sum?: PaperSumAggregateInputType
    _min?: PaperMinAggregateInputType
    _max?: PaperMaxAggregateInputType
  }

  export type PaperGroupByOutputType = {
    id: string
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    price: number
    pageCount: number
    authorName: string
    language: string
    keywords: string | null
    previewUrl: string | null
    fileUrl: string
    thumbnailUrl: string | null
    isFree: boolean
    createdAt: Date
    _count: PaperCountAggregateOutputType | null
    _avg: PaperAvgAggregateOutputType | null
    _sum: PaperSumAggregateOutputType | null
    _min: PaperMinAggregateOutputType | null
    _max: PaperMaxAggregateOutputType | null
  }

  type GetPaperGroupByPayload<T extends PaperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaperGroupByOutputType[P]>
            : GetScalarType<T[P], PaperGroupByOutputType[P]>
        }
      >
    >


  export type PaperSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    paperType?: boolean
    academicArea?: boolean
    price?: boolean
    pageCount?: boolean
    authorName?: boolean
    language?: boolean
    keywords?: boolean
    previewUrl?: boolean
    fileUrl?: boolean
    thumbnailUrl?: boolean
    isFree?: boolean
    createdAt?: boolean
    orderItems?: boolean | Paper$orderItemsArgs<ExtArgs>
    _count?: boolean | PaperCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paper"]>

  export type PaperSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    paperType?: boolean
    academicArea?: boolean
    price?: boolean
    pageCount?: boolean
    authorName?: boolean
    language?: boolean
    keywords?: boolean
    previewUrl?: boolean
    fileUrl?: boolean
    thumbnailUrl?: boolean
    isFree?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["paper"]>

  export type PaperSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    paperType?: boolean
    academicArea?: boolean
    price?: boolean
    pageCount?: boolean
    authorName?: boolean
    language?: boolean
    keywords?: boolean
    previewUrl?: boolean
    fileUrl?: boolean
    thumbnailUrl?: boolean
    isFree?: boolean
    createdAt?: boolean
  }

  export type PaperInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | Paper$orderItemsArgs<ExtArgs>
    _count?: boolean | PaperCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaperIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PaperPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Paper"
    objects: {
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      paperType: $Enums.PaperType
      academicArea: $Enums.AcademicArea
      price: number
      pageCount: number
      authorName: string
      language: string
      keywords: string | null
      previewUrl: string | null
      fileUrl: string
      thumbnailUrl: string | null
      isFree: boolean
      createdAt: Date
    }, ExtArgs["result"]["paper"]>
    composites: {}
  }

  type PaperGetPayload<S extends boolean | null | undefined | PaperDefaultArgs> = $Result.GetResult<Prisma.$PaperPayload, S>

  type PaperCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaperFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaperCountAggregateInputType | true
    }

  export interface PaperDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Paper'], meta: { name: 'Paper' } }
    /**
     * Find zero or one Paper that matches the filter.
     * @param {PaperFindUniqueArgs} args - Arguments to find a Paper
     * @example
     * // Get one Paper
     * const paper = await prisma.paper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaperFindUniqueArgs>(args: SelectSubset<T, PaperFindUniqueArgs<ExtArgs>>): Prisma__PaperClient<$Result.GetResult<Prisma.$PaperPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Paper that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaperFindUniqueOrThrowArgs} args - Arguments to find a Paper
     * @example
     * // Get one Paper
     * const paper = await prisma.paper.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaperFindUniqueOrThrowArgs>(args: SelectSubset<T, PaperFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaperClient<$Result.GetResult<Prisma.$PaperPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Paper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperFindFirstArgs} args - Arguments to find a Paper
     * @example
     * // Get one Paper
     * const paper = await prisma.paper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaperFindFirstArgs>(args?: SelectSubset<T, PaperFindFirstArgs<ExtArgs>>): Prisma__PaperClient<$Result.GetResult<Prisma.$PaperPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Paper that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperFindFirstOrThrowArgs} args - Arguments to find a Paper
     * @example
     * // Get one Paper
     * const paper = await prisma.paper.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaperFindFirstOrThrowArgs>(args?: SelectSubset<T, PaperFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaperClient<$Result.GetResult<Prisma.$PaperPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Papers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Papers
     * const papers = await prisma.paper.findMany()
     * 
     * // Get first 10 Papers
     * const papers = await prisma.paper.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paperWithIdOnly = await prisma.paper.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaperFindManyArgs>(args?: SelectSubset<T, PaperFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaperPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Paper.
     * @param {PaperCreateArgs} args - Arguments to create a Paper.
     * @example
     * // Create one Paper
     * const Paper = await prisma.paper.create({
     *   data: {
     *     // ... data to create a Paper
     *   }
     * })
     * 
     */
    create<T extends PaperCreateArgs>(args: SelectSubset<T, PaperCreateArgs<ExtArgs>>): Prisma__PaperClient<$Result.GetResult<Prisma.$PaperPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Papers.
     * @param {PaperCreateManyArgs} args - Arguments to create many Papers.
     * @example
     * // Create many Papers
     * const paper = await prisma.paper.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaperCreateManyArgs>(args?: SelectSubset<T, PaperCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Papers and returns the data saved in the database.
     * @param {PaperCreateManyAndReturnArgs} args - Arguments to create many Papers.
     * @example
     * // Create many Papers
     * const paper = await prisma.paper.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Papers and only return the `id`
     * const paperWithIdOnly = await prisma.paper.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaperCreateManyAndReturnArgs>(args?: SelectSubset<T, PaperCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaperPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Paper.
     * @param {PaperDeleteArgs} args - Arguments to delete one Paper.
     * @example
     * // Delete one Paper
     * const Paper = await prisma.paper.delete({
     *   where: {
     *     // ... filter to delete one Paper
     *   }
     * })
     * 
     */
    delete<T extends PaperDeleteArgs>(args: SelectSubset<T, PaperDeleteArgs<ExtArgs>>): Prisma__PaperClient<$Result.GetResult<Prisma.$PaperPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Paper.
     * @param {PaperUpdateArgs} args - Arguments to update one Paper.
     * @example
     * // Update one Paper
     * const paper = await prisma.paper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaperUpdateArgs>(args: SelectSubset<T, PaperUpdateArgs<ExtArgs>>): Prisma__PaperClient<$Result.GetResult<Prisma.$PaperPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Papers.
     * @param {PaperDeleteManyArgs} args - Arguments to filter Papers to delete.
     * @example
     * // Delete a few Papers
     * const { count } = await prisma.paper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaperDeleteManyArgs>(args?: SelectSubset<T, PaperDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Papers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Papers
     * const paper = await prisma.paper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaperUpdateManyArgs>(args: SelectSubset<T, PaperUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Paper.
     * @param {PaperUpsertArgs} args - Arguments to update or create a Paper.
     * @example
     * // Update or create a Paper
     * const paper = await prisma.paper.upsert({
     *   create: {
     *     // ... data to create a Paper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paper we want to update
     *   }
     * })
     */
    upsert<T extends PaperUpsertArgs>(args: SelectSubset<T, PaperUpsertArgs<ExtArgs>>): Prisma__PaperClient<$Result.GetResult<Prisma.$PaperPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Papers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperCountArgs} args - Arguments to filter Papers to count.
     * @example
     * // Count the number of Papers
     * const count = await prisma.paper.count({
     *   where: {
     *     // ... the filter for the Papers we want to count
     *   }
     * })
    **/
    count<T extends PaperCountArgs>(
      args?: Subset<T, PaperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaperAggregateArgs>(args: Subset<T, PaperAggregateArgs>): Prisma.PrismaPromise<GetPaperAggregateType<T>>

    /**
     * Group by Paper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaperGroupByArgs['orderBy'] }
        : { orderBy?: PaperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Paper model
   */
  readonly fields: PaperFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Paper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaperClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends Paper$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Paper$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Paper model
   */ 
  interface PaperFieldRefs {
    readonly id: FieldRef<"Paper", 'String'>
    readonly title: FieldRef<"Paper", 'String'>
    readonly description: FieldRef<"Paper", 'String'>
    readonly paperType: FieldRef<"Paper", 'PaperType'>
    readonly academicArea: FieldRef<"Paper", 'AcademicArea'>
    readonly price: FieldRef<"Paper", 'Int'>
    readonly pageCount: FieldRef<"Paper", 'Int'>
    readonly authorName: FieldRef<"Paper", 'String'>
    readonly language: FieldRef<"Paper", 'String'>
    readonly keywords: FieldRef<"Paper", 'String'>
    readonly previewUrl: FieldRef<"Paper", 'String'>
    readonly fileUrl: FieldRef<"Paper", 'String'>
    readonly thumbnailUrl: FieldRef<"Paper", 'String'>
    readonly isFree: FieldRef<"Paper", 'Boolean'>
    readonly createdAt: FieldRef<"Paper", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Paper findUnique
   */
  export type PaperFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paper
     */
    select?: PaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperInclude<ExtArgs> | null
    /**
     * Filter, which Paper to fetch.
     */
    where: PaperWhereUniqueInput
  }

  /**
   * Paper findUniqueOrThrow
   */
  export type PaperFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paper
     */
    select?: PaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperInclude<ExtArgs> | null
    /**
     * Filter, which Paper to fetch.
     */
    where: PaperWhereUniqueInput
  }

  /**
   * Paper findFirst
   */
  export type PaperFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paper
     */
    select?: PaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperInclude<ExtArgs> | null
    /**
     * Filter, which Paper to fetch.
     */
    where?: PaperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Papers to fetch.
     */
    orderBy?: PaperOrderByWithRelationInput | PaperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Papers.
     */
    cursor?: PaperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Papers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Papers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Papers.
     */
    distinct?: PaperScalarFieldEnum | PaperScalarFieldEnum[]
  }

  /**
   * Paper findFirstOrThrow
   */
  export type PaperFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paper
     */
    select?: PaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperInclude<ExtArgs> | null
    /**
     * Filter, which Paper to fetch.
     */
    where?: PaperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Papers to fetch.
     */
    orderBy?: PaperOrderByWithRelationInput | PaperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Papers.
     */
    cursor?: PaperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Papers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Papers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Papers.
     */
    distinct?: PaperScalarFieldEnum | PaperScalarFieldEnum[]
  }

  /**
   * Paper findMany
   */
  export type PaperFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paper
     */
    select?: PaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperInclude<ExtArgs> | null
    /**
     * Filter, which Papers to fetch.
     */
    where?: PaperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Papers to fetch.
     */
    orderBy?: PaperOrderByWithRelationInput | PaperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Papers.
     */
    cursor?: PaperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Papers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Papers.
     */
    skip?: number
    distinct?: PaperScalarFieldEnum | PaperScalarFieldEnum[]
  }

  /**
   * Paper create
   */
  export type PaperCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paper
     */
    select?: PaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperInclude<ExtArgs> | null
    /**
     * The data needed to create a Paper.
     */
    data: XOR<PaperCreateInput, PaperUncheckedCreateInput>
  }

  /**
   * Paper createMany
   */
  export type PaperCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Papers.
     */
    data: PaperCreateManyInput | PaperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Paper createManyAndReturn
   */
  export type PaperCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paper
     */
    select?: PaperSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Papers.
     */
    data: PaperCreateManyInput | PaperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Paper update
   */
  export type PaperUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paper
     */
    select?: PaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperInclude<ExtArgs> | null
    /**
     * The data needed to update a Paper.
     */
    data: XOR<PaperUpdateInput, PaperUncheckedUpdateInput>
    /**
     * Choose, which Paper to update.
     */
    where: PaperWhereUniqueInput
  }

  /**
   * Paper updateMany
   */
  export type PaperUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Papers.
     */
    data: XOR<PaperUpdateManyMutationInput, PaperUncheckedUpdateManyInput>
    /**
     * Filter which Papers to update
     */
    where?: PaperWhereInput
  }

  /**
   * Paper upsert
   */
  export type PaperUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paper
     */
    select?: PaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperInclude<ExtArgs> | null
    /**
     * The filter to search for the Paper to update in case it exists.
     */
    where: PaperWhereUniqueInput
    /**
     * In case the Paper found by the `where` argument doesn't exist, create a new Paper with this data.
     */
    create: XOR<PaperCreateInput, PaperUncheckedCreateInput>
    /**
     * In case the Paper was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaperUpdateInput, PaperUncheckedUpdateInput>
  }

  /**
   * Paper delete
   */
  export type PaperDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paper
     */
    select?: PaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperInclude<ExtArgs> | null
    /**
     * Filter which Paper to delete.
     */
    where: PaperWhereUniqueInput
  }

  /**
   * Paper deleteMany
   */
  export type PaperDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Papers to delete
     */
    where?: PaperWhereInput
  }

  /**
   * Paper.orderItems
   */
  export type Paper$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Paper without action
   */
  export type PaperDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paper
     */
    select?: PaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type CourseSumAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    academicArea: $Enums.AcademicArea | null
    instructorName: string | null
    instructorBio: string | null
    price: number | null
    duration: number | null
    level: $Enums.CourseLevel | null
    thumbnailUrl: string | null
    videoUrl: string | null
    status: $Enums.CourseStatus | null
    isFeatured: boolean | null
    createdAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    academicArea: $Enums.AcademicArea | null
    instructorName: string | null
    instructorBio: string | null
    price: number | null
    duration: number | null
    level: $Enums.CourseLevel | null
    thumbnailUrl: string | null
    videoUrl: string | null
    status: $Enums.CourseStatus | null
    isFeatured: boolean | null
    createdAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    description: number
    academicArea: number
    instructorName: number
    instructorBio: number
    price: number
    duration: number
    level: number
    thumbnailUrl: number
    videoUrl: number
    status: number
    isFeatured: number
    createdAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    price?: true
    duration?: true
  }

  export type CourseSumAggregateInputType = {
    price?: true
    duration?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    academicArea?: true
    instructorName?: true
    instructorBio?: true
    price?: true
    duration?: true
    level?: true
    thumbnailUrl?: true
    videoUrl?: true
    status?: true
    isFeatured?: true
    createdAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    academicArea?: true
    instructorName?: true
    instructorBio?: true
    price?: true
    duration?: true
    level?: true
    thumbnailUrl?: true
    videoUrl?: true
    status?: true
    isFeatured?: true
    createdAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    academicArea?: true
    instructorName?: true
    instructorBio?: true
    price?: true
    duration?: true
    level?: true
    thumbnailUrl?: true
    videoUrl?: true
    status?: true
    isFeatured?: true
    createdAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    instructorName: string
    instructorBio: string | null
    price: number
    duration: number
    level: $Enums.CourseLevel
    thumbnailUrl: string | null
    videoUrl: string | null
    status: $Enums.CourseStatus
    isFeatured: boolean
    createdAt: Date
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    academicArea?: boolean
    instructorName?: boolean
    instructorBio?: boolean
    price?: boolean
    duration?: boolean
    level?: boolean
    thumbnailUrl?: boolean
    videoUrl?: boolean
    status?: boolean
    isFeatured?: boolean
    createdAt?: boolean
    orderItems?: boolean | Course$orderItemsArgs<ExtArgs>
    certificates?: boolean | Course$certificatesArgs<ExtArgs>
    modules?: boolean | Course$modulesArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    academicArea?: boolean
    instructorName?: boolean
    instructorBio?: boolean
    price?: boolean
    duration?: boolean
    level?: boolean
    thumbnailUrl?: boolean
    videoUrl?: boolean
    status?: boolean
    isFeatured?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    academicArea?: boolean
    instructorName?: boolean
    instructorBio?: boolean
    price?: boolean
    duration?: boolean
    level?: boolean
    thumbnailUrl?: boolean
    videoUrl?: boolean
    status?: boolean
    isFeatured?: boolean
    createdAt?: boolean
  }

  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | Course$orderItemsArgs<ExtArgs>
    certificates?: boolean | Course$certificatesArgs<ExtArgs>
    modules?: boolean | Course$modulesArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
      modules: Prisma.$CourseModulePayload<ExtArgs>[]
      enrollments: Prisma.$CourseEnrollmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      academicArea: $Enums.AcademicArea
      instructorName: string
      instructorBio: string | null
      price: number
      duration: number
      level: $Enums.CourseLevel
      thumbnailUrl: string | null
      videoUrl: string | null
      status: $Enums.CourseStatus
      isFeatured: boolean
      createdAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends Course$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Course$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    certificates<T extends Course$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, Course$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany"> | Null>
    modules<T extends Course$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Course$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findMany"> | Null>
    enrollments<T extends Course$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Course$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */ 
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly title: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly academicArea: FieldRef<"Course", 'AcademicArea'>
    readonly instructorName: FieldRef<"Course", 'String'>
    readonly instructorBio: FieldRef<"Course", 'String'>
    readonly price: FieldRef<"Course", 'Int'>
    readonly duration: FieldRef<"Course", 'Int'>
    readonly level: FieldRef<"Course", 'CourseLevel'>
    readonly thumbnailUrl: FieldRef<"Course", 'String'>
    readonly videoUrl: FieldRef<"Course", 'String'>
    readonly status: FieldRef<"Course", 'CourseStatus'>
    readonly isFeatured: FieldRef<"Course", 'Boolean'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
  }

  /**
   * Course.orderItems
   */
  export type Course$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Course.certificates
   */
  export type Course$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Course.modules
   */
  export type Course$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    where?: CourseModuleWhereInput
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    cursor?: CourseModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * Course.enrollments
   */
  export type Course$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    where?: CourseEnrollmentWhereInput
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    cursor?: CourseEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseEnrollmentScalarFieldEnum | CourseEnrollmentScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model Ebook
   */

  export type AggregateEbook = {
    _count: EbookCountAggregateOutputType | null
    _avg: EbookAvgAggregateOutputType | null
    _sum: EbookSumAggregateOutputType | null
    _min: EbookMinAggregateOutputType | null
    _max: EbookMaxAggregateOutputType | null
  }

  export type EbookAvgAggregateOutputType = {
    price: number | null
    pageCount: number | null
  }

  export type EbookSumAggregateOutputType = {
    price: number | null
    pageCount: number | null
  }

  export type EbookMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    academicArea: $Enums.AcademicArea | null
    authorName: string | null
    price: number | null
    pageCount: number | null
    fileUrl: string | null
    coverUrl: string | null
    createdAt: Date | null
  }

  export type EbookMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    academicArea: $Enums.AcademicArea | null
    authorName: string | null
    price: number | null
    pageCount: number | null
    fileUrl: string | null
    coverUrl: string | null
    createdAt: Date | null
  }

  export type EbookCountAggregateOutputType = {
    id: number
    title: number
    description: number
    academicArea: number
    authorName: number
    price: number
    pageCount: number
    fileUrl: number
    coverUrl: number
    createdAt: number
    _all: number
  }


  export type EbookAvgAggregateInputType = {
    price?: true
    pageCount?: true
  }

  export type EbookSumAggregateInputType = {
    price?: true
    pageCount?: true
  }

  export type EbookMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    academicArea?: true
    authorName?: true
    price?: true
    pageCount?: true
    fileUrl?: true
    coverUrl?: true
    createdAt?: true
  }

  export type EbookMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    academicArea?: true
    authorName?: true
    price?: true
    pageCount?: true
    fileUrl?: true
    coverUrl?: true
    createdAt?: true
  }

  export type EbookCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    academicArea?: true
    authorName?: true
    price?: true
    pageCount?: true
    fileUrl?: true
    coverUrl?: true
    createdAt?: true
    _all?: true
  }

  export type EbookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ebook to aggregate.
     */
    where?: EbookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ebooks to fetch.
     */
    orderBy?: EbookOrderByWithRelationInput | EbookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EbookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ebooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ebooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ebooks
    **/
    _count?: true | EbookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EbookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EbookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EbookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EbookMaxAggregateInputType
  }

  export type GetEbookAggregateType<T extends EbookAggregateArgs> = {
        [P in keyof T & keyof AggregateEbook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEbook[P]>
      : GetScalarType<T[P], AggregateEbook[P]>
  }




  export type EbookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EbookWhereInput
    orderBy?: EbookOrderByWithAggregationInput | EbookOrderByWithAggregationInput[]
    by: EbookScalarFieldEnum[] | EbookScalarFieldEnum
    having?: EbookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EbookCountAggregateInputType | true
    _avg?: EbookAvgAggregateInputType
    _sum?: EbookSumAggregateInputType
    _min?: EbookMinAggregateInputType
    _max?: EbookMaxAggregateInputType
  }

  export type EbookGroupByOutputType = {
    id: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    authorName: string
    price: number
    pageCount: number
    fileUrl: string
    coverUrl: string | null
    createdAt: Date
    _count: EbookCountAggregateOutputType | null
    _avg: EbookAvgAggregateOutputType | null
    _sum: EbookSumAggregateOutputType | null
    _min: EbookMinAggregateOutputType | null
    _max: EbookMaxAggregateOutputType | null
  }

  type GetEbookGroupByPayload<T extends EbookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EbookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EbookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EbookGroupByOutputType[P]>
            : GetScalarType<T[P], EbookGroupByOutputType[P]>
        }
      >
    >


  export type EbookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    academicArea?: boolean
    authorName?: boolean
    price?: boolean
    pageCount?: boolean
    fileUrl?: boolean
    coverUrl?: boolean
    createdAt?: boolean
    files?: boolean | Ebook$filesArgs<ExtArgs>
    orderItems?: boolean | Ebook$orderItemsArgs<ExtArgs>
    _count?: boolean | EbookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ebook"]>

  export type EbookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    academicArea?: boolean
    authorName?: boolean
    price?: boolean
    pageCount?: boolean
    fileUrl?: boolean
    coverUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ebook"]>

  export type EbookSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    academicArea?: boolean
    authorName?: boolean
    price?: boolean
    pageCount?: boolean
    fileUrl?: boolean
    coverUrl?: boolean
    createdAt?: boolean
  }

  export type EbookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | Ebook$filesArgs<ExtArgs>
    orderItems?: boolean | Ebook$orderItemsArgs<ExtArgs>
    _count?: boolean | EbookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EbookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EbookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ebook"
    objects: {
      files: Prisma.$EbookFilePayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      academicArea: $Enums.AcademicArea
      authorName: string
      price: number
      pageCount: number
      fileUrl: string
      coverUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["ebook"]>
    composites: {}
  }

  type EbookGetPayload<S extends boolean | null | undefined | EbookDefaultArgs> = $Result.GetResult<Prisma.$EbookPayload, S>

  type EbookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EbookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EbookCountAggregateInputType | true
    }

  export interface EbookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ebook'], meta: { name: 'Ebook' } }
    /**
     * Find zero or one Ebook that matches the filter.
     * @param {EbookFindUniqueArgs} args - Arguments to find a Ebook
     * @example
     * // Get one Ebook
     * const ebook = await prisma.ebook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EbookFindUniqueArgs>(args: SelectSubset<T, EbookFindUniqueArgs<ExtArgs>>): Prisma__EbookClient<$Result.GetResult<Prisma.$EbookPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ebook that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EbookFindUniqueOrThrowArgs} args - Arguments to find a Ebook
     * @example
     * // Get one Ebook
     * const ebook = await prisma.ebook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EbookFindUniqueOrThrowArgs>(args: SelectSubset<T, EbookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EbookClient<$Result.GetResult<Prisma.$EbookPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ebook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EbookFindFirstArgs} args - Arguments to find a Ebook
     * @example
     * // Get one Ebook
     * const ebook = await prisma.ebook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EbookFindFirstArgs>(args?: SelectSubset<T, EbookFindFirstArgs<ExtArgs>>): Prisma__EbookClient<$Result.GetResult<Prisma.$EbookPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ebook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EbookFindFirstOrThrowArgs} args - Arguments to find a Ebook
     * @example
     * // Get one Ebook
     * const ebook = await prisma.ebook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EbookFindFirstOrThrowArgs>(args?: SelectSubset<T, EbookFindFirstOrThrowArgs<ExtArgs>>): Prisma__EbookClient<$Result.GetResult<Prisma.$EbookPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ebooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EbookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ebooks
     * const ebooks = await prisma.ebook.findMany()
     * 
     * // Get first 10 Ebooks
     * const ebooks = await prisma.ebook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ebookWithIdOnly = await prisma.ebook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EbookFindManyArgs>(args?: SelectSubset<T, EbookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EbookPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ebook.
     * @param {EbookCreateArgs} args - Arguments to create a Ebook.
     * @example
     * // Create one Ebook
     * const Ebook = await prisma.ebook.create({
     *   data: {
     *     // ... data to create a Ebook
     *   }
     * })
     * 
     */
    create<T extends EbookCreateArgs>(args: SelectSubset<T, EbookCreateArgs<ExtArgs>>): Prisma__EbookClient<$Result.GetResult<Prisma.$EbookPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ebooks.
     * @param {EbookCreateManyArgs} args - Arguments to create many Ebooks.
     * @example
     * // Create many Ebooks
     * const ebook = await prisma.ebook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EbookCreateManyArgs>(args?: SelectSubset<T, EbookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ebooks and returns the data saved in the database.
     * @param {EbookCreateManyAndReturnArgs} args - Arguments to create many Ebooks.
     * @example
     * // Create many Ebooks
     * const ebook = await prisma.ebook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ebooks and only return the `id`
     * const ebookWithIdOnly = await prisma.ebook.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EbookCreateManyAndReturnArgs>(args?: SelectSubset<T, EbookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EbookPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ebook.
     * @param {EbookDeleteArgs} args - Arguments to delete one Ebook.
     * @example
     * // Delete one Ebook
     * const Ebook = await prisma.ebook.delete({
     *   where: {
     *     // ... filter to delete one Ebook
     *   }
     * })
     * 
     */
    delete<T extends EbookDeleteArgs>(args: SelectSubset<T, EbookDeleteArgs<ExtArgs>>): Prisma__EbookClient<$Result.GetResult<Prisma.$EbookPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ebook.
     * @param {EbookUpdateArgs} args - Arguments to update one Ebook.
     * @example
     * // Update one Ebook
     * const ebook = await prisma.ebook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EbookUpdateArgs>(args: SelectSubset<T, EbookUpdateArgs<ExtArgs>>): Prisma__EbookClient<$Result.GetResult<Prisma.$EbookPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ebooks.
     * @param {EbookDeleteManyArgs} args - Arguments to filter Ebooks to delete.
     * @example
     * // Delete a few Ebooks
     * const { count } = await prisma.ebook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EbookDeleteManyArgs>(args?: SelectSubset<T, EbookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ebooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EbookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ebooks
     * const ebook = await prisma.ebook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EbookUpdateManyArgs>(args: SelectSubset<T, EbookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ebook.
     * @param {EbookUpsertArgs} args - Arguments to update or create a Ebook.
     * @example
     * // Update or create a Ebook
     * const ebook = await prisma.ebook.upsert({
     *   create: {
     *     // ... data to create a Ebook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ebook we want to update
     *   }
     * })
     */
    upsert<T extends EbookUpsertArgs>(args: SelectSubset<T, EbookUpsertArgs<ExtArgs>>): Prisma__EbookClient<$Result.GetResult<Prisma.$EbookPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ebooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EbookCountArgs} args - Arguments to filter Ebooks to count.
     * @example
     * // Count the number of Ebooks
     * const count = await prisma.ebook.count({
     *   where: {
     *     // ... the filter for the Ebooks we want to count
     *   }
     * })
    **/
    count<T extends EbookCountArgs>(
      args?: Subset<T, EbookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EbookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ebook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EbookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EbookAggregateArgs>(args: Subset<T, EbookAggregateArgs>): Prisma.PrismaPromise<GetEbookAggregateType<T>>

    /**
     * Group by Ebook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EbookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EbookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EbookGroupByArgs['orderBy'] }
        : { orderBy?: EbookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EbookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEbookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ebook model
   */
  readonly fields: EbookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ebook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EbookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    files<T extends Ebook$filesArgs<ExtArgs> = {}>(args?: Subset<T, Ebook$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EbookFilePayload<ExtArgs>, T, "findMany"> | Null>
    orderItems<T extends Ebook$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Ebook$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ebook model
   */ 
  interface EbookFieldRefs {
    readonly id: FieldRef<"Ebook", 'String'>
    readonly title: FieldRef<"Ebook", 'String'>
    readonly description: FieldRef<"Ebook", 'String'>
    readonly academicArea: FieldRef<"Ebook", 'AcademicArea'>
    readonly authorName: FieldRef<"Ebook", 'String'>
    readonly price: FieldRef<"Ebook", 'Int'>
    readonly pageCount: FieldRef<"Ebook", 'Int'>
    readonly fileUrl: FieldRef<"Ebook", 'String'>
    readonly coverUrl: FieldRef<"Ebook", 'String'>
    readonly createdAt: FieldRef<"Ebook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ebook findUnique
   */
  export type EbookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ebook
     */
    select?: EbookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookInclude<ExtArgs> | null
    /**
     * Filter, which Ebook to fetch.
     */
    where: EbookWhereUniqueInput
  }

  /**
   * Ebook findUniqueOrThrow
   */
  export type EbookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ebook
     */
    select?: EbookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookInclude<ExtArgs> | null
    /**
     * Filter, which Ebook to fetch.
     */
    where: EbookWhereUniqueInput
  }

  /**
   * Ebook findFirst
   */
  export type EbookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ebook
     */
    select?: EbookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookInclude<ExtArgs> | null
    /**
     * Filter, which Ebook to fetch.
     */
    where?: EbookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ebooks to fetch.
     */
    orderBy?: EbookOrderByWithRelationInput | EbookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ebooks.
     */
    cursor?: EbookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ebooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ebooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ebooks.
     */
    distinct?: EbookScalarFieldEnum | EbookScalarFieldEnum[]
  }

  /**
   * Ebook findFirstOrThrow
   */
  export type EbookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ebook
     */
    select?: EbookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookInclude<ExtArgs> | null
    /**
     * Filter, which Ebook to fetch.
     */
    where?: EbookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ebooks to fetch.
     */
    orderBy?: EbookOrderByWithRelationInput | EbookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ebooks.
     */
    cursor?: EbookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ebooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ebooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ebooks.
     */
    distinct?: EbookScalarFieldEnum | EbookScalarFieldEnum[]
  }

  /**
   * Ebook findMany
   */
  export type EbookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ebook
     */
    select?: EbookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookInclude<ExtArgs> | null
    /**
     * Filter, which Ebooks to fetch.
     */
    where?: EbookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ebooks to fetch.
     */
    orderBy?: EbookOrderByWithRelationInput | EbookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ebooks.
     */
    cursor?: EbookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ebooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ebooks.
     */
    skip?: number
    distinct?: EbookScalarFieldEnum | EbookScalarFieldEnum[]
  }

  /**
   * Ebook create
   */
  export type EbookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ebook
     */
    select?: EbookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookInclude<ExtArgs> | null
    /**
     * The data needed to create a Ebook.
     */
    data: XOR<EbookCreateInput, EbookUncheckedCreateInput>
  }

  /**
   * Ebook createMany
   */
  export type EbookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ebooks.
     */
    data: EbookCreateManyInput | EbookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ebook createManyAndReturn
   */
  export type EbookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ebook
     */
    select?: EbookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Ebooks.
     */
    data: EbookCreateManyInput | EbookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ebook update
   */
  export type EbookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ebook
     */
    select?: EbookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookInclude<ExtArgs> | null
    /**
     * The data needed to update a Ebook.
     */
    data: XOR<EbookUpdateInput, EbookUncheckedUpdateInput>
    /**
     * Choose, which Ebook to update.
     */
    where: EbookWhereUniqueInput
  }

  /**
   * Ebook updateMany
   */
  export type EbookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ebooks.
     */
    data: XOR<EbookUpdateManyMutationInput, EbookUncheckedUpdateManyInput>
    /**
     * Filter which Ebooks to update
     */
    where?: EbookWhereInput
  }

  /**
   * Ebook upsert
   */
  export type EbookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ebook
     */
    select?: EbookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookInclude<ExtArgs> | null
    /**
     * The filter to search for the Ebook to update in case it exists.
     */
    where: EbookWhereUniqueInput
    /**
     * In case the Ebook found by the `where` argument doesn't exist, create a new Ebook with this data.
     */
    create: XOR<EbookCreateInput, EbookUncheckedCreateInput>
    /**
     * In case the Ebook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EbookUpdateInput, EbookUncheckedUpdateInput>
  }

  /**
   * Ebook delete
   */
  export type EbookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ebook
     */
    select?: EbookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookInclude<ExtArgs> | null
    /**
     * Filter which Ebook to delete.
     */
    where: EbookWhereUniqueInput
  }

  /**
   * Ebook deleteMany
   */
  export type EbookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ebooks to delete
     */
    where?: EbookWhereInput
  }

  /**
   * Ebook.files
   */
  export type Ebook$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EbookFile
     */
    select?: EbookFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookFileInclude<ExtArgs> | null
    where?: EbookFileWhereInput
    orderBy?: EbookFileOrderByWithRelationInput | EbookFileOrderByWithRelationInput[]
    cursor?: EbookFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EbookFileScalarFieldEnum | EbookFileScalarFieldEnum[]
  }

  /**
   * Ebook.orderItems
   */
  export type Ebook$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Ebook without action
   */
  export type EbookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ebook
     */
    select?: EbookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookInclude<ExtArgs> | null
  }


  /**
   * Model EbookFile
   */

  export type AggregateEbookFile = {
    _count: EbookFileCountAggregateOutputType | null
    _avg: EbookFileAvgAggregateOutputType | null
    _sum: EbookFileSumAggregateOutputType | null
    _min: EbookFileMinAggregateOutputType | null
    _max: EbookFileMaxAggregateOutputType | null
  }

  export type EbookFileAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type EbookFileSumAggregateOutputType = {
    fileSize: number | null
  }

  export type EbookFileMinAggregateOutputType = {
    id: string | null
    ebookId: string | null
    fileUrl: string | null
    fileName: string | null
    fileSize: number | null
    createdAt: Date | null
  }

  export type EbookFileMaxAggregateOutputType = {
    id: string | null
    ebookId: string | null
    fileUrl: string | null
    fileName: string | null
    fileSize: number | null
    createdAt: Date | null
  }

  export type EbookFileCountAggregateOutputType = {
    id: number
    ebookId: number
    fileUrl: number
    fileName: number
    fileSize: number
    createdAt: number
    _all: number
  }


  export type EbookFileAvgAggregateInputType = {
    fileSize?: true
  }

  export type EbookFileSumAggregateInputType = {
    fileSize?: true
  }

  export type EbookFileMinAggregateInputType = {
    id?: true
    ebookId?: true
    fileUrl?: true
    fileName?: true
    fileSize?: true
    createdAt?: true
  }

  export type EbookFileMaxAggregateInputType = {
    id?: true
    ebookId?: true
    fileUrl?: true
    fileName?: true
    fileSize?: true
    createdAt?: true
  }

  export type EbookFileCountAggregateInputType = {
    id?: true
    ebookId?: true
    fileUrl?: true
    fileName?: true
    fileSize?: true
    createdAt?: true
    _all?: true
  }

  export type EbookFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EbookFile to aggregate.
     */
    where?: EbookFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EbookFiles to fetch.
     */
    orderBy?: EbookFileOrderByWithRelationInput | EbookFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EbookFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EbookFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EbookFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EbookFiles
    **/
    _count?: true | EbookFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EbookFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EbookFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EbookFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EbookFileMaxAggregateInputType
  }

  export type GetEbookFileAggregateType<T extends EbookFileAggregateArgs> = {
        [P in keyof T & keyof AggregateEbookFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEbookFile[P]>
      : GetScalarType<T[P], AggregateEbookFile[P]>
  }




  export type EbookFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EbookFileWhereInput
    orderBy?: EbookFileOrderByWithAggregationInput | EbookFileOrderByWithAggregationInput[]
    by: EbookFileScalarFieldEnum[] | EbookFileScalarFieldEnum
    having?: EbookFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EbookFileCountAggregateInputType | true
    _avg?: EbookFileAvgAggregateInputType
    _sum?: EbookFileSumAggregateInputType
    _min?: EbookFileMinAggregateInputType
    _max?: EbookFileMaxAggregateInputType
  }

  export type EbookFileGroupByOutputType = {
    id: string
    ebookId: string
    fileUrl: string
    fileName: string
    fileSize: number | null
    createdAt: Date
    _count: EbookFileCountAggregateOutputType | null
    _avg: EbookFileAvgAggregateOutputType | null
    _sum: EbookFileSumAggregateOutputType | null
    _min: EbookFileMinAggregateOutputType | null
    _max: EbookFileMaxAggregateOutputType | null
  }

  type GetEbookFileGroupByPayload<T extends EbookFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EbookFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EbookFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EbookFileGroupByOutputType[P]>
            : GetScalarType<T[P], EbookFileGroupByOutputType[P]>
        }
      >
    >


  export type EbookFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ebookId?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    createdAt?: boolean
    ebook?: boolean | EbookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ebookFile"]>

  export type EbookFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ebookId?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    createdAt?: boolean
    ebook?: boolean | EbookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ebookFile"]>

  export type EbookFileSelectScalar = {
    id?: boolean
    ebookId?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    createdAt?: boolean
  }

  export type EbookFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ebook?: boolean | EbookDefaultArgs<ExtArgs>
  }
  export type EbookFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ebook?: boolean | EbookDefaultArgs<ExtArgs>
  }

  export type $EbookFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EbookFile"
    objects: {
      ebook: Prisma.$EbookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ebookId: string
      fileUrl: string
      fileName: string
      fileSize: number | null
      createdAt: Date
    }, ExtArgs["result"]["ebookFile"]>
    composites: {}
  }

  type EbookFileGetPayload<S extends boolean | null | undefined | EbookFileDefaultArgs> = $Result.GetResult<Prisma.$EbookFilePayload, S>

  type EbookFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EbookFileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EbookFileCountAggregateInputType | true
    }

  export interface EbookFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EbookFile'], meta: { name: 'EbookFile' } }
    /**
     * Find zero or one EbookFile that matches the filter.
     * @param {EbookFileFindUniqueArgs} args - Arguments to find a EbookFile
     * @example
     * // Get one EbookFile
     * const ebookFile = await prisma.ebookFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EbookFileFindUniqueArgs>(args: SelectSubset<T, EbookFileFindUniqueArgs<ExtArgs>>): Prisma__EbookFileClient<$Result.GetResult<Prisma.$EbookFilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EbookFile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EbookFileFindUniqueOrThrowArgs} args - Arguments to find a EbookFile
     * @example
     * // Get one EbookFile
     * const ebookFile = await prisma.ebookFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EbookFileFindUniqueOrThrowArgs>(args: SelectSubset<T, EbookFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EbookFileClient<$Result.GetResult<Prisma.$EbookFilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EbookFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EbookFileFindFirstArgs} args - Arguments to find a EbookFile
     * @example
     * // Get one EbookFile
     * const ebookFile = await prisma.ebookFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EbookFileFindFirstArgs>(args?: SelectSubset<T, EbookFileFindFirstArgs<ExtArgs>>): Prisma__EbookFileClient<$Result.GetResult<Prisma.$EbookFilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EbookFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EbookFileFindFirstOrThrowArgs} args - Arguments to find a EbookFile
     * @example
     * // Get one EbookFile
     * const ebookFile = await prisma.ebookFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EbookFileFindFirstOrThrowArgs>(args?: SelectSubset<T, EbookFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__EbookFileClient<$Result.GetResult<Prisma.$EbookFilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EbookFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EbookFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EbookFiles
     * const ebookFiles = await prisma.ebookFile.findMany()
     * 
     * // Get first 10 EbookFiles
     * const ebookFiles = await prisma.ebookFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ebookFileWithIdOnly = await prisma.ebookFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EbookFileFindManyArgs>(args?: SelectSubset<T, EbookFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EbookFilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EbookFile.
     * @param {EbookFileCreateArgs} args - Arguments to create a EbookFile.
     * @example
     * // Create one EbookFile
     * const EbookFile = await prisma.ebookFile.create({
     *   data: {
     *     // ... data to create a EbookFile
     *   }
     * })
     * 
     */
    create<T extends EbookFileCreateArgs>(args: SelectSubset<T, EbookFileCreateArgs<ExtArgs>>): Prisma__EbookFileClient<$Result.GetResult<Prisma.$EbookFilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EbookFiles.
     * @param {EbookFileCreateManyArgs} args - Arguments to create many EbookFiles.
     * @example
     * // Create many EbookFiles
     * const ebookFile = await prisma.ebookFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EbookFileCreateManyArgs>(args?: SelectSubset<T, EbookFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EbookFiles and returns the data saved in the database.
     * @param {EbookFileCreateManyAndReturnArgs} args - Arguments to create many EbookFiles.
     * @example
     * // Create many EbookFiles
     * const ebookFile = await prisma.ebookFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EbookFiles and only return the `id`
     * const ebookFileWithIdOnly = await prisma.ebookFile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EbookFileCreateManyAndReturnArgs>(args?: SelectSubset<T, EbookFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EbookFilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EbookFile.
     * @param {EbookFileDeleteArgs} args - Arguments to delete one EbookFile.
     * @example
     * // Delete one EbookFile
     * const EbookFile = await prisma.ebookFile.delete({
     *   where: {
     *     // ... filter to delete one EbookFile
     *   }
     * })
     * 
     */
    delete<T extends EbookFileDeleteArgs>(args: SelectSubset<T, EbookFileDeleteArgs<ExtArgs>>): Prisma__EbookFileClient<$Result.GetResult<Prisma.$EbookFilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EbookFile.
     * @param {EbookFileUpdateArgs} args - Arguments to update one EbookFile.
     * @example
     * // Update one EbookFile
     * const ebookFile = await prisma.ebookFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EbookFileUpdateArgs>(args: SelectSubset<T, EbookFileUpdateArgs<ExtArgs>>): Prisma__EbookFileClient<$Result.GetResult<Prisma.$EbookFilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EbookFiles.
     * @param {EbookFileDeleteManyArgs} args - Arguments to filter EbookFiles to delete.
     * @example
     * // Delete a few EbookFiles
     * const { count } = await prisma.ebookFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EbookFileDeleteManyArgs>(args?: SelectSubset<T, EbookFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EbookFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EbookFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EbookFiles
     * const ebookFile = await prisma.ebookFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EbookFileUpdateManyArgs>(args: SelectSubset<T, EbookFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EbookFile.
     * @param {EbookFileUpsertArgs} args - Arguments to update or create a EbookFile.
     * @example
     * // Update or create a EbookFile
     * const ebookFile = await prisma.ebookFile.upsert({
     *   create: {
     *     // ... data to create a EbookFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EbookFile we want to update
     *   }
     * })
     */
    upsert<T extends EbookFileUpsertArgs>(args: SelectSubset<T, EbookFileUpsertArgs<ExtArgs>>): Prisma__EbookFileClient<$Result.GetResult<Prisma.$EbookFilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EbookFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EbookFileCountArgs} args - Arguments to filter EbookFiles to count.
     * @example
     * // Count the number of EbookFiles
     * const count = await prisma.ebookFile.count({
     *   where: {
     *     // ... the filter for the EbookFiles we want to count
     *   }
     * })
    **/
    count<T extends EbookFileCountArgs>(
      args?: Subset<T, EbookFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EbookFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EbookFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EbookFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EbookFileAggregateArgs>(args: Subset<T, EbookFileAggregateArgs>): Prisma.PrismaPromise<GetEbookFileAggregateType<T>>

    /**
     * Group by EbookFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EbookFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EbookFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EbookFileGroupByArgs['orderBy'] }
        : { orderBy?: EbookFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EbookFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEbookFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EbookFile model
   */
  readonly fields: EbookFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EbookFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EbookFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ebook<T extends EbookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EbookDefaultArgs<ExtArgs>>): Prisma__EbookClient<$Result.GetResult<Prisma.$EbookPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EbookFile model
   */ 
  interface EbookFileFieldRefs {
    readonly id: FieldRef<"EbookFile", 'String'>
    readonly ebookId: FieldRef<"EbookFile", 'String'>
    readonly fileUrl: FieldRef<"EbookFile", 'String'>
    readonly fileName: FieldRef<"EbookFile", 'String'>
    readonly fileSize: FieldRef<"EbookFile", 'Int'>
    readonly createdAt: FieldRef<"EbookFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EbookFile findUnique
   */
  export type EbookFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EbookFile
     */
    select?: EbookFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookFileInclude<ExtArgs> | null
    /**
     * Filter, which EbookFile to fetch.
     */
    where: EbookFileWhereUniqueInput
  }

  /**
   * EbookFile findUniqueOrThrow
   */
  export type EbookFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EbookFile
     */
    select?: EbookFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookFileInclude<ExtArgs> | null
    /**
     * Filter, which EbookFile to fetch.
     */
    where: EbookFileWhereUniqueInput
  }

  /**
   * EbookFile findFirst
   */
  export type EbookFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EbookFile
     */
    select?: EbookFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookFileInclude<ExtArgs> | null
    /**
     * Filter, which EbookFile to fetch.
     */
    where?: EbookFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EbookFiles to fetch.
     */
    orderBy?: EbookFileOrderByWithRelationInput | EbookFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EbookFiles.
     */
    cursor?: EbookFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EbookFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EbookFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EbookFiles.
     */
    distinct?: EbookFileScalarFieldEnum | EbookFileScalarFieldEnum[]
  }

  /**
   * EbookFile findFirstOrThrow
   */
  export type EbookFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EbookFile
     */
    select?: EbookFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookFileInclude<ExtArgs> | null
    /**
     * Filter, which EbookFile to fetch.
     */
    where?: EbookFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EbookFiles to fetch.
     */
    orderBy?: EbookFileOrderByWithRelationInput | EbookFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EbookFiles.
     */
    cursor?: EbookFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EbookFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EbookFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EbookFiles.
     */
    distinct?: EbookFileScalarFieldEnum | EbookFileScalarFieldEnum[]
  }

  /**
   * EbookFile findMany
   */
  export type EbookFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EbookFile
     */
    select?: EbookFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookFileInclude<ExtArgs> | null
    /**
     * Filter, which EbookFiles to fetch.
     */
    where?: EbookFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EbookFiles to fetch.
     */
    orderBy?: EbookFileOrderByWithRelationInput | EbookFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EbookFiles.
     */
    cursor?: EbookFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EbookFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EbookFiles.
     */
    skip?: number
    distinct?: EbookFileScalarFieldEnum | EbookFileScalarFieldEnum[]
  }

  /**
   * EbookFile create
   */
  export type EbookFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EbookFile
     */
    select?: EbookFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookFileInclude<ExtArgs> | null
    /**
     * The data needed to create a EbookFile.
     */
    data: XOR<EbookFileCreateInput, EbookFileUncheckedCreateInput>
  }

  /**
   * EbookFile createMany
   */
  export type EbookFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EbookFiles.
     */
    data: EbookFileCreateManyInput | EbookFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EbookFile createManyAndReturn
   */
  export type EbookFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EbookFile
     */
    select?: EbookFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EbookFiles.
     */
    data: EbookFileCreateManyInput | EbookFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EbookFile update
   */
  export type EbookFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EbookFile
     */
    select?: EbookFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookFileInclude<ExtArgs> | null
    /**
     * The data needed to update a EbookFile.
     */
    data: XOR<EbookFileUpdateInput, EbookFileUncheckedUpdateInput>
    /**
     * Choose, which EbookFile to update.
     */
    where: EbookFileWhereUniqueInput
  }

  /**
   * EbookFile updateMany
   */
  export type EbookFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EbookFiles.
     */
    data: XOR<EbookFileUpdateManyMutationInput, EbookFileUncheckedUpdateManyInput>
    /**
     * Filter which EbookFiles to update
     */
    where?: EbookFileWhereInput
  }

  /**
   * EbookFile upsert
   */
  export type EbookFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EbookFile
     */
    select?: EbookFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookFileInclude<ExtArgs> | null
    /**
     * The filter to search for the EbookFile to update in case it exists.
     */
    where: EbookFileWhereUniqueInput
    /**
     * In case the EbookFile found by the `where` argument doesn't exist, create a new EbookFile with this data.
     */
    create: XOR<EbookFileCreateInput, EbookFileUncheckedCreateInput>
    /**
     * In case the EbookFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EbookFileUpdateInput, EbookFileUncheckedUpdateInput>
  }

  /**
   * EbookFile delete
   */
  export type EbookFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EbookFile
     */
    select?: EbookFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookFileInclude<ExtArgs> | null
    /**
     * Filter which EbookFile to delete.
     */
    where: EbookFileWhereUniqueInput
  }

  /**
   * EbookFile deleteMany
   */
  export type EbookFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EbookFiles to delete
     */
    where?: EbookFileWhereInput
  }

  /**
   * EbookFile without action
   */
  export type EbookFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EbookFile
     */
    select?: EbookFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EbookFileInclude<ExtArgs> | null
  }


  /**
   * Model Certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  export type CertificateAvgAggregateOutputType = {
    grade: number | null
  }

  export type CertificateSumAggregateOutputType = {
    grade: number | null
  }

  export type CertificateMinAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    certificateNumber: string | null
    grade: number | null
    completionDate: Date | null
    qrCodeUrl: string | null
    createdAt: Date | null
  }

  export type CertificateMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    certificateNumber: string | null
    grade: number | null
    completionDate: Date | null
    qrCodeUrl: string | null
    createdAt: Date | null
  }

  export type CertificateCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    certificateNumber: number
    grade: number
    completionDate: number
    qrCodeUrl: number
    createdAt: number
    _all: number
  }


  export type CertificateAvgAggregateInputType = {
    grade?: true
  }

  export type CertificateSumAggregateInputType = {
    grade?: true
  }

  export type CertificateMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    certificateNumber?: true
    grade?: true
    completionDate?: true
    qrCodeUrl?: true
    createdAt?: true
  }

  export type CertificateMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    certificateNumber?: true
    grade?: true
    completionDate?: true
    qrCodeUrl?: true
    createdAt?: true
  }

  export type CertificateCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    certificateNumber?: true
    grade?: true
    completionDate?: true
    qrCodeUrl?: true
    createdAt?: true
    _all?: true
  }

  export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificate to aggregate.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certificates
    **/
    _count?: true | CertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateMaxAggregateInputType
  }

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate[P]>
      : GetScalarType<T[P], AggregateCertificate[P]>
  }




  export type CertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithAggregationInput | CertificateOrderByWithAggregationInput[]
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum
    having?: CertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateCountAggregateInputType | true
    _avg?: CertificateAvgAggregateInputType
    _sum?: CertificateSumAggregateInputType
    _min?: CertificateMinAggregateInputType
    _max?: CertificateMaxAggregateInputType
  }

  export type CertificateGroupByOutputType = {
    id: string
    userId: string
    courseId: string
    certificateNumber: string
    grade: number
    completionDate: Date
    qrCodeUrl: string
    createdAt: Date
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>
        }
      >
    >


  export type CertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    certificateNumber?: boolean
    grade?: boolean
    completionDate?: boolean
    qrCodeUrl?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    certificateNumber?: boolean
    grade?: boolean
    completionDate?: boolean
    qrCodeUrl?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    certificateNumber?: boolean
    grade?: boolean
    completionDate?: boolean
    qrCodeUrl?: boolean
    createdAt?: boolean
  }

  export type CertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certificate"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      courseId: string
      certificateNumber: string
      grade: number
      completionDate: Date
      qrCodeUrl: string
      createdAt: Date
    }, ExtArgs["result"]["certificate"]>
    composites: {}
  }

  type CertificateGetPayload<S extends boolean | null | undefined | CertificateDefaultArgs> = $Result.GetResult<Prisma.$CertificatePayload, S>

  type CertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CertificateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CertificateCountAggregateInputType | true
    }

  export interface CertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificate'], meta: { name: 'Certificate' } }
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateFindUniqueArgs>(args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateFindFirstArgs>(args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateWithIdOnly = await prisma.certificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateFindManyArgs>(args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Certificate.
     * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     * 
     */
    create<T extends CertificateCreateArgs>(args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Certificates.
     * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateCreateManyArgs>(args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificates and returns the data saved in the database.
     * @param {CertificateCreateManyAndReturnArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Certificate.
     * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     * 
     */
    delete<T extends CertificateDeleteArgs>(args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Certificate.
     * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateUpdateArgs>(args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Certificates.
     * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateDeleteManyArgs>(args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateUpdateManyArgs>(args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certificate.
     * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateUpsertArgs>(args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends CertificateCountArgs>(
      args?: Subset<T, CertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateAggregateArgs>(args: Subset<T, CertificateAggregateArgs>): Prisma.PrismaPromise<GetCertificateAggregateType<T>>

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certificate model
   */
  readonly fields: CertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certificate model
   */ 
  interface CertificateFieldRefs {
    readonly id: FieldRef<"Certificate", 'String'>
    readonly userId: FieldRef<"Certificate", 'String'>
    readonly courseId: FieldRef<"Certificate", 'String'>
    readonly certificateNumber: FieldRef<"Certificate", 'String'>
    readonly grade: FieldRef<"Certificate", 'Int'>
    readonly completionDate: FieldRef<"Certificate", 'DateTime'>
    readonly qrCodeUrl: FieldRef<"Certificate", 'String'>
    readonly createdAt: FieldRef<"Certificate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Certificate findUnique
   */
  export type CertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findUniqueOrThrow
   */
  export type CertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findFirst
   */
  export type CertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findFirstOrThrow
   */
  export type CertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findMany
   */
  export type CertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate create
   */
  export type CertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a Certificate.
     */
    data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
  }

  /**
   * Certificate createMany
   */
  export type CertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificate createManyAndReturn
   */
  export type CertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate update
   */
  export type CertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a Certificate.
     */
    data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
    /**
     * Choose, which Certificate to update.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate updateMany
   */
  export type CertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate upsert
   */
  export type CertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the Certificate to update in case it exists.
     */
    where: CertificateWhereUniqueInput
    /**
     * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
     */
    create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
    /**
     * In case the Certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
  }

  /**
   * Certificate delete
   */
  export type CertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter which Certificate to delete.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate deleteMany
   */
  export type CertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate without action
   */
  export type CertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
  }


  /**
   * Model Library
   */

  export type AggregateLibrary = {
    _count: LibraryCountAggregateOutputType | null
    _min: LibraryMinAggregateOutputType | null
    _max: LibraryMaxAggregateOutputType | null
  }

  export type LibraryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    itemType: $Enums.LibraryItemType | null
    itemId: string | null
    downloadUrl: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type LibraryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    itemType: $Enums.LibraryItemType | null
    itemId: string | null
    downloadUrl: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type LibraryCountAggregateOutputType = {
    id: number
    userId: number
    itemType: number
    itemId: number
    downloadUrl: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type LibraryMinAggregateInputType = {
    id?: true
    userId?: true
    itemType?: true
    itemId?: true
    downloadUrl?: true
    expiresAt?: true
    createdAt?: true
  }

  export type LibraryMaxAggregateInputType = {
    id?: true
    userId?: true
    itemType?: true
    itemId?: true
    downloadUrl?: true
    expiresAt?: true
    createdAt?: true
  }

  export type LibraryCountAggregateInputType = {
    id?: true
    userId?: true
    itemType?: true
    itemId?: true
    downloadUrl?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type LibraryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Library to aggregate.
     */
    where?: LibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Libraries to fetch.
     */
    orderBy?: LibraryOrderByWithRelationInput | LibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Libraries
    **/
    _count?: true | LibraryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryMaxAggregateInputType
  }

  export type GetLibraryAggregateType<T extends LibraryAggregateArgs> = {
        [P in keyof T & keyof AggregateLibrary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibrary[P]>
      : GetScalarType<T[P], AggregateLibrary[P]>
  }




  export type LibraryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LibraryWhereInput
    orderBy?: LibraryOrderByWithAggregationInput | LibraryOrderByWithAggregationInput[]
    by: LibraryScalarFieldEnum[] | LibraryScalarFieldEnum
    having?: LibraryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryCountAggregateInputType | true
    _min?: LibraryMinAggregateInputType
    _max?: LibraryMaxAggregateInputType
  }

  export type LibraryGroupByOutputType = {
    id: string
    userId: string
    itemType: $Enums.LibraryItemType
    itemId: string
    downloadUrl: string
    expiresAt: Date | null
    createdAt: Date
    _count: LibraryCountAggregateOutputType | null
    _min: LibraryMinAggregateOutputType | null
    _max: LibraryMaxAggregateOutputType | null
  }

  type GetLibraryGroupByPayload<T extends LibraryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LibraryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryGroupByOutputType[P]>
        }
      >
    >


  export type LibrarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemType?: boolean
    itemId?: boolean
    downloadUrl?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["library"]>

  export type LibrarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemType?: boolean
    itemId?: boolean
    downloadUrl?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["library"]>

  export type LibrarySelectScalar = {
    id?: boolean
    userId?: boolean
    itemType?: boolean
    itemId?: boolean
    downloadUrl?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type LibraryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LibraryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LibraryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Library"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      itemType: $Enums.LibraryItemType
      itemId: string
      downloadUrl: string
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["library"]>
    composites: {}
  }

  type LibraryGetPayload<S extends boolean | null | undefined | LibraryDefaultArgs> = $Result.GetResult<Prisma.$LibraryPayload, S>

  type LibraryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LibraryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LibraryCountAggregateInputType | true
    }

  export interface LibraryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Library'], meta: { name: 'Library' } }
    /**
     * Find zero or one Library that matches the filter.
     * @param {LibraryFindUniqueArgs} args - Arguments to find a Library
     * @example
     * // Get one Library
     * const library = await prisma.library.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LibraryFindUniqueArgs>(args: SelectSubset<T, LibraryFindUniqueArgs<ExtArgs>>): Prisma__LibraryClient<$Result.GetResult<Prisma.$LibraryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Library that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LibraryFindUniqueOrThrowArgs} args - Arguments to find a Library
     * @example
     * // Get one Library
     * const library = await prisma.library.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LibraryFindUniqueOrThrowArgs>(args: SelectSubset<T, LibraryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LibraryClient<$Result.GetResult<Prisma.$LibraryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Library that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryFindFirstArgs} args - Arguments to find a Library
     * @example
     * // Get one Library
     * const library = await prisma.library.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LibraryFindFirstArgs>(args?: SelectSubset<T, LibraryFindFirstArgs<ExtArgs>>): Prisma__LibraryClient<$Result.GetResult<Prisma.$LibraryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Library that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryFindFirstOrThrowArgs} args - Arguments to find a Library
     * @example
     * // Get one Library
     * const library = await prisma.library.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LibraryFindFirstOrThrowArgs>(args?: SelectSubset<T, LibraryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LibraryClient<$Result.GetResult<Prisma.$LibraryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Libraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Libraries
     * const libraries = await prisma.library.findMany()
     * 
     * // Get first 10 Libraries
     * const libraries = await prisma.library.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryWithIdOnly = await prisma.library.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LibraryFindManyArgs>(args?: SelectSubset<T, LibraryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Library.
     * @param {LibraryCreateArgs} args - Arguments to create a Library.
     * @example
     * // Create one Library
     * const Library = await prisma.library.create({
     *   data: {
     *     // ... data to create a Library
     *   }
     * })
     * 
     */
    create<T extends LibraryCreateArgs>(args: SelectSubset<T, LibraryCreateArgs<ExtArgs>>): Prisma__LibraryClient<$Result.GetResult<Prisma.$LibraryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Libraries.
     * @param {LibraryCreateManyArgs} args - Arguments to create many Libraries.
     * @example
     * // Create many Libraries
     * const library = await prisma.library.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LibraryCreateManyArgs>(args?: SelectSubset<T, LibraryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Libraries and returns the data saved in the database.
     * @param {LibraryCreateManyAndReturnArgs} args - Arguments to create many Libraries.
     * @example
     * // Create many Libraries
     * const library = await prisma.library.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Libraries and only return the `id`
     * const libraryWithIdOnly = await prisma.library.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LibraryCreateManyAndReturnArgs>(args?: SelectSubset<T, LibraryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Library.
     * @param {LibraryDeleteArgs} args - Arguments to delete one Library.
     * @example
     * // Delete one Library
     * const Library = await prisma.library.delete({
     *   where: {
     *     // ... filter to delete one Library
     *   }
     * })
     * 
     */
    delete<T extends LibraryDeleteArgs>(args: SelectSubset<T, LibraryDeleteArgs<ExtArgs>>): Prisma__LibraryClient<$Result.GetResult<Prisma.$LibraryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Library.
     * @param {LibraryUpdateArgs} args - Arguments to update one Library.
     * @example
     * // Update one Library
     * const library = await prisma.library.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LibraryUpdateArgs>(args: SelectSubset<T, LibraryUpdateArgs<ExtArgs>>): Prisma__LibraryClient<$Result.GetResult<Prisma.$LibraryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Libraries.
     * @param {LibraryDeleteManyArgs} args - Arguments to filter Libraries to delete.
     * @example
     * // Delete a few Libraries
     * const { count } = await prisma.library.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LibraryDeleteManyArgs>(args?: SelectSubset<T, LibraryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Libraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Libraries
     * const library = await prisma.library.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LibraryUpdateManyArgs>(args: SelectSubset<T, LibraryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Library.
     * @param {LibraryUpsertArgs} args - Arguments to update or create a Library.
     * @example
     * // Update or create a Library
     * const library = await prisma.library.upsert({
     *   create: {
     *     // ... data to create a Library
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Library we want to update
     *   }
     * })
     */
    upsert<T extends LibraryUpsertArgs>(args: SelectSubset<T, LibraryUpsertArgs<ExtArgs>>): Prisma__LibraryClient<$Result.GetResult<Prisma.$LibraryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Libraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCountArgs} args - Arguments to filter Libraries to count.
     * @example
     * // Count the number of Libraries
     * const count = await prisma.library.count({
     *   where: {
     *     // ... the filter for the Libraries we want to count
     *   }
     * })
    **/
    count<T extends LibraryCountArgs>(
      args?: Subset<T, LibraryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Library.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryAggregateArgs>(args: Subset<T, LibraryAggregateArgs>): Prisma.PrismaPromise<GetLibraryAggregateType<T>>

    /**
     * Group by Library.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryGroupByArgs['orderBy'] }
        : { orderBy?: LibraryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Library model
   */
  readonly fields: LibraryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Library.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LibraryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Library model
   */ 
  interface LibraryFieldRefs {
    readonly id: FieldRef<"Library", 'String'>
    readonly userId: FieldRef<"Library", 'String'>
    readonly itemType: FieldRef<"Library", 'LibraryItemType'>
    readonly itemId: FieldRef<"Library", 'String'>
    readonly downloadUrl: FieldRef<"Library", 'String'>
    readonly expiresAt: FieldRef<"Library", 'DateTime'>
    readonly createdAt: FieldRef<"Library", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Library findUnique
   */
  export type LibraryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * Filter, which Library to fetch.
     */
    where: LibraryWhereUniqueInput
  }

  /**
   * Library findUniqueOrThrow
   */
  export type LibraryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * Filter, which Library to fetch.
     */
    where: LibraryWhereUniqueInput
  }

  /**
   * Library findFirst
   */
  export type LibraryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * Filter, which Library to fetch.
     */
    where?: LibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Libraries to fetch.
     */
    orderBy?: LibraryOrderByWithRelationInput | LibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Libraries.
     */
    cursor?: LibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Libraries.
     */
    distinct?: LibraryScalarFieldEnum | LibraryScalarFieldEnum[]
  }

  /**
   * Library findFirstOrThrow
   */
  export type LibraryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * Filter, which Library to fetch.
     */
    where?: LibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Libraries to fetch.
     */
    orderBy?: LibraryOrderByWithRelationInput | LibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Libraries.
     */
    cursor?: LibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Libraries.
     */
    distinct?: LibraryScalarFieldEnum | LibraryScalarFieldEnum[]
  }

  /**
   * Library findMany
   */
  export type LibraryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * Filter, which Libraries to fetch.
     */
    where?: LibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Libraries to fetch.
     */
    orderBy?: LibraryOrderByWithRelationInput | LibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Libraries.
     */
    cursor?: LibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Libraries.
     */
    skip?: number
    distinct?: LibraryScalarFieldEnum | LibraryScalarFieldEnum[]
  }

  /**
   * Library create
   */
  export type LibraryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * The data needed to create a Library.
     */
    data: XOR<LibraryCreateInput, LibraryUncheckedCreateInput>
  }

  /**
   * Library createMany
   */
  export type LibraryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Libraries.
     */
    data: LibraryCreateManyInput | LibraryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Library createManyAndReturn
   */
  export type LibraryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Libraries.
     */
    data: LibraryCreateManyInput | LibraryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Library update
   */
  export type LibraryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * The data needed to update a Library.
     */
    data: XOR<LibraryUpdateInput, LibraryUncheckedUpdateInput>
    /**
     * Choose, which Library to update.
     */
    where: LibraryWhereUniqueInput
  }

  /**
   * Library updateMany
   */
  export type LibraryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Libraries.
     */
    data: XOR<LibraryUpdateManyMutationInput, LibraryUncheckedUpdateManyInput>
    /**
     * Filter which Libraries to update
     */
    where?: LibraryWhereInput
  }

  /**
   * Library upsert
   */
  export type LibraryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * The filter to search for the Library to update in case it exists.
     */
    where: LibraryWhereUniqueInput
    /**
     * In case the Library found by the `where` argument doesn't exist, create a new Library with this data.
     */
    create: XOR<LibraryCreateInput, LibraryUncheckedCreateInput>
    /**
     * In case the Library was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryUpdateInput, LibraryUncheckedUpdateInput>
  }

  /**
   * Library delete
   */
  export type LibraryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * Filter which Library to delete.
     */
    where: LibraryWhereUniqueInput
  }

  /**
   * Library deleteMany
   */
  export type LibraryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Libraries to delete
     */
    where?: LibraryWhereInput
  }

  /**
   * Library without action
   */
  export type LibraryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | Category$postsArgs<ExtArgs>
    subscribers?: boolean | Category$subscribersArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Category$postsArgs<ExtArgs>
    subscribers?: boolean | Category$subscribersArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      posts: Prisma.$BlogPostPayload<ExtArgs>[]
      subscribers: Prisma.$NewsletterSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Category$postsArgs<ExtArgs> = {}>(args?: Subset<T, Category$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany"> | Null>
    subscribers<T extends Category$subscribersArgs<ExtArgs> = {}>(args?: Subset<T, Category$subscribersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.posts
   */
  export type Category$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * Category.subscribers
   */
  export type Category$subscribersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriptionInclude<ExtArgs> | null
    where?: NewsletterSubscriptionWhereInput
    orderBy?: NewsletterSubscriptionOrderByWithRelationInput | NewsletterSubscriptionOrderByWithRelationInput[]
    cursor?: NewsletterSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsletterSubscriptionScalarFieldEnum | NewsletterSubscriptionScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | Tag$postsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Tag$postsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      posts: Prisma.$BlogTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Tag$postsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */ 
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
  }

  /**
   * Tag.posts
   */
  export type Tag$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    where?: BlogTagWhereInput
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    cursor?: BlogTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostAvgAggregateOutputType = {
    views: number | null
    readingTime: number | null
  }

  export type BlogPostSumAggregateOutputType = {
    views: number | null
    readingTime: number | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    slug: string | null
    excerpt: string | null
    coverImageUrl: string | null
    published: boolean | null
    status: $Enums.PostStatus | null
    publishedAt: Date | null
    authorId: string | null
    categoryId: string | null
    views: number | null
    metaTitle: string | null
    metaDescription: string | null
    ogImage: string | null
    canonicalUrl: string | null
    readingTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    slug: string | null
    excerpt: string | null
    coverImageUrl: string | null
    published: boolean | null
    status: $Enums.PostStatus | null
    publishedAt: Date | null
    authorId: string | null
    categoryId: string | null
    views: number | null
    metaTitle: string | null
    metaDescription: string | null
    ogImage: string | null
    canonicalUrl: string | null
    readingTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    title: number
    content: number
    slug: number
    excerpt: number
    coverImageUrl: number
    published: number
    status: number
    publishedAt: number
    authorId: number
    categoryId: number
    views: number
    metaTitle: number
    metaDescription: number
    metaKeywords: number
    ogImage: number
    canonicalUrl: number
    readingTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogPostAvgAggregateInputType = {
    views?: true
    readingTime?: true
  }

  export type BlogPostSumAggregateInputType = {
    views?: true
    readingTime?: true
  }

  export type BlogPostMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    slug?: true
    excerpt?: true
    coverImageUrl?: true
    published?: true
    status?: true
    publishedAt?: true
    authorId?: true
    categoryId?: true
    views?: true
    metaTitle?: true
    metaDescription?: true
    ogImage?: true
    canonicalUrl?: true
    readingTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    slug?: true
    excerpt?: true
    coverImageUrl?: true
    published?: true
    status?: true
    publishedAt?: true
    authorId?: true
    categoryId?: true
    views?: true
    metaTitle?: true
    metaDescription?: true
    ogImage?: true
    canonicalUrl?: true
    readingTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    slug?: true
    excerpt?: true
    coverImageUrl?: true
    published?: true
    status?: true
    publishedAt?: true
    authorId?: true
    categoryId?: true
    views?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
    ogImage?: true
    canonicalUrl?: true
    readingTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _avg?: BlogPostAvgAggregateInputType
    _sum?: BlogPostSumAggregateInputType
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: string
    title: string
    content: string
    slug: string
    excerpt: string | null
    coverImageUrl: string | null
    published: boolean
    status: $Enums.PostStatus
    publishedAt: Date | null
    authorId: string
    categoryId: string | null
    views: number
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string[]
    ogImage: string | null
    canonicalUrl: string | null
    readingTime: number | null
    createdAt: Date
    updatedAt: Date
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    slug?: boolean
    excerpt?: boolean
    coverImageUrl?: boolean
    published?: boolean
    status?: boolean
    publishedAt?: boolean
    authorId?: boolean
    categoryId?: boolean
    views?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    ogImage?: boolean
    canonicalUrl?: boolean
    readingTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
    tags?: boolean | BlogPost$tagsArgs<ExtArgs>
    comments?: boolean | BlogPost$commentsArgs<ExtArgs>
    likes?: boolean | BlogPost$likesArgs<ExtArgs>
    analytics?: boolean | BlogPost$analyticsArgs<ExtArgs>
    notifications?: boolean | BlogPost$notificationsArgs<ExtArgs>
    _count?: boolean | BlogPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    slug?: boolean
    excerpt?: boolean
    coverImageUrl?: boolean
    published?: boolean
    status?: boolean
    publishedAt?: boolean
    authorId?: boolean
    categoryId?: boolean
    views?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    ogImage?: boolean
    canonicalUrl?: boolean
    readingTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    slug?: boolean
    excerpt?: boolean
    coverImageUrl?: boolean
    published?: boolean
    status?: boolean
    publishedAt?: boolean
    authorId?: boolean
    categoryId?: boolean
    views?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    ogImage?: boolean
    canonicalUrl?: boolean
    readingTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
    tags?: boolean | BlogPost$tagsArgs<ExtArgs>
    comments?: boolean | BlogPost$commentsArgs<ExtArgs>
    likes?: boolean | BlogPost$likesArgs<ExtArgs>
    analytics?: boolean | BlogPost$analyticsArgs<ExtArgs>
    notifications?: boolean | BlogPost$notificationsArgs<ExtArgs>
    _count?: boolean | BlogPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
  }

  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs> | null
      tags: Prisma.$BlogTagPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
      analytics: Prisma.$PostAnalyticsPayload<ExtArgs>[]
      notifications: Prisma.$PostNotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      slug: string
      excerpt: string | null
      coverImageUrl: string | null
      published: boolean
      status: $Enums.PostStatus
      publishedAt: Date | null
      authorId: string
      categoryId: string | null
      views: number
      metaTitle: string | null
      metaDescription: string | null
      metaKeywords: string[]
      ogImage: string | null
      canonicalUrl: string | null
      readingTime: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }

  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostFindUniqueArgs>(args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlogPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostFindFirstArgs>(args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostFindManyArgs>(args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
     */
    create<T extends BlogPostCreateArgs>(args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlogPosts.
     * @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostCreateManyArgs>(args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPosts and returns the data saved in the database.
     * @param {BlogPostCreateManyAndReturnArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
     */
    delete<T extends BlogPostDeleteArgs>(args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostUpdateArgs>(args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostDeleteManyArgs>(args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostUpdateManyArgs>(args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostUpsertArgs>(args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    category<T extends BlogPost$categoryArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tags<T extends BlogPost$tagsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends BlogPost$commentsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    likes<T extends BlogPost$likesArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany"> | Null>
    analytics<T extends BlogPost$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$analyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends BlogPost$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostNotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPost model
   */ 
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'String'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly content: FieldRef<"BlogPost", 'String'>
    readonly slug: FieldRef<"BlogPost", 'String'>
    readonly excerpt: FieldRef<"BlogPost", 'String'>
    readonly coverImageUrl: FieldRef<"BlogPost", 'String'>
    readonly published: FieldRef<"BlogPost", 'Boolean'>
    readonly status: FieldRef<"BlogPost", 'PostStatus'>
    readonly publishedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly authorId: FieldRef<"BlogPost", 'String'>
    readonly categoryId: FieldRef<"BlogPost", 'String'>
    readonly views: FieldRef<"BlogPost", 'Int'>
    readonly metaTitle: FieldRef<"BlogPost", 'String'>
    readonly metaDescription: FieldRef<"BlogPost", 'String'>
    readonly metaKeywords: FieldRef<"BlogPost", 'String[]'>
    readonly ogImage: FieldRef<"BlogPost", 'String'>
    readonly canonicalUrl: FieldRef<"BlogPost", 'String'>
    readonly readingTime: FieldRef<"BlogPost", 'Int'>
    readonly createdAt: FieldRef<"BlogPost", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost createManyAndReturn
   */
  export type BlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost.category
   */
  export type BlogPost$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * BlogPost.tags
   */
  export type BlogPost$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    where?: BlogTagWhereInput
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    cursor?: BlogTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogPost.comments
   */
  export type BlogPost$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * BlogPost.likes
   */
  export type BlogPost$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * BlogPost.analytics
   */
  export type BlogPost$analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    where?: PostAnalyticsWhereInput
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    cursor?: PostAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostAnalyticsScalarFieldEnum | PostAnalyticsScalarFieldEnum[]
  }

  /**
   * BlogPost.notifications
   */
  export type BlogPost$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostNotification
     */
    select?: PostNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostNotificationInclude<ExtArgs> | null
    where?: PostNotificationWhereInput
    orderBy?: PostNotificationOrderByWithRelationInput | PostNotificationOrderByWithRelationInput[]
    cursor?: PostNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostNotificationScalarFieldEnum | PostNotificationScalarFieldEnum[]
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
  }


  /**
   * Model BlogTag
   */

  export type AggregateBlogTag = {
    _count: BlogTagCountAggregateOutputType | null
    _min: BlogTagMinAggregateOutputType | null
    _max: BlogTagMaxAggregateOutputType | null
  }

  export type BlogTagMinAggregateOutputType = {
    postId: string | null
    tagId: string | null
  }

  export type BlogTagMaxAggregateOutputType = {
    postId: string | null
    tagId: string | null
  }

  export type BlogTagCountAggregateOutputType = {
    postId: number
    tagId: number
    _all: number
  }


  export type BlogTagMinAggregateInputType = {
    postId?: true
    tagId?: true
  }

  export type BlogTagMaxAggregateInputType = {
    postId?: true
    tagId?: true
  }

  export type BlogTagCountAggregateInputType = {
    postId?: true
    tagId?: true
    _all?: true
  }

  export type BlogTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogTag to aggregate.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogTags
    **/
    _count?: true | BlogTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogTagMaxAggregateInputType
  }

  export type GetBlogTagAggregateType<T extends BlogTagAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogTag[P]>
      : GetScalarType<T[P], AggregateBlogTag[P]>
  }




  export type BlogTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogTagWhereInput
    orderBy?: BlogTagOrderByWithAggregationInput | BlogTagOrderByWithAggregationInput[]
    by: BlogTagScalarFieldEnum[] | BlogTagScalarFieldEnum
    having?: BlogTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogTagCountAggregateInputType | true
    _min?: BlogTagMinAggregateInputType
    _max?: BlogTagMaxAggregateInputType
  }

  export type BlogTagGroupByOutputType = {
    postId: string
    tagId: string
    _count: BlogTagCountAggregateOutputType | null
    _min: BlogTagMinAggregateOutputType | null
    _max: BlogTagMaxAggregateOutputType | null
  }

  type GetBlogTagGroupByPayload<T extends BlogTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogTagGroupByOutputType[P]>
            : GetScalarType<T[P], BlogTagGroupByOutputType[P]>
        }
      >
    >


  export type BlogTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogTag"]>

  export type BlogTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogTag"]>

  export type BlogTagSelectScalar = {
    postId?: boolean
    tagId?: boolean
  }

  export type BlogTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type BlogTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $BlogTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogTag"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      postId: string
      tagId: string
    }, ExtArgs["result"]["blogTag"]>
    composites: {}
  }

  type BlogTagGetPayload<S extends boolean | null | undefined | BlogTagDefaultArgs> = $Result.GetResult<Prisma.$BlogTagPayload, S>

  type BlogTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlogTagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogTagCountAggregateInputType | true
    }

  export interface BlogTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogTag'], meta: { name: 'BlogTag' } }
    /**
     * Find zero or one BlogTag that matches the filter.
     * @param {BlogTagFindUniqueArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogTagFindUniqueArgs>(args: SelectSubset<T, BlogTagFindUniqueArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlogTag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlogTagFindUniqueOrThrowArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogTagFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlogTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagFindFirstArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogTagFindFirstArgs>(args?: SelectSubset<T, BlogTagFindFirstArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlogTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagFindFirstOrThrowArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogTagFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlogTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogTags
     * const blogTags = await prisma.blogTag.findMany()
     * 
     * // Get first 10 BlogTags
     * const blogTags = await prisma.blogTag.findMany({ take: 10 })
     * 
     * // Only select the `postId`
     * const blogTagWithPostIdOnly = await prisma.blogTag.findMany({ select: { postId: true } })
     * 
     */
    findMany<T extends BlogTagFindManyArgs>(args?: SelectSubset<T, BlogTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlogTag.
     * @param {BlogTagCreateArgs} args - Arguments to create a BlogTag.
     * @example
     * // Create one BlogTag
     * const BlogTag = await prisma.blogTag.create({
     *   data: {
     *     // ... data to create a BlogTag
     *   }
     * })
     * 
     */
    create<T extends BlogTagCreateArgs>(args: SelectSubset<T, BlogTagCreateArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlogTags.
     * @param {BlogTagCreateManyArgs} args - Arguments to create many BlogTags.
     * @example
     * // Create many BlogTags
     * const blogTag = await prisma.blogTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogTagCreateManyArgs>(args?: SelectSubset<T, BlogTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogTags and returns the data saved in the database.
     * @param {BlogTagCreateManyAndReturnArgs} args - Arguments to create many BlogTags.
     * @example
     * // Create many BlogTags
     * const blogTag = await prisma.blogTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogTags and only return the `postId`
     * const blogTagWithPostIdOnly = await prisma.blogTag.createManyAndReturn({ 
     *   select: { postId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogTagCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlogTag.
     * @param {BlogTagDeleteArgs} args - Arguments to delete one BlogTag.
     * @example
     * // Delete one BlogTag
     * const BlogTag = await prisma.blogTag.delete({
     *   where: {
     *     // ... filter to delete one BlogTag
     *   }
     * })
     * 
     */
    delete<T extends BlogTagDeleteArgs>(args: SelectSubset<T, BlogTagDeleteArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlogTag.
     * @param {BlogTagUpdateArgs} args - Arguments to update one BlogTag.
     * @example
     * // Update one BlogTag
     * const blogTag = await prisma.blogTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogTagUpdateArgs>(args: SelectSubset<T, BlogTagUpdateArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlogTags.
     * @param {BlogTagDeleteManyArgs} args - Arguments to filter BlogTags to delete.
     * @example
     * // Delete a few BlogTags
     * const { count } = await prisma.blogTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogTagDeleteManyArgs>(args?: SelectSubset<T, BlogTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogTags
     * const blogTag = await prisma.blogTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogTagUpdateManyArgs>(args: SelectSubset<T, BlogTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogTag.
     * @param {BlogTagUpsertArgs} args - Arguments to update or create a BlogTag.
     * @example
     * // Update or create a BlogTag
     * const blogTag = await prisma.blogTag.upsert({
     *   create: {
     *     // ... data to create a BlogTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogTag we want to update
     *   }
     * })
     */
    upsert<T extends BlogTagUpsertArgs>(args: SelectSubset<T, BlogTagUpsertArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlogTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagCountArgs} args - Arguments to filter BlogTags to count.
     * @example
     * // Count the number of BlogTags
     * const count = await prisma.blogTag.count({
     *   where: {
     *     // ... the filter for the BlogTags we want to count
     *   }
     * })
    **/
    count<T extends BlogTagCountArgs>(
      args?: Subset<T, BlogTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogTagAggregateArgs>(args: Subset<T, BlogTagAggregateArgs>): Prisma.PrismaPromise<GetBlogTagAggregateType<T>>

    /**
     * Group by BlogTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogTagGroupByArgs['orderBy'] }
        : { orderBy?: BlogTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogTag model
   */
  readonly fields: BlogTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogTag model
   */ 
  interface BlogTagFieldRefs {
    readonly postId: FieldRef<"BlogTag", 'String'>
    readonly tagId: FieldRef<"BlogTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BlogTag findUnique
   */
  export type BlogTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag findUniqueOrThrow
   */
  export type BlogTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag findFirst
   */
  export type BlogTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogTags.
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogTags.
     */
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogTag findFirstOrThrow
   */
  export type BlogTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogTags.
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogTags.
     */
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogTag findMany
   */
  export type BlogTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTags to fetch.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogTags.
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogTag create
   */
  export type BlogTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogTag.
     */
    data: XOR<BlogTagCreateInput, BlogTagUncheckedCreateInput>
  }

  /**
   * BlogTag createMany
   */
  export type BlogTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogTags.
     */
    data: BlogTagCreateManyInput | BlogTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogTag createManyAndReturn
   */
  export type BlogTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlogTags.
     */
    data: BlogTagCreateManyInput | BlogTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogTag update
   */
  export type BlogTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogTag.
     */
    data: XOR<BlogTagUpdateInput, BlogTagUncheckedUpdateInput>
    /**
     * Choose, which BlogTag to update.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag updateMany
   */
  export type BlogTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogTags.
     */
    data: XOR<BlogTagUpdateManyMutationInput, BlogTagUncheckedUpdateManyInput>
    /**
     * Filter which BlogTags to update
     */
    where?: BlogTagWhereInput
  }

  /**
   * BlogTag upsert
   */
  export type BlogTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogTag to update in case it exists.
     */
    where: BlogTagWhereUniqueInput
    /**
     * In case the BlogTag found by the `where` argument doesn't exist, create a new BlogTag with this data.
     */
    create: XOR<BlogTagCreateInput, BlogTagUncheckedCreateInput>
    /**
     * In case the BlogTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogTagUpdateInput, BlogTagUncheckedUpdateInput>
  }

  /**
   * BlogTag delete
   */
  export type BlogTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter which BlogTag to delete.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag deleteMany
   */
  export type BlogTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogTags to delete
     */
    where?: BlogTagWhereInput
  }

  /**
   * BlogTag without action
   */
  export type BlogTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    postId: string | null
    userId: string | null
    parentId: string | null
    approved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    postId: string | null
    userId: string | null
    parentId: string | null
    approved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    postId: number
    userId: number
    parentId: number
    approved: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    postId?: true
    userId?: true
    parentId?: true
    approved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    postId?: true
    userId?: true
    parentId?: true
    approved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    postId?: true
    userId?: true
    parentId?: true
    approved?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    content: string
    postId: string
    userId: string
    parentId: string | null
    approved: boolean
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    postId?: boolean
    userId?: boolean
    parentId?: boolean
    approved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    postId?: boolean
    userId?: boolean
    parentId?: boolean
    approved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    postId?: boolean
    userId?: boolean
    parentId?: boolean
    approved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$CommentPayload<ExtArgs> | null
      replies: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      postId: string
      userId: string
      parentId: string | null
      approved: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly parentId: FieldRef<"Comment", 'String'>
    readonly approved: FieldRef<"Comment", 'Boolean'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Like
   */

  export type AggregateLike = {
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  export type LikeMinAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LikeMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LikeCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type LikeMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
  }

  export type LikeMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
  }

  export type LikeCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type LikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Like to aggregate.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeMaxAggregateInputType
  }

  export type GetLikeAggregateType<T extends LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLike[P]>
      : GetScalarType<T[P], AggregateLike[P]>
  }




  export type LikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithAggregationInput | LikeOrderByWithAggregationInput[]
    by: LikeScalarFieldEnum[] | LikeScalarFieldEnum
    having?: LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCountAggregateInputType | true
    _min?: LikeMinAggregateInputType
    _max?: LikeMaxAggregateInputType
  }

  export type LikeGroupByOutputType = {
    id: string
    postId: string
    userId: string
    createdAt: Date
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  type GetLikeGroupByPayload<T extends LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeGroupByOutputType[P]>
            : GetScalarType<T[P], LikeGroupByOutputType[P]>
        }
      >
    >


  export type LikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type LikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Like"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["like"]>
    composites: {}
  }

  type LikeGetPayload<S extends boolean | null | undefined | LikeDefaultArgs> = $Result.GetResult<Prisma.$LikePayload, S>

  type LikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LikeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LikeCountAggregateInputType | true
    }

  export interface LikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Like'], meta: { name: 'Like' } }
    /**
     * Find zero or one Like that matches the filter.
     * @param {LikeFindUniqueArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeFindUniqueArgs>(args: SelectSubset<T, LikeFindUniqueArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Like that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LikeFindUniqueOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeFindFirstArgs>(args?: SelectSubset<T, LikeFindFirstArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.like.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeWithIdOnly = await prisma.like.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikeFindManyArgs>(args?: SelectSubset<T, LikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Like.
     * @param {LikeCreateArgs} args - Arguments to create a Like.
     * @example
     * // Create one Like
     * const Like = await prisma.like.create({
     *   data: {
     *     // ... data to create a Like
     *   }
     * })
     * 
     */
    create<T extends LikeCreateArgs>(args: SelectSubset<T, LikeCreateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Likes.
     * @param {LikeCreateManyArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeCreateManyArgs>(args?: SelectSubset<T, LikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Likes and returns the data saved in the database.
     * @param {LikeCreateManyAndReturnArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Likes and only return the `id`
     * const likeWithIdOnly = await prisma.like.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikeCreateManyAndReturnArgs>(args?: SelectSubset<T, LikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Like.
     * @param {LikeDeleteArgs} args - Arguments to delete one Like.
     * @example
     * // Delete one Like
     * const Like = await prisma.like.delete({
     *   where: {
     *     // ... filter to delete one Like
     *   }
     * })
     * 
     */
    delete<T extends LikeDeleteArgs>(args: SelectSubset<T, LikeDeleteArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Like.
     * @param {LikeUpdateArgs} args - Arguments to update one Like.
     * @example
     * // Update one Like
     * const like = await prisma.like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeUpdateArgs>(args: SelectSubset<T, LikeUpdateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Likes.
     * @param {LikeDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeDeleteManyArgs>(args?: SelectSubset<T, LikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeUpdateManyArgs>(args: SelectSubset<T, LikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Like.
     * @param {LikeUpsertArgs} args - Arguments to update or create a Like.
     * @example
     * // Update or create a Like
     * const like = await prisma.like.upsert({
     *   create: {
     *     // ... data to create a Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Like we want to update
     *   }
     * })
     */
    upsert<T extends LikeUpsertArgs>(args: SelectSubset<T, LikeUpsertArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.like.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikeCountArgs>(
      args?: Subset<T, LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeAggregateArgs>(args: Subset<T, LikeAggregateArgs>): Prisma.PrismaPromise<GetLikeAggregateType<T>>

    /**
     * Group by Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeGroupByArgs['orderBy'] }
        : { orderBy?: LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Like model
   */
  readonly fields: LikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Like model
   */ 
  interface LikeFieldRefs {
    readonly id: FieldRef<"Like", 'String'>
    readonly postId: FieldRef<"Like", 'String'>
    readonly userId: FieldRef<"Like", 'String'>
    readonly createdAt: FieldRef<"Like", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Like findUnique
   */
  export type LikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findUniqueOrThrow
   */
  export type LikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findFirst
   */
  export type LikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findFirstOrThrow
   */
  export type LikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findMany
   */
  export type LikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like create
   */
  export type LikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to create a Like.
     */
    data: XOR<LikeCreateInput, LikeUncheckedCreateInput>
  }

  /**
   * Like createMany
   */
  export type LikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Like createManyAndReturn
   */
  export type LikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Like update
   */
  export type LikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to update a Like.
     */
    data: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    /**
     * Choose, which Like to update.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like updateMany
   */
  export type LikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
  }

  /**
   * Like upsert
   */
  export type LikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The filter to search for the Like to update in case it exists.
     */
    where: LikeWhereUniqueInput
    /**
     * In case the Like found by the `where` argument doesn't exist, create a new Like with this data.
     */
    create: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    /**
     * In case the Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
  }

  /**
   * Like delete
   */
  export type LikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter which Like to delete.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like deleteMany
   */
  export type LikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikeWhereInput
  }

  /**
   * Like without action
   */
  export type LikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
  }


  /**
   * Model CollaboratorApplication
   */

  export type AggregateCollaboratorApplication = {
    _count: CollaboratorApplicationCountAggregateOutputType | null
    _avg: CollaboratorApplicationAvgAggregateOutputType | null
    _sum: CollaboratorApplicationSumAggregateOutputType | null
    _min: CollaboratorApplicationMinAggregateOutputType | null
    _max: CollaboratorApplicationMaxAggregateOutputType | null
  }

  export type CollaboratorApplicationAvgAggregateOutputType = {
    expectedSalary: number | null
    score: number | null
  }

  export type CollaboratorApplicationSumAggregateOutputType = {
    expectedSalary: number | null
    score: number | null
  }

  export type CollaboratorApplicationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    fullName: string | null
    email: string | null
    phone: string | null
    cpf: string | null
    birthDate: Date | null
    zipCode: string | null
    address: string | null
    city: string | null
    state: string | null
    area: string | null
    education: string | null
    experience: string | null
    availability: string | null
    expectedSalary: number | null
    resumeUrl: string | null
    linkedin: string | null
    github: string | null
    status: $Enums.ApplicationStatus | null
    stage: $Enums.ApplicationStage | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
    reviewedAt: Date | null
    approvedAt: Date | null
    rejectedAt: Date | null
    reviewerId: string | null
  }

  export type CollaboratorApplicationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    fullName: string | null
    email: string | null
    phone: string | null
    cpf: string | null
    birthDate: Date | null
    zipCode: string | null
    address: string | null
    city: string | null
    state: string | null
    area: string | null
    education: string | null
    experience: string | null
    availability: string | null
    expectedSalary: number | null
    resumeUrl: string | null
    linkedin: string | null
    github: string | null
    status: $Enums.ApplicationStatus | null
    stage: $Enums.ApplicationStage | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
    reviewedAt: Date | null
    approvedAt: Date | null
    rejectedAt: Date | null
    reviewerId: string | null
  }

  export type CollaboratorApplicationCountAggregateOutputType = {
    id: number
    userId: number
    fullName: number
    email: number
    phone: number
    cpf: number
    birthDate: number
    zipCode: number
    address: number
    city: number
    state: number
    area: number
    education: number
    experience: number
    skills: number
    availability: number
    expectedSalary: number
    resumeUrl: number
    portfolioUrls: number
    linkedin: number
    github: number
    status: number
    stage: number
    score: number
    createdAt: number
    updatedAt: number
    reviewedAt: number
    approvedAt: number
    rejectedAt: number
    reviewerId: number
    _all: number
  }


  export type CollaboratorApplicationAvgAggregateInputType = {
    expectedSalary?: true
    score?: true
  }

  export type CollaboratorApplicationSumAggregateInputType = {
    expectedSalary?: true
    score?: true
  }

  export type CollaboratorApplicationMinAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    email?: true
    phone?: true
    cpf?: true
    birthDate?: true
    zipCode?: true
    address?: true
    city?: true
    state?: true
    area?: true
    education?: true
    experience?: true
    availability?: true
    expectedSalary?: true
    resumeUrl?: true
    linkedin?: true
    github?: true
    status?: true
    stage?: true
    score?: true
    createdAt?: true
    updatedAt?: true
    reviewedAt?: true
    approvedAt?: true
    rejectedAt?: true
    reviewerId?: true
  }

  export type CollaboratorApplicationMaxAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    email?: true
    phone?: true
    cpf?: true
    birthDate?: true
    zipCode?: true
    address?: true
    city?: true
    state?: true
    area?: true
    education?: true
    experience?: true
    availability?: true
    expectedSalary?: true
    resumeUrl?: true
    linkedin?: true
    github?: true
    status?: true
    stage?: true
    score?: true
    createdAt?: true
    updatedAt?: true
    reviewedAt?: true
    approvedAt?: true
    rejectedAt?: true
    reviewerId?: true
  }

  export type CollaboratorApplicationCountAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    email?: true
    phone?: true
    cpf?: true
    birthDate?: true
    zipCode?: true
    address?: true
    city?: true
    state?: true
    area?: true
    education?: true
    experience?: true
    skills?: true
    availability?: true
    expectedSalary?: true
    resumeUrl?: true
    portfolioUrls?: true
    linkedin?: true
    github?: true
    status?: true
    stage?: true
    score?: true
    createdAt?: true
    updatedAt?: true
    reviewedAt?: true
    approvedAt?: true
    rejectedAt?: true
    reviewerId?: true
    _all?: true
  }

  export type CollaboratorApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollaboratorApplication to aggregate.
     */
    where?: CollaboratorApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollaboratorApplications to fetch.
     */
    orderBy?: CollaboratorApplicationOrderByWithRelationInput | CollaboratorApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollaboratorApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollaboratorApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollaboratorApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollaboratorApplications
    **/
    _count?: true | CollaboratorApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollaboratorApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollaboratorApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollaboratorApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollaboratorApplicationMaxAggregateInputType
  }

  export type GetCollaboratorApplicationAggregateType<T extends CollaboratorApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateCollaboratorApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollaboratorApplication[P]>
      : GetScalarType<T[P], AggregateCollaboratorApplication[P]>
  }




  export type CollaboratorApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollaboratorApplicationWhereInput
    orderBy?: CollaboratorApplicationOrderByWithAggregationInput | CollaboratorApplicationOrderByWithAggregationInput[]
    by: CollaboratorApplicationScalarFieldEnum[] | CollaboratorApplicationScalarFieldEnum
    having?: CollaboratorApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollaboratorApplicationCountAggregateInputType | true
    _avg?: CollaboratorApplicationAvgAggregateInputType
    _sum?: CollaboratorApplicationSumAggregateInputType
    _min?: CollaboratorApplicationMinAggregateInputType
    _max?: CollaboratorApplicationMaxAggregateInputType
  }

  export type CollaboratorApplicationGroupByOutputType = {
    id: string
    userId: string
    fullName: string
    email: string
    phone: string
    cpf: string | null
    birthDate: Date | null
    zipCode: string | null
    address: string | null
    city: string | null
    state: string | null
    area: string
    education: string | null
    experience: string
    skills: JsonValue | null
    availability: string
    expectedSalary: number | null
    resumeUrl: string | null
    portfolioUrls: JsonValue | null
    linkedin: string | null
    github: string | null
    status: $Enums.ApplicationStatus
    stage: $Enums.ApplicationStage
    score: number | null
    createdAt: Date
    updatedAt: Date
    reviewedAt: Date | null
    approvedAt: Date | null
    rejectedAt: Date | null
    reviewerId: string | null
    _count: CollaboratorApplicationCountAggregateOutputType | null
    _avg: CollaboratorApplicationAvgAggregateOutputType | null
    _sum: CollaboratorApplicationSumAggregateOutputType | null
    _min: CollaboratorApplicationMinAggregateOutputType | null
    _max: CollaboratorApplicationMaxAggregateOutputType | null
  }

  type GetCollaboratorApplicationGroupByPayload<T extends CollaboratorApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollaboratorApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollaboratorApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollaboratorApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], CollaboratorApplicationGroupByOutputType[P]>
        }
      >
    >


  export type CollaboratorApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    cpf?: boolean
    birthDate?: boolean
    zipCode?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    area?: boolean
    education?: boolean
    experience?: boolean
    skills?: boolean
    availability?: boolean
    expectedSalary?: boolean
    resumeUrl?: boolean
    portfolioUrls?: boolean
    linkedin?: boolean
    github?: boolean
    status?: boolean
    stage?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedAt?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    reviewerId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    evaluations?: boolean | CollaboratorApplication$evaluationsArgs<ExtArgs>
    notes?: boolean | CollaboratorApplication$notesArgs<ExtArgs>
    interviews?: boolean | CollaboratorApplication$interviewsArgs<ExtArgs>
    reviewer?: boolean | CollaboratorApplication$reviewerArgs<ExtArgs>
    _count?: boolean | CollaboratorApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collaboratorApplication"]>

  export type CollaboratorApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    cpf?: boolean
    birthDate?: boolean
    zipCode?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    area?: boolean
    education?: boolean
    experience?: boolean
    skills?: boolean
    availability?: boolean
    expectedSalary?: boolean
    resumeUrl?: boolean
    portfolioUrls?: boolean
    linkedin?: boolean
    github?: boolean
    status?: boolean
    stage?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedAt?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    reviewerId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | CollaboratorApplication$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["collaboratorApplication"]>

  export type CollaboratorApplicationSelectScalar = {
    id?: boolean
    userId?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    cpf?: boolean
    birthDate?: boolean
    zipCode?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    area?: boolean
    education?: boolean
    experience?: boolean
    skills?: boolean
    availability?: boolean
    expectedSalary?: boolean
    resumeUrl?: boolean
    portfolioUrls?: boolean
    linkedin?: boolean
    github?: boolean
    status?: boolean
    stage?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedAt?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    reviewerId?: boolean
  }

  export type CollaboratorApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    evaluations?: boolean | CollaboratorApplication$evaluationsArgs<ExtArgs>
    notes?: boolean | CollaboratorApplication$notesArgs<ExtArgs>
    interviews?: boolean | CollaboratorApplication$interviewsArgs<ExtArgs>
    reviewer?: boolean | CollaboratorApplication$reviewerArgs<ExtArgs>
    _count?: boolean | CollaboratorApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CollaboratorApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | CollaboratorApplication$reviewerArgs<ExtArgs>
  }

  export type $CollaboratorApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CollaboratorApplication"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
      interviews: Prisma.$InterviewPayload<ExtArgs>[]
      reviewer: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      fullName: string
      email: string
      phone: string
      cpf: string | null
      birthDate: Date | null
      zipCode: string | null
      address: string | null
      city: string | null
      state: string | null
      area: string
      education: string | null
      experience: string
      skills: Prisma.JsonValue | null
      availability: string
      expectedSalary: number | null
      resumeUrl: string | null
      portfolioUrls: Prisma.JsonValue | null
      linkedin: string | null
      github: string | null
      status: $Enums.ApplicationStatus
      stage: $Enums.ApplicationStage
      score: number | null
      createdAt: Date
      updatedAt: Date
      reviewedAt: Date | null
      approvedAt: Date | null
      rejectedAt: Date | null
      reviewerId: string | null
    }, ExtArgs["result"]["collaboratorApplication"]>
    composites: {}
  }

  type CollaboratorApplicationGetPayload<S extends boolean | null | undefined | CollaboratorApplicationDefaultArgs> = $Result.GetResult<Prisma.$CollaboratorApplicationPayload, S>

  type CollaboratorApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CollaboratorApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CollaboratorApplicationCountAggregateInputType | true
    }

  export interface CollaboratorApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollaboratorApplication'], meta: { name: 'CollaboratorApplication' } }
    /**
     * Find zero or one CollaboratorApplication that matches the filter.
     * @param {CollaboratorApplicationFindUniqueArgs} args - Arguments to find a CollaboratorApplication
     * @example
     * // Get one CollaboratorApplication
     * const collaboratorApplication = await prisma.collaboratorApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollaboratorApplicationFindUniqueArgs>(args: SelectSubset<T, CollaboratorApplicationFindUniqueArgs<ExtArgs>>): Prisma__CollaboratorApplicationClient<$Result.GetResult<Prisma.$CollaboratorApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CollaboratorApplication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CollaboratorApplicationFindUniqueOrThrowArgs} args - Arguments to find a CollaboratorApplication
     * @example
     * // Get one CollaboratorApplication
     * const collaboratorApplication = await prisma.collaboratorApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollaboratorApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, CollaboratorApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollaboratorApplicationClient<$Result.GetResult<Prisma.$CollaboratorApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CollaboratorApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorApplicationFindFirstArgs} args - Arguments to find a CollaboratorApplication
     * @example
     * // Get one CollaboratorApplication
     * const collaboratorApplication = await prisma.collaboratorApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollaboratorApplicationFindFirstArgs>(args?: SelectSubset<T, CollaboratorApplicationFindFirstArgs<ExtArgs>>): Prisma__CollaboratorApplicationClient<$Result.GetResult<Prisma.$CollaboratorApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CollaboratorApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorApplicationFindFirstOrThrowArgs} args - Arguments to find a CollaboratorApplication
     * @example
     * // Get one CollaboratorApplication
     * const collaboratorApplication = await prisma.collaboratorApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollaboratorApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, CollaboratorApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollaboratorApplicationClient<$Result.GetResult<Prisma.$CollaboratorApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CollaboratorApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollaboratorApplications
     * const collaboratorApplications = await prisma.collaboratorApplication.findMany()
     * 
     * // Get first 10 CollaboratorApplications
     * const collaboratorApplications = await prisma.collaboratorApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collaboratorApplicationWithIdOnly = await prisma.collaboratorApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollaboratorApplicationFindManyArgs>(args?: SelectSubset<T, CollaboratorApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollaboratorApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CollaboratorApplication.
     * @param {CollaboratorApplicationCreateArgs} args - Arguments to create a CollaboratorApplication.
     * @example
     * // Create one CollaboratorApplication
     * const CollaboratorApplication = await prisma.collaboratorApplication.create({
     *   data: {
     *     // ... data to create a CollaboratorApplication
     *   }
     * })
     * 
     */
    create<T extends CollaboratorApplicationCreateArgs>(args: SelectSubset<T, CollaboratorApplicationCreateArgs<ExtArgs>>): Prisma__CollaboratorApplicationClient<$Result.GetResult<Prisma.$CollaboratorApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CollaboratorApplications.
     * @param {CollaboratorApplicationCreateManyArgs} args - Arguments to create many CollaboratorApplications.
     * @example
     * // Create many CollaboratorApplications
     * const collaboratorApplication = await prisma.collaboratorApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollaboratorApplicationCreateManyArgs>(args?: SelectSubset<T, CollaboratorApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CollaboratorApplications and returns the data saved in the database.
     * @param {CollaboratorApplicationCreateManyAndReturnArgs} args - Arguments to create many CollaboratorApplications.
     * @example
     * // Create many CollaboratorApplications
     * const collaboratorApplication = await prisma.collaboratorApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CollaboratorApplications and only return the `id`
     * const collaboratorApplicationWithIdOnly = await prisma.collaboratorApplication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollaboratorApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, CollaboratorApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollaboratorApplicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CollaboratorApplication.
     * @param {CollaboratorApplicationDeleteArgs} args - Arguments to delete one CollaboratorApplication.
     * @example
     * // Delete one CollaboratorApplication
     * const CollaboratorApplication = await prisma.collaboratorApplication.delete({
     *   where: {
     *     // ... filter to delete one CollaboratorApplication
     *   }
     * })
     * 
     */
    delete<T extends CollaboratorApplicationDeleteArgs>(args: SelectSubset<T, CollaboratorApplicationDeleteArgs<ExtArgs>>): Prisma__CollaboratorApplicationClient<$Result.GetResult<Prisma.$CollaboratorApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CollaboratorApplication.
     * @param {CollaboratorApplicationUpdateArgs} args - Arguments to update one CollaboratorApplication.
     * @example
     * // Update one CollaboratorApplication
     * const collaboratorApplication = await prisma.collaboratorApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollaboratorApplicationUpdateArgs>(args: SelectSubset<T, CollaboratorApplicationUpdateArgs<ExtArgs>>): Prisma__CollaboratorApplicationClient<$Result.GetResult<Prisma.$CollaboratorApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CollaboratorApplications.
     * @param {CollaboratorApplicationDeleteManyArgs} args - Arguments to filter CollaboratorApplications to delete.
     * @example
     * // Delete a few CollaboratorApplications
     * const { count } = await prisma.collaboratorApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollaboratorApplicationDeleteManyArgs>(args?: SelectSubset<T, CollaboratorApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollaboratorApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollaboratorApplications
     * const collaboratorApplication = await prisma.collaboratorApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollaboratorApplicationUpdateManyArgs>(args: SelectSubset<T, CollaboratorApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CollaboratorApplication.
     * @param {CollaboratorApplicationUpsertArgs} args - Arguments to update or create a CollaboratorApplication.
     * @example
     * // Update or create a CollaboratorApplication
     * const collaboratorApplication = await prisma.collaboratorApplication.upsert({
     *   create: {
     *     // ... data to create a CollaboratorApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollaboratorApplication we want to update
     *   }
     * })
     */
    upsert<T extends CollaboratorApplicationUpsertArgs>(args: SelectSubset<T, CollaboratorApplicationUpsertArgs<ExtArgs>>): Prisma__CollaboratorApplicationClient<$Result.GetResult<Prisma.$CollaboratorApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CollaboratorApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorApplicationCountArgs} args - Arguments to filter CollaboratorApplications to count.
     * @example
     * // Count the number of CollaboratorApplications
     * const count = await prisma.collaboratorApplication.count({
     *   where: {
     *     // ... the filter for the CollaboratorApplications we want to count
     *   }
     * })
    **/
    count<T extends CollaboratorApplicationCountArgs>(
      args?: Subset<T, CollaboratorApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollaboratorApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollaboratorApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollaboratorApplicationAggregateArgs>(args: Subset<T, CollaboratorApplicationAggregateArgs>): Prisma.PrismaPromise<GetCollaboratorApplicationAggregateType<T>>

    /**
     * Group by CollaboratorApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollaboratorApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollaboratorApplicationGroupByArgs['orderBy'] }
        : { orderBy?: CollaboratorApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollaboratorApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollaboratorApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CollaboratorApplication model
   */
  readonly fields: CollaboratorApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CollaboratorApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollaboratorApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    evaluations<T extends CollaboratorApplication$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, CollaboratorApplication$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findMany"> | Null>
    notes<T extends CollaboratorApplication$notesArgs<ExtArgs> = {}>(args?: Subset<T, CollaboratorApplication$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany"> | Null>
    interviews<T extends CollaboratorApplication$interviewsArgs<ExtArgs> = {}>(args?: Subset<T, CollaboratorApplication$interviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findMany"> | Null>
    reviewer<T extends CollaboratorApplication$reviewerArgs<ExtArgs> = {}>(args?: Subset<T, CollaboratorApplication$reviewerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CollaboratorApplication model
   */ 
  interface CollaboratorApplicationFieldRefs {
    readonly id: FieldRef<"CollaboratorApplication", 'String'>
    readonly userId: FieldRef<"CollaboratorApplication", 'String'>
    readonly fullName: FieldRef<"CollaboratorApplication", 'String'>
    readonly email: FieldRef<"CollaboratorApplication", 'String'>
    readonly phone: FieldRef<"CollaboratorApplication", 'String'>
    readonly cpf: FieldRef<"CollaboratorApplication", 'String'>
    readonly birthDate: FieldRef<"CollaboratorApplication", 'DateTime'>
    readonly zipCode: FieldRef<"CollaboratorApplication", 'String'>
    readonly address: FieldRef<"CollaboratorApplication", 'String'>
    readonly city: FieldRef<"CollaboratorApplication", 'String'>
    readonly state: FieldRef<"CollaboratorApplication", 'String'>
    readonly area: FieldRef<"CollaboratorApplication", 'String'>
    readonly education: FieldRef<"CollaboratorApplication", 'String'>
    readonly experience: FieldRef<"CollaboratorApplication", 'String'>
    readonly skills: FieldRef<"CollaboratorApplication", 'Json'>
    readonly availability: FieldRef<"CollaboratorApplication", 'String'>
    readonly expectedSalary: FieldRef<"CollaboratorApplication", 'Float'>
    readonly resumeUrl: FieldRef<"CollaboratorApplication", 'String'>
    readonly portfolioUrls: FieldRef<"CollaboratorApplication", 'Json'>
    readonly linkedin: FieldRef<"CollaboratorApplication", 'String'>
    readonly github: FieldRef<"CollaboratorApplication", 'String'>
    readonly status: FieldRef<"CollaboratorApplication", 'ApplicationStatus'>
    readonly stage: FieldRef<"CollaboratorApplication", 'ApplicationStage'>
    readonly score: FieldRef<"CollaboratorApplication", 'Int'>
    readonly createdAt: FieldRef<"CollaboratorApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"CollaboratorApplication", 'DateTime'>
    readonly reviewedAt: FieldRef<"CollaboratorApplication", 'DateTime'>
    readonly approvedAt: FieldRef<"CollaboratorApplication", 'DateTime'>
    readonly rejectedAt: FieldRef<"CollaboratorApplication", 'DateTime'>
    readonly reviewerId: FieldRef<"CollaboratorApplication", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CollaboratorApplication findUnique
   */
  export type CollaboratorApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorApplication
     */
    select?: CollaboratorApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaboratorApplicationInclude<ExtArgs> | null
    /**
     * Filter, which CollaboratorApplication to fetch.
     */
    where: CollaboratorApplicationWhereUniqueInput
  }

  /**
   * CollaboratorApplication findUniqueOrThrow
   */
  export type CollaboratorApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorApplication
     */
    select?: CollaboratorApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaboratorApplicationInclude<ExtArgs> | null
    /**
     * Filter, which CollaboratorApplication to fetch.
     */
    where: CollaboratorApplicationWhereUniqueInput
  }

  /**
   * CollaboratorApplication findFirst
   */
  export type CollaboratorApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorApplication
     */
    select?: CollaboratorApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaboratorApplicationInclude<ExtArgs> | null
    /**
     * Filter, which CollaboratorApplication to fetch.
     */
    where?: CollaboratorApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollaboratorApplications to fetch.
     */
    orderBy?: CollaboratorApplicationOrderByWithRelationInput | CollaboratorApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollaboratorApplications.
     */
    cursor?: CollaboratorApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollaboratorApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollaboratorApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollaboratorApplications.
     */
    distinct?: CollaboratorApplicationScalarFieldEnum | CollaboratorApplicationScalarFieldEnum[]
  }

  /**
   * CollaboratorApplication findFirstOrThrow
   */
  export type CollaboratorApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorApplication
     */
    select?: CollaboratorApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaboratorApplicationInclude<ExtArgs> | null
    /**
     * Filter, which CollaboratorApplication to fetch.
     */
    where?: CollaboratorApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollaboratorApplications to fetch.
     */
    orderBy?: CollaboratorApplicationOrderByWithRelationInput | CollaboratorApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollaboratorApplications.
     */
    cursor?: CollaboratorApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollaboratorApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollaboratorApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollaboratorApplications.
     */
    distinct?: CollaboratorApplicationScalarFieldEnum | CollaboratorApplicationScalarFieldEnum[]
  }

  /**
   * CollaboratorApplication findMany
   */
  export type CollaboratorApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorApplication
     */
    select?: CollaboratorApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaboratorApplicationInclude<ExtArgs> | null
    /**
     * Filter, which CollaboratorApplications to fetch.
     */
    where?: CollaboratorApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollaboratorApplications to fetch.
     */
    orderBy?: CollaboratorApplicationOrderByWithRelationInput | CollaboratorApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollaboratorApplications.
     */
    cursor?: CollaboratorApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollaboratorApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollaboratorApplications.
     */
    skip?: number
    distinct?: CollaboratorApplicationScalarFieldEnum | CollaboratorApplicationScalarFieldEnum[]
  }

  /**
   * CollaboratorApplication create
   */
  export type CollaboratorApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorApplication
     */
    select?: CollaboratorApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaboratorApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a CollaboratorApplication.
     */
    data: XOR<CollaboratorApplicationCreateInput, CollaboratorApplicationUncheckedCreateInput>
  }

  /**
   * CollaboratorApplication createMany
   */
  export type CollaboratorApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollaboratorApplications.
     */
    data: CollaboratorApplicationCreateManyInput | CollaboratorApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollaboratorApplication createManyAndReturn
   */
  export type CollaboratorApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorApplication
     */
    select?: CollaboratorApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CollaboratorApplications.
     */
    data: CollaboratorApplicationCreateManyInput | CollaboratorApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaboratorApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollaboratorApplication update
   */
  export type CollaboratorApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorApplication
     */
    select?: CollaboratorApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaboratorApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a CollaboratorApplication.
     */
    data: XOR<CollaboratorApplicationUpdateInput, CollaboratorApplicationUncheckedUpdateInput>
    /**
     * Choose, which CollaboratorApplication to update.
     */
    where: CollaboratorApplicationWhereUniqueInput
  }

  /**
   * CollaboratorApplication updateMany
   */
  export type CollaboratorApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollaboratorApplications.
     */
    data: XOR<CollaboratorApplicationUpdateManyMutationInput, CollaboratorApplicationUncheckedUpdateManyInput>
    /**
     * Filter which CollaboratorApplications to update
     */
    where?: CollaboratorApplicationWhereInput
  }

  /**
   * CollaboratorApplication upsert
   */
  export type CollaboratorApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorApplication
     */
    select?: CollaboratorApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaboratorApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the CollaboratorApplication to update in case it exists.
     */
    where: CollaboratorApplicationWhereUniqueInput
    /**
     * In case the CollaboratorApplication found by the `where` argument doesn't exist, create a new CollaboratorApplication with this data.
     */
    create: XOR<CollaboratorApplicationCreateInput, CollaboratorApplicationUncheckedCreateInput>
    /**
     * In case the CollaboratorApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollaboratorApplicationUpdateInput, CollaboratorApplicationUncheckedUpdateInput>
  }

  /**
   * CollaboratorApplication delete
   */
  export type CollaboratorApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorApplication
     */
    select?: CollaboratorApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaboratorApplicationInclude<ExtArgs> | null
    /**
     * Filter which CollaboratorApplication to delete.
     */
    where: CollaboratorApplicationWhereUniqueInput
  }

  /**
   * CollaboratorApplication deleteMany
   */
  export type CollaboratorApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollaboratorApplications to delete
     */
    where?: CollaboratorApplicationWhereInput
  }

  /**
   * CollaboratorApplication.evaluations
   */
  export type CollaboratorApplication$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * CollaboratorApplication.notes
   */
  export type CollaboratorApplication$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * CollaboratorApplication.interviews
   */
  export type CollaboratorApplication$interviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    where?: InterviewWhereInput
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    cursor?: InterviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * CollaboratorApplication.reviewer
   */
  export type CollaboratorApplication$reviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CollaboratorApplication without action
   */
  export type CollaboratorApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorApplication
     */
    select?: CollaboratorApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaboratorApplicationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    subject: string | null
    message: string | null
    status: $Enums.MessageStatus | null
    replied: boolean | null
    repliedAt: Date | null
    replyContent: string | null
    assignedTo: string | null
    priority: $Enums.Priority | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    subject: string | null
    message: string | null
    status: $Enums.MessageStatus | null
    replied: boolean | null
    repliedAt: Date | null
    replyContent: string | null
    assignedTo: string | null
    priority: $Enums.Priority | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    subject: number
    message: number
    status: number
    replied: number
    repliedAt: number
    replyContent: number
    assignedTo: number
    priority: number
    category: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    status?: true
    replied?: true
    repliedAt?: true
    replyContent?: true
    assignedTo?: true
    priority?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    status?: true
    replied?: true
    repliedAt?: true
    replyContent?: true
    assignedTo?: true
    priority?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    status?: true
    replied?: true
    repliedAt?: true
    replyContent?: true
    assignedTo?: true
    priority?: true
    category?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    subject: string
    message: string
    status: $Enums.MessageStatus
    replied: boolean
    repliedAt: Date | null
    replyContent: string | null
    assignedTo: string | null
    priority: $Enums.Priority
    category: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    replied?: boolean
    repliedAt?: boolean
    replyContent?: boolean
    assignedTo?: boolean
    priority?: boolean
    category?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    replied?: boolean
    repliedAt?: boolean
    replyContent?: boolean
    assignedTo?: boolean
    priority?: boolean
    category?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    replied?: boolean
    repliedAt?: boolean
    replyContent?: boolean
    assignedTo?: boolean
    priority?: boolean
    category?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      subject: string
      message: string
      status: $Enums.MessageStatus
      replied: boolean
      repliedAt: Date | null
      replyContent: string | null
      assignedTo: string | null
      priority: $Enums.Priority
      category: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly name: FieldRef<"Message", 'String'>
    readonly email: FieldRef<"Message", 'String'>
    readonly phone: FieldRef<"Message", 'String'>
    readonly subject: FieldRef<"Message", 'String'>
    readonly message: FieldRef<"Message", 'String'>
    readonly status: FieldRef<"Message", 'MessageStatus'>
    readonly replied: FieldRef<"Message", 'Boolean'>
    readonly repliedAt: FieldRef<"Message", 'DateTime'>
    readonly replyContent: FieldRef<"Message", 'String'>
    readonly assignedTo: FieldRef<"Message", 'String'>
    readonly priority: FieldRef<"Message", 'Priority'>
    readonly category: FieldRef<"Message", 'String'>
    readonly metadata: FieldRef<"Message", 'Json'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
  }


  /**
   * Model LegalDocument
   */

  export type AggregateLegalDocument = {
    _count: LegalDocumentCountAggregateOutputType | null
    _min: LegalDocumentMinAggregateOutputType | null
    _max: LegalDocumentMaxAggregateOutputType | null
  }

  export type LegalDocumentMinAggregateOutputType = {
    id: string | null
    type: $Enums.LegalType | null
    title: string | null
    content: string | null
    version: string | null
    active: boolean | null
    publishedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LegalDocumentMaxAggregateOutputType = {
    id: string | null
    type: $Enums.LegalType | null
    title: string | null
    content: string | null
    version: string | null
    active: boolean | null
    publishedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LegalDocumentCountAggregateOutputType = {
    id: number
    type: number
    title: number
    content: number
    version: number
    active: number
    publishedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LegalDocumentMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    version?: true
    active?: true
    publishedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LegalDocumentMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    version?: true
    active?: true
    publishedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LegalDocumentCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    version?: true
    active?: true
    publishedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LegalDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LegalDocument to aggregate.
     */
    where?: LegalDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LegalDocuments to fetch.
     */
    orderBy?: LegalDocumentOrderByWithRelationInput | LegalDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LegalDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LegalDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LegalDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LegalDocuments
    **/
    _count?: true | LegalDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LegalDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LegalDocumentMaxAggregateInputType
  }

  export type GetLegalDocumentAggregateType<T extends LegalDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateLegalDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLegalDocument[P]>
      : GetScalarType<T[P], AggregateLegalDocument[P]>
  }




  export type LegalDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LegalDocumentWhereInput
    orderBy?: LegalDocumentOrderByWithAggregationInput | LegalDocumentOrderByWithAggregationInput[]
    by: LegalDocumentScalarFieldEnum[] | LegalDocumentScalarFieldEnum
    having?: LegalDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LegalDocumentCountAggregateInputType | true
    _min?: LegalDocumentMinAggregateInputType
    _max?: LegalDocumentMaxAggregateInputType
  }

  export type LegalDocumentGroupByOutputType = {
    id: string
    type: $Enums.LegalType
    title: string
    content: string
    version: string
    active: boolean
    publishedBy: string
    createdAt: Date
    updatedAt: Date
    _count: LegalDocumentCountAggregateOutputType | null
    _min: LegalDocumentMinAggregateOutputType | null
    _max: LegalDocumentMaxAggregateOutputType | null
  }

  type GetLegalDocumentGroupByPayload<T extends LegalDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LegalDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LegalDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LegalDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], LegalDocumentGroupByOutputType[P]>
        }
      >
    >


  export type LegalDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    version?: boolean
    active?: boolean
    publishedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["legalDocument"]>

  export type LegalDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    version?: boolean
    active?: boolean
    publishedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["legalDocument"]>

  export type LegalDocumentSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    version?: boolean
    active?: boolean
    publishedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $LegalDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LegalDocument"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.LegalType
      title: string
      content: string
      version: string
      active: boolean
      publishedBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["legalDocument"]>
    composites: {}
  }

  type LegalDocumentGetPayload<S extends boolean | null | undefined | LegalDocumentDefaultArgs> = $Result.GetResult<Prisma.$LegalDocumentPayload, S>

  type LegalDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LegalDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LegalDocumentCountAggregateInputType | true
    }

  export interface LegalDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LegalDocument'], meta: { name: 'LegalDocument' } }
    /**
     * Find zero or one LegalDocument that matches the filter.
     * @param {LegalDocumentFindUniqueArgs} args - Arguments to find a LegalDocument
     * @example
     * // Get one LegalDocument
     * const legalDocument = await prisma.legalDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LegalDocumentFindUniqueArgs>(args: SelectSubset<T, LegalDocumentFindUniqueArgs<ExtArgs>>): Prisma__LegalDocumentClient<$Result.GetResult<Prisma.$LegalDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LegalDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LegalDocumentFindUniqueOrThrowArgs} args - Arguments to find a LegalDocument
     * @example
     * // Get one LegalDocument
     * const legalDocument = await prisma.legalDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LegalDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, LegalDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LegalDocumentClient<$Result.GetResult<Prisma.$LegalDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LegalDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalDocumentFindFirstArgs} args - Arguments to find a LegalDocument
     * @example
     * // Get one LegalDocument
     * const legalDocument = await prisma.legalDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LegalDocumentFindFirstArgs>(args?: SelectSubset<T, LegalDocumentFindFirstArgs<ExtArgs>>): Prisma__LegalDocumentClient<$Result.GetResult<Prisma.$LegalDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LegalDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalDocumentFindFirstOrThrowArgs} args - Arguments to find a LegalDocument
     * @example
     * // Get one LegalDocument
     * const legalDocument = await prisma.legalDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LegalDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, LegalDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LegalDocumentClient<$Result.GetResult<Prisma.$LegalDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LegalDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LegalDocuments
     * const legalDocuments = await prisma.legalDocument.findMany()
     * 
     * // Get first 10 LegalDocuments
     * const legalDocuments = await prisma.legalDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const legalDocumentWithIdOnly = await prisma.legalDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LegalDocumentFindManyArgs>(args?: SelectSubset<T, LegalDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LegalDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LegalDocument.
     * @param {LegalDocumentCreateArgs} args - Arguments to create a LegalDocument.
     * @example
     * // Create one LegalDocument
     * const LegalDocument = await prisma.legalDocument.create({
     *   data: {
     *     // ... data to create a LegalDocument
     *   }
     * })
     * 
     */
    create<T extends LegalDocumentCreateArgs>(args: SelectSubset<T, LegalDocumentCreateArgs<ExtArgs>>): Prisma__LegalDocumentClient<$Result.GetResult<Prisma.$LegalDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LegalDocuments.
     * @param {LegalDocumentCreateManyArgs} args - Arguments to create many LegalDocuments.
     * @example
     * // Create many LegalDocuments
     * const legalDocument = await prisma.legalDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LegalDocumentCreateManyArgs>(args?: SelectSubset<T, LegalDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LegalDocuments and returns the data saved in the database.
     * @param {LegalDocumentCreateManyAndReturnArgs} args - Arguments to create many LegalDocuments.
     * @example
     * // Create many LegalDocuments
     * const legalDocument = await prisma.legalDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LegalDocuments and only return the `id`
     * const legalDocumentWithIdOnly = await prisma.legalDocument.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LegalDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, LegalDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LegalDocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LegalDocument.
     * @param {LegalDocumentDeleteArgs} args - Arguments to delete one LegalDocument.
     * @example
     * // Delete one LegalDocument
     * const LegalDocument = await prisma.legalDocument.delete({
     *   where: {
     *     // ... filter to delete one LegalDocument
     *   }
     * })
     * 
     */
    delete<T extends LegalDocumentDeleteArgs>(args: SelectSubset<T, LegalDocumentDeleteArgs<ExtArgs>>): Prisma__LegalDocumentClient<$Result.GetResult<Prisma.$LegalDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LegalDocument.
     * @param {LegalDocumentUpdateArgs} args - Arguments to update one LegalDocument.
     * @example
     * // Update one LegalDocument
     * const legalDocument = await prisma.legalDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LegalDocumentUpdateArgs>(args: SelectSubset<T, LegalDocumentUpdateArgs<ExtArgs>>): Prisma__LegalDocumentClient<$Result.GetResult<Prisma.$LegalDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LegalDocuments.
     * @param {LegalDocumentDeleteManyArgs} args - Arguments to filter LegalDocuments to delete.
     * @example
     * // Delete a few LegalDocuments
     * const { count } = await prisma.legalDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LegalDocumentDeleteManyArgs>(args?: SelectSubset<T, LegalDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LegalDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LegalDocuments
     * const legalDocument = await prisma.legalDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LegalDocumentUpdateManyArgs>(args: SelectSubset<T, LegalDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LegalDocument.
     * @param {LegalDocumentUpsertArgs} args - Arguments to update or create a LegalDocument.
     * @example
     * // Update or create a LegalDocument
     * const legalDocument = await prisma.legalDocument.upsert({
     *   create: {
     *     // ... data to create a LegalDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LegalDocument we want to update
     *   }
     * })
     */
    upsert<T extends LegalDocumentUpsertArgs>(args: SelectSubset<T, LegalDocumentUpsertArgs<ExtArgs>>): Prisma__LegalDocumentClient<$Result.GetResult<Prisma.$LegalDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LegalDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalDocumentCountArgs} args - Arguments to filter LegalDocuments to count.
     * @example
     * // Count the number of LegalDocuments
     * const count = await prisma.legalDocument.count({
     *   where: {
     *     // ... the filter for the LegalDocuments we want to count
     *   }
     * })
    **/
    count<T extends LegalDocumentCountArgs>(
      args?: Subset<T, LegalDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LegalDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LegalDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LegalDocumentAggregateArgs>(args: Subset<T, LegalDocumentAggregateArgs>): Prisma.PrismaPromise<GetLegalDocumentAggregateType<T>>

    /**
     * Group by LegalDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LegalDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LegalDocumentGroupByArgs['orderBy'] }
        : { orderBy?: LegalDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LegalDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLegalDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LegalDocument model
   */
  readonly fields: LegalDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LegalDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LegalDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LegalDocument model
   */ 
  interface LegalDocumentFieldRefs {
    readonly id: FieldRef<"LegalDocument", 'String'>
    readonly type: FieldRef<"LegalDocument", 'LegalType'>
    readonly title: FieldRef<"LegalDocument", 'String'>
    readonly content: FieldRef<"LegalDocument", 'String'>
    readonly version: FieldRef<"LegalDocument", 'String'>
    readonly active: FieldRef<"LegalDocument", 'Boolean'>
    readonly publishedBy: FieldRef<"LegalDocument", 'String'>
    readonly createdAt: FieldRef<"LegalDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"LegalDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LegalDocument findUnique
   */
  export type LegalDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalDocument
     */
    select?: LegalDocumentSelect<ExtArgs> | null
    /**
     * Filter, which LegalDocument to fetch.
     */
    where: LegalDocumentWhereUniqueInput
  }

  /**
   * LegalDocument findUniqueOrThrow
   */
  export type LegalDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalDocument
     */
    select?: LegalDocumentSelect<ExtArgs> | null
    /**
     * Filter, which LegalDocument to fetch.
     */
    where: LegalDocumentWhereUniqueInput
  }

  /**
   * LegalDocument findFirst
   */
  export type LegalDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalDocument
     */
    select?: LegalDocumentSelect<ExtArgs> | null
    /**
     * Filter, which LegalDocument to fetch.
     */
    where?: LegalDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LegalDocuments to fetch.
     */
    orderBy?: LegalDocumentOrderByWithRelationInput | LegalDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LegalDocuments.
     */
    cursor?: LegalDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LegalDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LegalDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LegalDocuments.
     */
    distinct?: LegalDocumentScalarFieldEnum | LegalDocumentScalarFieldEnum[]
  }

  /**
   * LegalDocument findFirstOrThrow
   */
  export type LegalDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalDocument
     */
    select?: LegalDocumentSelect<ExtArgs> | null
    /**
     * Filter, which LegalDocument to fetch.
     */
    where?: LegalDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LegalDocuments to fetch.
     */
    orderBy?: LegalDocumentOrderByWithRelationInput | LegalDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LegalDocuments.
     */
    cursor?: LegalDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LegalDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LegalDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LegalDocuments.
     */
    distinct?: LegalDocumentScalarFieldEnum | LegalDocumentScalarFieldEnum[]
  }

  /**
   * LegalDocument findMany
   */
  export type LegalDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalDocument
     */
    select?: LegalDocumentSelect<ExtArgs> | null
    /**
     * Filter, which LegalDocuments to fetch.
     */
    where?: LegalDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LegalDocuments to fetch.
     */
    orderBy?: LegalDocumentOrderByWithRelationInput | LegalDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LegalDocuments.
     */
    cursor?: LegalDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LegalDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LegalDocuments.
     */
    skip?: number
    distinct?: LegalDocumentScalarFieldEnum | LegalDocumentScalarFieldEnum[]
  }

  /**
   * LegalDocument create
   */
  export type LegalDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalDocument
     */
    select?: LegalDocumentSelect<ExtArgs> | null
    /**
     * The data needed to create a LegalDocument.
     */
    data: XOR<LegalDocumentCreateInput, LegalDocumentUncheckedCreateInput>
  }

  /**
   * LegalDocument createMany
   */
  export type LegalDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LegalDocuments.
     */
    data: LegalDocumentCreateManyInput | LegalDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LegalDocument createManyAndReturn
   */
  export type LegalDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalDocument
     */
    select?: LegalDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LegalDocuments.
     */
    data: LegalDocumentCreateManyInput | LegalDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LegalDocument update
   */
  export type LegalDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalDocument
     */
    select?: LegalDocumentSelect<ExtArgs> | null
    /**
     * The data needed to update a LegalDocument.
     */
    data: XOR<LegalDocumentUpdateInput, LegalDocumentUncheckedUpdateInput>
    /**
     * Choose, which LegalDocument to update.
     */
    where: LegalDocumentWhereUniqueInput
  }

  /**
   * LegalDocument updateMany
   */
  export type LegalDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LegalDocuments.
     */
    data: XOR<LegalDocumentUpdateManyMutationInput, LegalDocumentUncheckedUpdateManyInput>
    /**
     * Filter which LegalDocuments to update
     */
    where?: LegalDocumentWhereInput
  }

  /**
   * LegalDocument upsert
   */
  export type LegalDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalDocument
     */
    select?: LegalDocumentSelect<ExtArgs> | null
    /**
     * The filter to search for the LegalDocument to update in case it exists.
     */
    where: LegalDocumentWhereUniqueInput
    /**
     * In case the LegalDocument found by the `where` argument doesn't exist, create a new LegalDocument with this data.
     */
    create: XOR<LegalDocumentCreateInput, LegalDocumentUncheckedCreateInput>
    /**
     * In case the LegalDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LegalDocumentUpdateInput, LegalDocumentUncheckedUpdateInput>
  }

  /**
   * LegalDocument delete
   */
  export type LegalDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalDocument
     */
    select?: LegalDocumentSelect<ExtArgs> | null
    /**
     * Filter which LegalDocument to delete.
     */
    where: LegalDocumentWhereUniqueInput
  }

  /**
   * LegalDocument deleteMany
   */
  export type LegalDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LegalDocuments to delete
     */
    where?: LegalDocumentWhereInput
  }

  /**
   * LegalDocument without action
   */
  export type LegalDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalDocument
     */
    select?: LegalDocumentSelect<ExtArgs> | null
  }


  /**
   * Model MessageTemplate
   */

  export type AggregateMessageTemplate = {
    _count: MessageTemplateCountAggregateOutputType | null
    _min: MessageTemplateMinAggregateOutputType | null
    _max: MessageTemplateMaxAggregateOutputType | null
  }

  export type MessageTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    content: string | null
    category: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    content: string | null
    category: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageTemplateCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    content: number
    variables: number
    category: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageTemplateMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    content?: true
    category?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    content?: true
    category?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageTemplateCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    content?: true
    variables?: true
    category?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageTemplate to aggregate.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageTemplates
    **/
    _count?: true | MessageTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageTemplateMaxAggregateInputType
  }

  export type GetMessageTemplateAggregateType<T extends MessageTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageTemplate[P]>
      : GetScalarType<T[P], AggregateMessageTemplate[P]>
  }




  export type MessageTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageTemplateWhereInput
    orderBy?: MessageTemplateOrderByWithAggregationInput | MessageTemplateOrderByWithAggregationInput[]
    by: MessageTemplateScalarFieldEnum[] | MessageTemplateScalarFieldEnum
    having?: MessageTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageTemplateCountAggregateInputType | true
    _min?: MessageTemplateMinAggregateInputType
    _max?: MessageTemplateMaxAggregateInputType
  }

  export type MessageTemplateGroupByOutputType = {
    id: string
    name: string
    subject: string
    content: string
    variables: string[]
    category: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: MessageTemplateCountAggregateOutputType | null
    _min: MessageTemplateMinAggregateOutputType | null
    _max: MessageTemplateMaxAggregateOutputType | null
  }

  type GetMessageTemplateGroupByPayload<T extends MessageTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], MessageTemplateGroupByOutputType[P]>
        }
      >
    >


  export type MessageTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    variables?: boolean
    category?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["messageTemplate"]>

  export type MessageTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    variables?: boolean
    category?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["messageTemplate"]>

  export type MessageTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    variables?: boolean
    category?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $MessageTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subject: string
      content: string
      variables: string[]
      category: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["messageTemplate"]>
    composites: {}
  }

  type MessageTemplateGetPayload<S extends boolean | null | undefined | MessageTemplateDefaultArgs> = $Result.GetResult<Prisma.$MessageTemplatePayload, S>

  type MessageTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageTemplateCountAggregateInputType | true
    }

  export interface MessageTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageTemplate'], meta: { name: 'MessageTemplate' } }
    /**
     * Find zero or one MessageTemplate that matches the filter.
     * @param {MessageTemplateFindUniqueArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageTemplateFindUniqueArgs>(args: SelectSubset<T, MessageTemplateFindUniqueArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageTemplateFindUniqueOrThrowArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindFirstArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageTemplateFindFirstArgs>(args?: SelectSubset<T, MessageTemplateFindFirstArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindFirstOrThrowArgs} args - Arguments to find a MessageTemplate
     * @example
     * // Get one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageTemplates
     * const messageTemplates = await prisma.messageTemplate.findMany()
     * 
     * // Get first 10 MessageTemplates
     * const messageTemplates = await prisma.messageTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageTemplateWithIdOnly = await prisma.messageTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageTemplateFindManyArgs>(args?: SelectSubset<T, MessageTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageTemplate.
     * @param {MessageTemplateCreateArgs} args - Arguments to create a MessageTemplate.
     * @example
     * // Create one MessageTemplate
     * const MessageTemplate = await prisma.messageTemplate.create({
     *   data: {
     *     // ... data to create a MessageTemplate
     *   }
     * })
     * 
     */
    create<T extends MessageTemplateCreateArgs>(args: SelectSubset<T, MessageTemplateCreateArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageTemplates.
     * @param {MessageTemplateCreateManyArgs} args - Arguments to create many MessageTemplates.
     * @example
     * // Create many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageTemplateCreateManyArgs>(args?: SelectSubset<T, MessageTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageTemplates and returns the data saved in the database.
     * @param {MessageTemplateCreateManyAndReturnArgs} args - Arguments to create many MessageTemplates.
     * @example
     * // Create many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageTemplates and only return the `id`
     * const messageTemplateWithIdOnly = await prisma.messageTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MessageTemplate.
     * @param {MessageTemplateDeleteArgs} args - Arguments to delete one MessageTemplate.
     * @example
     * // Delete one MessageTemplate
     * const MessageTemplate = await prisma.messageTemplate.delete({
     *   where: {
     *     // ... filter to delete one MessageTemplate
     *   }
     * })
     * 
     */
    delete<T extends MessageTemplateDeleteArgs>(args: SelectSubset<T, MessageTemplateDeleteArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageTemplate.
     * @param {MessageTemplateUpdateArgs} args - Arguments to update one MessageTemplate.
     * @example
     * // Update one MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageTemplateUpdateArgs>(args: SelectSubset<T, MessageTemplateUpdateArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageTemplates.
     * @param {MessageTemplateDeleteManyArgs} args - Arguments to filter MessageTemplates to delete.
     * @example
     * // Delete a few MessageTemplates
     * const { count } = await prisma.messageTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageTemplateDeleteManyArgs>(args?: SelectSubset<T, MessageTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageTemplates
     * const messageTemplate = await prisma.messageTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageTemplateUpdateManyArgs>(args: SelectSubset<T, MessageTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageTemplate.
     * @param {MessageTemplateUpsertArgs} args - Arguments to update or create a MessageTemplate.
     * @example
     * // Update or create a MessageTemplate
     * const messageTemplate = await prisma.messageTemplate.upsert({
     *   create: {
     *     // ... data to create a MessageTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageTemplate we want to update
     *   }
     * })
     */
    upsert<T extends MessageTemplateUpsertArgs>(args: SelectSubset<T, MessageTemplateUpsertArgs<ExtArgs>>): Prisma__MessageTemplateClient<$Result.GetResult<Prisma.$MessageTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateCountArgs} args - Arguments to filter MessageTemplates to count.
     * @example
     * // Count the number of MessageTemplates
     * const count = await prisma.messageTemplate.count({
     *   where: {
     *     // ... the filter for the MessageTemplates we want to count
     *   }
     * })
    **/
    count<T extends MessageTemplateCountArgs>(
      args?: Subset<T, MessageTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageTemplateAggregateArgs>(args: Subset<T, MessageTemplateAggregateArgs>): Prisma.PrismaPromise<GetMessageTemplateAggregateType<T>>

    /**
     * Group by MessageTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageTemplateGroupByArgs['orderBy'] }
        : { orderBy?: MessageTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageTemplate model
   */
  readonly fields: MessageTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageTemplate model
   */ 
  interface MessageTemplateFieldRefs {
    readonly id: FieldRef<"MessageTemplate", 'String'>
    readonly name: FieldRef<"MessageTemplate", 'String'>
    readonly subject: FieldRef<"MessageTemplate", 'String'>
    readonly content: FieldRef<"MessageTemplate", 'String'>
    readonly variables: FieldRef<"MessageTemplate", 'String[]'>
    readonly category: FieldRef<"MessageTemplate", 'String'>
    readonly createdBy: FieldRef<"MessageTemplate", 'String'>
    readonly createdAt: FieldRef<"MessageTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"MessageTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageTemplate findUnique
   */
  export type MessageTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate findUniqueOrThrow
   */
  export type MessageTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate findFirst
   */
  export type MessageTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageTemplates.
     */
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate findFirstOrThrow
   */
  export type MessageTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Filter, which MessageTemplate to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageTemplates.
     */
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate findMany
   */
  export type MessageTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Filter, which MessageTemplates to fetch.
     */
    where?: MessageTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageTemplates to fetch.
     */
    orderBy?: MessageTemplateOrderByWithRelationInput | MessageTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageTemplates.
     */
    cursor?: MessageTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageTemplates.
     */
    skip?: number
    distinct?: MessageTemplateScalarFieldEnum | MessageTemplateScalarFieldEnum[]
  }

  /**
   * MessageTemplate create
   */
  export type MessageTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * The data needed to create a MessageTemplate.
     */
    data: XOR<MessageTemplateCreateInput, MessageTemplateUncheckedCreateInput>
  }

  /**
   * MessageTemplate createMany
   */
  export type MessageTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageTemplates.
     */
    data: MessageTemplateCreateManyInput | MessageTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageTemplate createManyAndReturn
   */
  export type MessageTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MessageTemplates.
     */
    data: MessageTemplateCreateManyInput | MessageTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageTemplate update
   */
  export type MessageTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * The data needed to update a MessageTemplate.
     */
    data: XOR<MessageTemplateUpdateInput, MessageTemplateUncheckedUpdateInput>
    /**
     * Choose, which MessageTemplate to update.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate updateMany
   */
  export type MessageTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageTemplates.
     */
    data: XOR<MessageTemplateUpdateManyMutationInput, MessageTemplateUncheckedUpdateManyInput>
    /**
     * Filter which MessageTemplates to update
     */
    where?: MessageTemplateWhereInput
  }

  /**
   * MessageTemplate upsert
   */
  export type MessageTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * The filter to search for the MessageTemplate to update in case it exists.
     */
    where: MessageTemplateWhereUniqueInput
    /**
     * In case the MessageTemplate found by the `where` argument doesn't exist, create a new MessageTemplate with this data.
     */
    create: XOR<MessageTemplateCreateInput, MessageTemplateUncheckedCreateInput>
    /**
     * In case the MessageTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageTemplateUpdateInput, MessageTemplateUncheckedUpdateInput>
  }

  /**
   * MessageTemplate delete
   */
  export type MessageTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
    /**
     * Filter which MessageTemplate to delete.
     */
    where: MessageTemplateWhereUniqueInput
  }

  /**
   * MessageTemplate deleteMany
   */
  export type MessageTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageTemplates to delete
     */
    where?: MessageTemplateWhereInput
  }

  /**
   * MessageTemplate without action
   */
  export type MessageTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageTemplate
     */
    select?: MessageTemplateSelect<ExtArgs> | null
  }


  /**
   * Model DownloadTracking
   */

  export type AggregateDownloadTracking = {
    _count: DownloadTrackingCountAggregateOutputType | null
    _min: DownloadTrackingMinAggregateOutputType | null
    _max: DownloadTrackingMaxAggregateOutputType | null
  }

  export type DownloadTrackingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    itemId: string | null
    itemType: string | null
    downloadedAt: Date | null
  }

  export type DownloadTrackingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    itemId: string | null
    itemType: string | null
    downloadedAt: Date | null
  }

  export type DownloadTrackingCountAggregateOutputType = {
    id: number
    userId: number
    itemId: number
    itemType: number
    downloadedAt: number
    _all: number
  }


  export type DownloadTrackingMinAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    itemType?: true
    downloadedAt?: true
  }

  export type DownloadTrackingMaxAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    itemType?: true
    downloadedAt?: true
  }

  export type DownloadTrackingCountAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    itemType?: true
    downloadedAt?: true
    _all?: true
  }

  export type DownloadTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DownloadTracking to aggregate.
     */
    where?: DownloadTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DownloadTrackings to fetch.
     */
    orderBy?: DownloadTrackingOrderByWithRelationInput | DownloadTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DownloadTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DownloadTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DownloadTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DownloadTrackings
    **/
    _count?: true | DownloadTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DownloadTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DownloadTrackingMaxAggregateInputType
  }

  export type GetDownloadTrackingAggregateType<T extends DownloadTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateDownloadTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDownloadTracking[P]>
      : GetScalarType<T[P], AggregateDownloadTracking[P]>
  }




  export type DownloadTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DownloadTrackingWhereInput
    orderBy?: DownloadTrackingOrderByWithAggregationInput | DownloadTrackingOrderByWithAggregationInput[]
    by: DownloadTrackingScalarFieldEnum[] | DownloadTrackingScalarFieldEnum
    having?: DownloadTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DownloadTrackingCountAggregateInputType | true
    _min?: DownloadTrackingMinAggregateInputType
    _max?: DownloadTrackingMaxAggregateInputType
  }

  export type DownloadTrackingGroupByOutputType = {
    id: string
    userId: string
    itemId: string
    itemType: string
    downloadedAt: Date
    _count: DownloadTrackingCountAggregateOutputType | null
    _min: DownloadTrackingMinAggregateOutputType | null
    _max: DownloadTrackingMaxAggregateOutputType | null
  }

  type GetDownloadTrackingGroupByPayload<T extends DownloadTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DownloadTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DownloadTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DownloadTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], DownloadTrackingGroupByOutputType[P]>
        }
      >
    >


  export type DownloadTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemId?: boolean
    itemType?: boolean
    downloadedAt?: boolean
  }, ExtArgs["result"]["downloadTracking"]>

  export type DownloadTrackingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemId?: boolean
    itemType?: boolean
    downloadedAt?: boolean
  }, ExtArgs["result"]["downloadTracking"]>

  export type DownloadTrackingSelectScalar = {
    id?: boolean
    userId?: boolean
    itemId?: boolean
    itemType?: boolean
    downloadedAt?: boolean
  }


  export type $DownloadTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DownloadTracking"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      itemId: string
      itemType: string
      downloadedAt: Date
    }, ExtArgs["result"]["downloadTracking"]>
    composites: {}
  }

  type DownloadTrackingGetPayload<S extends boolean | null | undefined | DownloadTrackingDefaultArgs> = $Result.GetResult<Prisma.$DownloadTrackingPayload, S>

  type DownloadTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DownloadTrackingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DownloadTrackingCountAggregateInputType | true
    }

  export interface DownloadTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DownloadTracking'], meta: { name: 'DownloadTracking' } }
    /**
     * Find zero or one DownloadTracking that matches the filter.
     * @param {DownloadTrackingFindUniqueArgs} args - Arguments to find a DownloadTracking
     * @example
     * // Get one DownloadTracking
     * const downloadTracking = await prisma.downloadTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DownloadTrackingFindUniqueArgs>(args: SelectSubset<T, DownloadTrackingFindUniqueArgs<ExtArgs>>): Prisma__DownloadTrackingClient<$Result.GetResult<Prisma.$DownloadTrackingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DownloadTracking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DownloadTrackingFindUniqueOrThrowArgs} args - Arguments to find a DownloadTracking
     * @example
     * // Get one DownloadTracking
     * const downloadTracking = await prisma.downloadTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DownloadTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, DownloadTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DownloadTrackingClient<$Result.GetResult<Prisma.$DownloadTrackingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DownloadTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadTrackingFindFirstArgs} args - Arguments to find a DownloadTracking
     * @example
     * // Get one DownloadTracking
     * const downloadTracking = await prisma.downloadTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DownloadTrackingFindFirstArgs>(args?: SelectSubset<T, DownloadTrackingFindFirstArgs<ExtArgs>>): Prisma__DownloadTrackingClient<$Result.GetResult<Prisma.$DownloadTrackingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DownloadTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadTrackingFindFirstOrThrowArgs} args - Arguments to find a DownloadTracking
     * @example
     * // Get one DownloadTracking
     * const downloadTracking = await prisma.downloadTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DownloadTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, DownloadTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__DownloadTrackingClient<$Result.GetResult<Prisma.$DownloadTrackingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DownloadTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DownloadTrackings
     * const downloadTrackings = await prisma.downloadTracking.findMany()
     * 
     * // Get first 10 DownloadTrackings
     * const downloadTrackings = await prisma.downloadTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const downloadTrackingWithIdOnly = await prisma.downloadTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DownloadTrackingFindManyArgs>(args?: SelectSubset<T, DownloadTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DownloadTrackingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DownloadTracking.
     * @param {DownloadTrackingCreateArgs} args - Arguments to create a DownloadTracking.
     * @example
     * // Create one DownloadTracking
     * const DownloadTracking = await prisma.downloadTracking.create({
     *   data: {
     *     // ... data to create a DownloadTracking
     *   }
     * })
     * 
     */
    create<T extends DownloadTrackingCreateArgs>(args: SelectSubset<T, DownloadTrackingCreateArgs<ExtArgs>>): Prisma__DownloadTrackingClient<$Result.GetResult<Prisma.$DownloadTrackingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DownloadTrackings.
     * @param {DownloadTrackingCreateManyArgs} args - Arguments to create many DownloadTrackings.
     * @example
     * // Create many DownloadTrackings
     * const downloadTracking = await prisma.downloadTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DownloadTrackingCreateManyArgs>(args?: SelectSubset<T, DownloadTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DownloadTrackings and returns the data saved in the database.
     * @param {DownloadTrackingCreateManyAndReturnArgs} args - Arguments to create many DownloadTrackings.
     * @example
     * // Create many DownloadTrackings
     * const downloadTracking = await prisma.downloadTracking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DownloadTrackings and only return the `id`
     * const downloadTrackingWithIdOnly = await prisma.downloadTracking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DownloadTrackingCreateManyAndReturnArgs>(args?: SelectSubset<T, DownloadTrackingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DownloadTrackingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DownloadTracking.
     * @param {DownloadTrackingDeleteArgs} args - Arguments to delete one DownloadTracking.
     * @example
     * // Delete one DownloadTracking
     * const DownloadTracking = await prisma.downloadTracking.delete({
     *   where: {
     *     // ... filter to delete one DownloadTracking
     *   }
     * })
     * 
     */
    delete<T extends DownloadTrackingDeleteArgs>(args: SelectSubset<T, DownloadTrackingDeleteArgs<ExtArgs>>): Prisma__DownloadTrackingClient<$Result.GetResult<Prisma.$DownloadTrackingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DownloadTracking.
     * @param {DownloadTrackingUpdateArgs} args - Arguments to update one DownloadTracking.
     * @example
     * // Update one DownloadTracking
     * const downloadTracking = await prisma.downloadTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DownloadTrackingUpdateArgs>(args: SelectSubset<T, DownloadTrackingUpdateArgs<ExtArgs>>): Prisma__DownloadTrackingClient<$Result.GetResult<Prisma.$DownloadTrackingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DownloadTrackings.
     * @param {DownloadTrackingDeleteManyArgs} args - Arguments to filter DownloadTrackings to delete.
     * @example
     * // Delete a few DownloadTrackings
     * const { count } = await prisma.downloadTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DownloadTrackingDeleteManyArgs>(args?: SelectSubset<T, DownloadTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DownloadTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DownloadTrackings
     * const downloadTracking = await prisma.downloadTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DownloadTrackingUpdateManyArgs>(args: SelectSubset<T, DownloadTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DownloadTracking.
     * @param {DownloadTrackingUpsertArgs} args - Arguments to update or create a DownloadTracking.
     * @example
     * // Update or create a DownloadTracking
     * const downloadTracking = await prisma.downloadTracking.upsert({
     *   create: {
     *     // ... data to create a DownloadTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DownloadTracking we want to update
     *   }
     * })
     */
    upsert<T extends DownloadTrackingUpsertArgs>(args: SelectSubset<T, DownloadTrackingUpsertArgs<ExtArgs>>): Prisma__DownloadTrackingClient<$Result.GetResult<Prisma.$DownloadTrackingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DownloadTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadTrackingCountArgs} args - Arguments to filter DownloadTrackings to count.
     * @example
     * // Count the number of DownloadTrackings
     * const count = await prisma.downloadTracking.count({
     *   where: {
     *     // ... the filter for the DownloadTrackings we want to count
     *   }
     * })
    **/
    count<T extends DownloadTrackingCountArgs>(
      args?: Subset<T, DownloadTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DownloadTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DownloadTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DownloadTrackingAggregateArgs>(args: Subset<T, DownloadTrackingAggregateArgs>): Prisma.PrismaPromise<GetDownloadTrackingAggregateType<T>>

    /**
     * Group by DownloadTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DownloadTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DownloadTrackingGroupByArgs['orderBy'] }
        : { orderBy?: DownloadTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DownloadTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDownloadTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DownloadTracking model
   */
  readonly fields: DownloadTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DownloadTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DownloadTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DownloadTracking model
   */ 
  interface DownloadTrackingFieldRefs {
    readonly id: FieldRef<"DownloadTracking", 'String'>
    readonly userId: FieldRef<"DownloadTracking", 'String'>
    readonly itemId: FieldRef<"DownloadTracking", 'String'>
    readonly itemType: FieldRef<"DownloadTracking", 'String'>
    readonly downloadedAt: FieldRef<"DownloadTracking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DownloadTracking findUnique
   */
  export type DownloadTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTracking
     */
    select?: DownloadTrackingSelect<ExtArgs> | null
    /**
     * Filter, which DownloadTracking to fetch.
     */
    where: DownloadTrackingWhereUniqueInput
  }

  /**
   * DownloadTracking findUniqueOrThrow
   */
  export type DownloadTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTracking
     */
    select?: DownloadTrackingSelect<ExtArgs> | null
    /**
     * Filter, which DownloadTracking to fetch.
     */
    where: DownloadTrackingWhereUniqueInput
  }

  /**
   * DownloadTracking findFirst
   */
  export type DownloadTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTracking
     */
    select?: DownloadTrackingSelect<ExtArgs> | null
    /**
     * Filter, which DownloadTracking to fetch.
     */
    where?: DownloadTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DownloadTrackings to fetch.
     */
    orderBy?: DownloadTrackingOrderByWithRelationInput | DownloadTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DownloadTrackings.
     */
    cursor?: DownloadTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DownloadTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DownloadTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DownloadTrackings.
     */
    distinct?: DownloadTrackingScalarFieldEnum | DownloadTrackingScalarFieldEnum[]
  }

  /**
   * DownloadTracking findFirstOrThrow
   */
  export type DownloadTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTracking
     */
    select?: DownloadTrackingSelect<ExtArgs> | null
    /**
     * Filter, which DownloadTracking to fetch.
     */
    where?: DownloadTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DownloadTrackings to fetch.
     */
    orderBy?: DownloadTrackingOrderByWithRelationInput | DownloadTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DownloadTrackings.
     */
    cursor?: DownloadTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DownloadTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DownloadTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DownloadTrackings.
     */
    distinct?: DownloadTrackingScalarFieldEnum | DownloadTrackingScalarFieldEnum[]
  }

  /**
   * DownloadTracking findMany
   */
  export type DownloadTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTracking
     */
    select?: DownloadTrackingSelect<ExtArgs> | null
    /**
     * Filter, which DownloadTrackings to fetch.
     */
    where?: DownloadTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DownloadTrackings to fetch.
     */
    orderBy?: DownloadTrackingOrderByWithRelationInput | DownloadTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DownloadTrackings.
     */
    cursor?: DownloadTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DownloadTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DownloadTrackings.
     */
    skip?: number
    distinct?: DownloadTrackingScalarFieldEnum | DownloadTrackingScalarFieldEnum[]
  }

  /**
   * DownloadTracking create
   */
  export type DownloadTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTracking
     */
    select?: DownloadTrackingSelect<ExtArgs> | null
    /**
     * The data needed to create a DownloadTracking.
     */
    data: XOR<DownloadTrackingCreateInput, DownloadTrackingUncheckedCreateInput>
  }

  /**
   * DownloadTracking createMany
   */
  export type DownloadTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DownloadTrackings.
     */
    data: DownloadTrackingCreateManyInput | DownloadTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DownloadTracking createManyAndReturn
   */
  export type DownloadTrackingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTracking
     */
    select?: DownloadTrackingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DownloadTrackings.
     */
    data: DownloadTrackingCreateManyInput | DownloadTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DownloadTracking update
   */
  export type DownloadTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTracking
     */
    select?: DownloadTrackingSelect<ExtArgs> | null
    /**
     * The data needed to update a DownloadTracking.
     */
    data: XOR<DownloadTrackingUpdateInput, DownloadTrackingUncheckedUpdateInput>
    /**
     * Choose, which DownloadTracking to update.
     */
    where: DownloadTrackingWhereUniqueInput
  }

  /**
   * DownloadTracking updateMany
   */
  export type DownloadTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DownloadTrackings.
     */
    data: XOR<DownloadTrackingUpdateManyMutationInput, DownloadTrackingUncheckedUpdateManyInput>
    /**
     * Filter which DownloadTrackings to update
     */
    where?: DownloadTrackingWhereInput
  }

  /**
   * DownloadTracking upsert
   */
  export type DownloadTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTracking
     */
    select?: DownloadTrackingSelect<ExtArgs> | null
    /**
     * The filter to search for the DownloadTracking to update in case it exists.
     */
    where: DownloadTrackingWhereUniqueInput
    /**
     * In case the DownloadTracking found by the `where` argument doesn't exist, create a new DownloadTracking with this data.
     */
    create: XOR<DownloadTrackingCreateInput, DownloadTrackingUncheckedCreateInput>
    /**
     * In case the DownloadTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DownloadTrackingUpdateInput, DownloadTrackingUncheckedUpdateInput>
  }

  /**
   * DownloadTracking delete
   */
  export type DownloadTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTracking
     */
    select?: DownloadTrackingSelect<ExtArgs> | null
    /**
     * Filter which DownloadTracking to delete.
     */
    where: DownloadTrackingWhereUniqueInput
  }

  /**
   * DownloadTracking deleteMany
   */
  export type DownloadTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DownloadTrackings to delete
     */
    where?: DownloadTrackingWhereInput
  }

  /**
   * DownloadTracking without action
   */
  export type DownloadTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTracking
     */
    select?: DownloadTrackingSelect<ExtArgs> | null
  }


  /**
   * Model CustomPaper
   */

  export type AggregateCustomPaper = {
    _count: CustomPaperCountAggregateOutputType | null
    _avg: CustomPaperAvgAggregateOutputType | null
    _sum: CustomPaperSumAggregateOutputType | null
    _min: CustomPaperMinAggregateOutputType | null
    _max: CustomPaperMaxAggregateOutputType | null
  }

  export type CustomPaperAvgAggregateOutputType = {
    pageCount: number | null
    quotedPrice: number | null
    finalPrice: number | null
  }

  export type CustomPaperSumAggregateOutputType = {
    pageCount: number | null
    quotedPrice: number | null
    finalPrice: number | null
  }

  export type CustomPaperMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    paperType: $Enums.PaperType | null
    academicArea: $Enums.AcademicArea | null
    pageCount: number | null
    deadline: Date | null
    urgency: $Enums.CustomPaperUrgency | null
    requirements: string | null
    keywords: string | null
    references: string | null
    quotedPrice: number | null
    finalPrice: number | null
    paymentStatus: $Enums.PaymentStatus | null
    status: $Enums.CustomPaperStatus | null
    adminNotes: string | null
    rejectionReason: string | null
    requestedAt: Date | null
    quotedAt: Date | null
    approvedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    orderId: string | null
  }

  export type CustomPaperMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    paperType: $Enums.PaperType | null
    academicArea: $Enums.AcademicArea | null
    pageCount: number | null
    deadline: Date | null
    urgency: $Enums.CustomPaperUrgency | null
    requirements: string | null
    keywords: string | null
    references: string | null
    quotedPrice: number | null
    finalPrice: number | null
    paymentStatus: $Enums.PaymentStatus | null
    status: $Enums.CustomPaperStatus | null
    adminNotes: string | null
    rejectionReason: string | null
    requestedAt: Date | null
    quotedAt: Date | null
    approvedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    orderId: string | null
  }

  export type CustomPaperCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    paperType: number
    academicArea: number
    pageCount: number
    deadline: number
    urgency: number
    requirements: number
    keywords: number
    references: number
    requirementFiles: number
    deliveryFiles: number
    quotedPrice: number
    finalPrice: number
    paymentStatus: number
    status: number
    adminNotes: number
    rejectionReason: number
    requestedAt: number
    quotedAt: number
    approvedAt: number
    startedAt: number
    completedAt: number
    orderId: number
    _all: number
  }


  export type CustomPaperAvgAggregateInputType = {
    pageCount?: true
    quotedPrice?: true
    finalPrice?: true
  }

  export type CustomPaperSumAggregateInputType = {
    pageCount?: true
    quotedPrice?: true
    finalPrice?: true
  }

  export type CustomPaperMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    paperType?: true
    academicArea?: true
    pageCount?: true
    deadline?: true
    urgency?: true
    requirements?: true
    keywords?: true
    references?: true
    quotedPrice?: true
    finalPrice?: true
    paymentStatus?: true
    status?: true
    adminNotes?: true
    rejectionReason?: true
    requestedAt?: true
    quotedAt?: true
    approvedAt?: true
    startedAt?: true
    completedAt?: true
    orderId?: true
  }

  export type CustomPaperMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    paperType?: true
    academicArea?: true
    pageCount?: true
    deadline?: true
    urgency?: true
    requirements?: true
    keywords?: true
    references?: true
    quotedPrice?: true
    finalPrice?: true
    paymentStatus?: true
    status?: true
    adminNotes?: true
    rejectionReason?: true
    requestedAt?: true
    quotedAt?: true
    approvedAt?: true
    startedAt?: true
    completedAt?: true
    orderId?: true
  }

  export type CustomPaperCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    paperType?: true
    academicArea?: true
    pageCount?: true
    deadline?: true
    urgency?: true
    requirements?: true
    keywords?: true
    references?: true
    requirementFiles?: true
    deliveryFiles?: true
    quotedPrice?: true
    finalPrice?: true
    paymentStatus?: true
    status?: true
    adminNotes?: true
    rejectionReason?: true
    requestedAt?: true
    quotedAt?: true
    approvedAt?: true
    startedAt?: true
    completedAt?: true
    orderId?: true
    _all?: true
  }

  export type CustomPaperAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomPaper to aggregate.
     */
    where?: CustomPaperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomPapers to fetch.
     */
    orderBy?: CustomPaperOrderByWithRelationInput | CustomPaperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomPaperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomPapers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomPapers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomPapers
    **/
    _count?: true | CustomPaperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomPaperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomPaperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomPaperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomPaperMaxAggregateInputType
  }

  export type GetCustomPaperAggregateType<T extends CustomPaperAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomPaper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomPaper[P]>
      : GetScalarType<T[P], AggregateCustomPaper[P]>
  }




  export type CustomPaperGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomPaperWhereInput
    orderBy?: CustomPaperOrderByWithAggregationInput | CustomPaperOrderByWithAggregationInput[]
    by: CustomPaperScalarFieldEnum[] | CustomPaperScalarFieldEnum
    having?: CustomPaperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomPaperCountAggregateInputType | true
    _avg?: CustomPaperAvgAggregateInputType
    _sum?: CustomPaperSumAggregateInputType
    _min?: CustomPaperMinAggregateInputType
    _max?: CustomPaperMaxAggregateInputType
  }

  export type CustomPaperGroupByOutputType = {
    id: string
    userId: string | null
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    pageCount: number
    deadline: Date
    urgency: $Enums.CustomPaperUrgency
    requirements: string
    keywords: string | null
    references: string | null
    requirementFiles: string[]
    deliveryFiles: string[]
    quotedPrice: number | null
    finalPrice: number | null
    paymentStatus: $Enums.PaymentStatus
    status: $Enums.CustomPaperStatus
    adminNotes: string | null
    rejectionReason: string | null
    requestedAt: Date
    quotedAt: Date | null
    approvedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    orderId: string | null
    _count: CustomPaperCountAggregateOutputType | null
    _avg: CustomPaperAvgAggregateOutputType | null
    _sum: CustomPaperSumAggregateOutputType | null
    _min: CustomPaperMinAggregateOutputType | null
    _max: CustomPaperMaxAggregateOutputType | null
  }

  type GetCustomPaperGroupByPayload<T extends CustomPaperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomPaperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomPaperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomPaperGroupByOutputType[P]>
            : GetScalarType<T[P], CustomPaperGroupByOutputType[P]>
        }
      >
    >


  export type CustomPaperSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    paperType?: boolean
    academicArea?: boolean
    pageCount?: boolean
    deadline?: boolean
    urgency?: boolean
    requirements?: boolean
    keywords?: boolean
    references?: boolean
    requirementFiles?: boolean
    deliveryFiles?: boolean
    quotedPrice?: boolean
    finalPrice?: boolean
    paymentStatus?: boolean
    status?: boolean
    adminNotes?: boolean
    rejectionReason?: boolean
    requestedAt?: boolean
    quotedAt?: boolean
    approvedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    orderId?: boolean
    user?: boolean | CustomPaper$userArgs<ExtArgs>
    messages?: boolean | CustomPaper$messagesArgs<ExtArgs>
    order?: boolean | CustomPaper$orderArgs<ExtArgs>
    _count?: boolean | CustomPaperCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customPaper"]>

  export type CustomPaperSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    paperType?: boolean
    academicArea?: boolean
    pageCount?: boolean
    deadline?: boolean
    urgency?: boolean
    requirements?: boolean
    keywords?: boolean
    references?: boolean
    requirementFiles?: boolean
    deliveryFiles?: boolean
    quotedPrice?: boolean
    finalPrice?: boolean
    paymentStatus?: boolean
    status?: boolean
    adminNotes?: boolean
    rejectionReason?: boolean
    requestedAt?: boolean
    quotedAt?: boolean
    approvedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    orderId?: boolean
    user?: boolean | CustomPaper$userArgs<ExtArgs>
    order?: boolean | CustomPaper$orderArgs<ExtArgs>
  }, ExtArgs["result"]["customPaper"]>

  export type CustomPaperSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    paperType?: boolean
    academicArea?: boolean
    pageCount?: boolean
    deadline?: boolean
    urgency?: boolean
    requirements?: boolean
    keywords?: boolean
    references?: boolean
    requirementFiles?: boolean
    deliveryFiles?: boolean
    quotedPrice?: boolean
    finalPrice?: boolean
    paymentStatus?: boolean
    status?: boolean
    adminNotes?: boolean
    rejectionReason?: boolean
    requestedAt?: boolean
    quotedAt?: boolean
    approvedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    orderId?: boolean
  }

  export type CustomPaperInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | CustomPaper$userArgs<ExtArgs>
    messages?: boolean | CustomPaper$messagesArgs<ExtArgs>
    order?: boolean | CustomPaper$orderArgs<ExtArgs>
    _count?: boolean | CustomPaperCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomPaperIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | CustomPaper$userArgs<ExtArgs>
    order?: boolean | CustomPaper$orderArgs<ExtArgs>
  }

  export type $CustomPaperPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomPaper"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      messages: Prisma.$CustomPaperMessagePayload<ExtArgs>[]
      order: Prisma.$OrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      title: string
      description: string
      paperType: $Enums.PaperType
      academicArea: $Enums.AcademicArea
      pageCount: number
      deadline: Date
      urgency: $Enums.CustomPaperUrgency
      requirements: string
      keywords: string | null
      references: string | null
      requirementFiles: string[]
      deliveryFiles: string[]
      quotedPrice: number | null
      finalPrice: number | null
      paymentStatus: $Enums.PaymentStatus
      status: $Enums.CustomPaperStatus
      adminNotes: string | null
      rejectionReason: string | null
      requestedAt: Date
      quotedAt: Date | null
      approvedAt: Date | null
      startedAt: Date | null
      completedAt: Date | null
      orderId: string | null
    }, ExtArgs["result"]["customPaper"]>
    composites: {}
  }

  type CustomPaperGetPayload<S extends boolean | null | undefined | CustomPaperDefaultArgs> = $Result.GetResult<Prisma.$CustomPaperPayload, S>

  type CustomPaperCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomPaperFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomPaperCountAggregateInputType | true
    }

  export interface CustomPaperDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomPaper'], meta: { name: 'CustomPaper' } }
    /**
     * Find zero or one CustomPaper that matches the filter.
     * @param {CustomPaperFindUniqueArgs} args - Arguments to find a CustomPaper
     * @example
     * // Get one CustomPaper
     * const customPaper = await prisma.customPaper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomPaperFindUniqueArgs>(args: SelectSubset<T, CustomPaperFindUniqueArgs<ExtArgs>>): Prisma__CustomPaperClient<$Result.GetResult<Prisma.$CustomPaperPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomPaper that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomPaperFindUniqueOrThrowArgs} args - Arguments to find a CustomPaper
     * @example
     * // Get one CustomPaper
     * const customPaper = await prisma.customPaper.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomPaperFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomPaperFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomPaperClient<$Result.GetResult<Prisma.$CustomPaperPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomPaper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPaperFindFirstArgs} args - Arguments to find a CustomPaper
     * @example
     * // Get one CustomPaper
     * const customPaper = await prisma.customPaper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomPaperFindFirstArgs>(args?: SelectSubset<T, CustomPaperFindFirstArgs<ExtArgs>>): Prisma__CustomPaperClient<$Result.GetResult<Prisma.$CustomPaperPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomPaper that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPaperFindFirstOrThrowArgs} args - Arguments to find a CustomPaper
     * @example
     * // Get one CustomPaper
     * const customPaper = await prisma.customPaper.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomPaperFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomPaperFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomPaperClient<$Result.GetResult<Prisma.$CustomPaperPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomPapers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPaperFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomPapers
     * const customPapers = await prisma.customPaper.findMany()
     * 
     * // Get first 10 CustomPapers
     * const customPapers = await prisma.customPaper.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customPaperWithIdOnly = await prisma.customPaper.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomPaperFindManyArgs>(args?: SelectSubset<T, CustomPaperFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomPaperPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomPaper.
     * @param {CustomPaperCreateArgs} args - Arguments to create a CustomPaper.
     * @example
     * // Create one CustomPaper
     * const CustomPaper = await prisma.customPaper.create({
     *   data: {
     *     // ... data to create a CustomPaper
     *   }
     * })
     * 
     */
    create<T extends CustomPaperCreateArgs>(args: SelectSubset<T, CustomPaperCreateArgs<ExtArgs>>): Prisma__CustomPaperClient<$Result.GetResult<Prisma.$CustomPaperPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomPapers.
     * @param {CustomPaperCreateManyArgs} args - Arguments to create many CustomPapers.
     * @example
     * // Create many CustomPapers
     * const customPaper = await prisma.customPaper.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomPaperCreateManyArgs>(args?: SelectSubset<T, CustomPaperCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomPapers and returns the data saved in the database.
     * @param {CustomPaperCreateManyAndReturnArgs} args - Arguments to create many CustomPapers.
     * @example
     * // Create many CustomPapers
     * const customPaper = await prisma.customPaper.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomPapers and only return the `id`
     * const customPaperWithIdOnly = await prisma.customPaper.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomPaperCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomPaperCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomPaperPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomPaper.
     * @param {CustomPaperDeleteArgs} args - Arguments to delete one CustomPaper.
     * @example
     * // Delete one CustomPaper
     * const CustomPaper = await prisma.customPaper.delete({
     *   where: {
     *     // ... filter to delete one CustomPaper
     *   }
     * })
     * 
     */
    delete<T extends CustomPaperDeleteArgs>(args: SelectSubset<T, CustomPaperDeleteArgs<ExtArgs>>): Prisma__CustomPaperClient<$Result.GetResult<Prisma.$CustomPaperPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomPaper.
     * @param {CustomPaperUpdateArgs} args - Arguments to update one CustomPaper.
     * @example
     * // Update one CustomPaper
     * const customPaper = await prisma.customPaper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomPaperUpdateArgs>(args: SelectSubset<T, CustomPaperUpdateArgs<ExtArgs>>): Prisma__CustomPaperClient<$Result.GetResult<Prisma.$CustomPaperPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomPapers.
     * @param {CustomPaperDeleteManyArgs} args - Arguments to filter CustomPapers to delete.
     * @example
     * // Delete a few CustomPapers
     * const { count } = await prisma.customPaper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomPaperDeleteManyArgs>(args?: SelectSubset<T, CustomPaperDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomPapers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPaperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomPapers
     * const customPaper = await prisma.customPaper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomPaperUpdateManyArgs>(args: SelectSubset<T, CustomPaperUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomPaper.
     * @param {CustomPaperUpsertArgs} args - Arguments to update or create a CustomPaper.
     * @example
     * // Update or create a CustomPaper
     * const customPaper = await prisma.customPaper.upsert({
     *   create: {
     *     // ... data to create a CustomPaper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomPaper we want to update
     *   }
     * })
     */
    upsert<T extends CustomPaperUpsertArgs>(args: SelectSubset<T, CustomPaperUpsertArgs<ExtArgs>>): Prisma__CustomPaperClient<$Result.GetResult<Prisma.$CustomPaperPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomPapers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPaperCountArgs} args - Arguments to filter CustomPapers to count.
     * @example
     * // Count the number of CustomPapers
     * const count = await prisma.customPaper.count({
     *   where: {
     *     // ... the filter for the CustomPapers we want to count
     *   }
     * })
    **/
    count<T extends CustomPaperCountArgs>(
      args?: Subset<T, CustomPaperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomPaperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomPaper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPaperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomPaperAggregateArgs>(args: Subset<T, CustomPaperAggregateArgs>): Prisma.PrismaPromise<GetCustomPaperAggregateType<T>>

    /**
     * Group by CustomPaper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPaperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomPaperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomPaperGroupByArgs['orderBy'] }
        : { orderBy?: CustomPaperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomPaperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomPaperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomPaper model
   */
  readonly fields: CustomPaperFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomPaper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomPaperClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends CustomPaper$userArgs<ExtArgs> = {}>(args?: Subset<T, CustomPaper$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    messages<T extends CustomPaper$messagesArgs<ExtArgs> = {}>(args?: Subset<T, CustomPaper$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomPaperMessagePayload<ExtArgs>, T, "findMany"> | Null>
    order<T extends CustomPaper$orderArgs<ExtArgs> = {}>(args?: Subset<T, CustomPaper$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomPaper model
   */ 
  interface CustomPaperFieldRefs {
    readonly id: FieldRef<"CustomPaper", 'String'>
    readonly userId: FieldRef<"CustomPaper", 'String'>
    readonly title: FieldRef<"CustomPaper", 'String'>
    readonly description: FieldRef<"CustomPaper", 'String'>
    readonly paperType: FieldRef<"CustomPaper", 'PaperType'>
    readonly academicArea: FieldRef<"CustomPaper", 'AcademicArea'>
    readonly pageCount: FieldRef<"CustomPaper", 'Int'>
    readonly deadline: FieldRef<"CustomPaper", 'DateTime'>
    readonly urgency: FieldRef<"CustomPaper", 'CustomPaperUrgency'>
    readonly requirements: FieldRef<"CustomPaper", 'String'>
    readonly keywords: FieldRef<"CustomPaper", 'String'>
    readonly references: FieldRef<"CustomPaper", 'String'>
    readonly requirementFiles: FieldRef<"CustomPaper", 'String[]'>
    readonly deliveryFiles: FieldRef<"CustomPaper", 'String[]'>
    readonly quotedPrice: FieldRef<"CustomPaper", 'Int'>
    readonly finalPrice: FieldRef<"CustomPaper", 'Int'>
    readonly paymentStatus: FieldRef<"CustomPaper", 'PaymentStatus'>
    readonly status: FieldRef<"CustomPaper", 'CustomPaperStatus'>
    readonly adminNotes: FieldRef<"CustomPaper", 'String'>
    readonly rejectionReason: FieldRef<"CustomPaper", 'String'>
    readonly requestedAt: FieldRef<"CustomPaper", 'DateTime'>
    readonly quotedAt: FieldRef<"CustomPaper", 'DateTime'>
    readonly approvedAt: FieldRef<"CustomPaper", 'DateTime'>
    readonly startedAt: FieldRef<"CustomPaper", 'DateTime'>
    readonly completedAt: FieldRef<"CustomPaper", 'DateTime'>
    readonly orderId: FieldRef<"CustomPaper", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CustomPaper findUnique
   */
  export type CustomPaperFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaper
     */
    select?: CustomPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperInclude<ExtArgs> | null
    /**
     * Filter, which CustomPaper to fetch.
     */
    where: CustomPaperWhereUniqueInput
  }

  /**
   * CustomPaper findUniqueOrThrow
   */
  export type CustomPaperFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaper
     */
    select?: CustomPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperInclude<ExtArgs> | null
    /**
     * Filter, which CustomPaper to fetch.
     */
    where: CustomPaperWhereUniqueInput
  }

  /**
   * CustomPaper findFirst
   */
  export type CustomPaperFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaper
     */
    select?: CustomPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperInclude<ExtArgs> | null
    /**
     * Filter, which CustomPaper to fetch.
     */
    where?: CustomPaperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomPapers to fetch.
     */
    orderBy?: CustomPaperOrderByWithRelationInput | CustomPaperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomPapers.
     */
    cursor?: CustomPaperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomPapers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomPapers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomPapers.
     */
    distinct?: CustomPaperScalarFieldEnum | CustomPaperScalarFieldEnum[]
  }

  /**
   * CustomPaper findFirstOrThrow
   */
  export type CustomPaperFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaper
     */
    select?: CustomPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperInclude<ExtArgs> | null
    /**
     * Filter, which CustomPaper to fetch.
     */
    where?: CustomPaperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomPapers to fetch.
     */
    orderBy?: CustomPaperOrderByWithRelationInput | CustomPaperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomPapers.
     */
    cursor?: CustomPaperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomPapers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomPapers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomPapers.
     */
    distinct?: CustomPaperScalarFieldEnum | CustomPaperScalarFieldEnum[]
  }

  /**
   * CustomPaper findMany
   */
  export type CustomPaperFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaper
     */
    select?: CustomPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperInclude<ExtArgs> | null
    /**
     * Filter, which CustomPapers to fetch.
     */
    where?: CustomPaperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomPapers to fetch.
     */
    orderBy?: CustomPaperOrderByWithRelationInput | CustomPaperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomPapers.
     */
    cursor?: CustomPaperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomPapers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomPapers.
     */
    skip?: number
    distinct?: CustomPaperScalarFieldEnum | CustomPaperScalarFieldEnum[]
  }

  /**
   * CustomPaper create
   */
  export type CustomPaperCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaper
     */
    select?: CustomPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomPaper.
     */
    data: XOR<CustomPaperCreateInput, CustomPaperUncheckedCreateInput>
  }

  /**
   * CustomPaper createMany
   */
  export type CustomPaperCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomPapers.
     */
    data: CustomPaperCreateManyInput | CustomPaperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomPaper createManyAndReturn
   */
  export type CustomPaperCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaper
     */
    select?: CustomPaperSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomPapers.
     */
    data: CustomPaperCreateManyInput | CustomPaperCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomPaper update
   */
  export type CustomPaperUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaper
     */
    select?: CustomPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomPaper.
     */
    data: XOR<CustomPaperUpdateInput, CustomPaperUncheckedUpdateInput>
    /**
     * Choose, which CustomPaper to update.
     */
    where: CustomPaperWhereUniqueInput
  }

  /**
   * CustomPaper updateMany
   */
  export type CustomPaperUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomPapers.
     */
    data: XOR<CustomPaperUpdateManyMutationInput, CustomPaperUncheckedUpdateManyInput>
    /**
     * Filter which CustomPapers to update
     */
    where?: CustomPaperWhereInput
  }

  /**
   * CustomPaper upsert
   */
  export type CustomPaperUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaper
     */
    select?: CustomPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomPaper to update in case it exists.
     */
    where: CustomPaperWhereUniqueInput
    /**
     * In case the CustomPaper found by the `where` argument doesn't exist, create a new CustomPaper with this data.
     */
    create: XOR<CustomPaperCreateInput, CustomPaperUncheckedCreateInput>
    /**
     * In case the CustomPaper was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomPaperUpdateInput, CustomPaperUncheckedUpdateInput>
  }

  /**
   * CustomPaper delete
   */
  export type CustomPaperDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaper
     */
    select?: CustomPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperInclude<ExtArgs> | null
    /**
     * Filter which CustomPaper to delete.
     */
    where: CustomPaperWhereUniqueInput
  }

  /**
   * CustomPaper deleteMany
   */
  export type CustomPaperDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomPapers to delete
     */
    where?: CustomPaperWhereInput
  }

  /**
   * CustomPaper.user
   */
  export type CustomPaper$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CustomPaper.messages
   */
  export type CustomPaper$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaperMessage
     */
    select?: CustomPaperMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperMessageInclude<ExtArgs> | null
    where?: CustomPaperMessageWhereInput
    orderBy?: CustomPaperMessageOrderByWithRelationInput | CustomPaperMessageOrderByWithRelationInput[]
    cursor?: CustomPaperMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomPaperMessageScalarFieldEnum | CustomPaperMessageScalarFieldEnum[]
  }

  /**
   * CustomPaper.order
   */
  export type CustomPaper$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * CustomPaper without action
   */
  export type CustomPaperDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaper
     */
    select?: CustomPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperInclude<ExtArgs> | null
  }


  /**
   * Model CustomPaperMessage
   */

  export type AggregateCustomPaperMessage = {
    _count: CustomPaperMessageCountAggregateOutputType | null
    _min: CustomPaperMessageMinAggregateOutputType | null
    _max: CustomPaperMessageMaxAggregateOutputType | null
  }

  export type CustomPaperMessageMinAggregateOutputType = {
    id: string | null
    customPaperId: string | null
    senderId: string | null
    content: string | null
    isFromAdmin: boolean | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type CustomPaperMessageMaxAggregateOutputType = {
    id: string | null
    customPaperId: string | null
    senderId: string | null
    content: string | null
    isFromAdmin: boolean | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type CustomPaperMessageCountAggregateOutputType = {
    id: number
    customPaperId: number
    senderId: number
    content: number
    attachments: number
    isFromAdmin: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type CustomPaperMessageMinAggregateInputType = {
    id?: true
    customPaperId?: true
    senderId?: true
    content?: true
    isFromAdmin?: true
    isRead?: true
    createdAt?: true
  }

  export type CustomPaperMessageMaxAggregateInputType = {
    id?: true
    customPaperId?: true
    senderId?: true
    content?: true
    isFromAdmin?: true
    isRead?: true
    createdAt?: true
  }

  export type CustomPaperMessageCountAggregateInputType = {
    id?: true
    customPaperId?: true
    senderId?: true
    content?: true
    attachments?: true
    isFromAdmin?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type CustomPaperMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomPaperMessage to aggregate.
     */
    where?: CustomPaperMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomPaperMessages to fetch.
     */
    orderBy?: CustomPaperMessageOrderByWithRelationInput | CustomPaperMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomPaperMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomPaperMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomPaperMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomPaperMessages
    **/
    _count?: true | CustomPaperMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomPaperMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomPaperMessageMaxAggregateInputType
  }

  export type GetCustomPaperMessageAggregateType<T extends CustomPaperMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomPaperMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomPaperMessage[P]>
      : GetScalarType<T[P], AggregateCustomPaperMessage[P]>
  }




  export type CustomPaperMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomPaperMessageWhereInput
    orderBy?: CustomPaperMessageOrderByWithAggregationInput | CustomPaperMessageOrderByWithAggregationInput[]
    by: CustomPaperMessageScalarFieldEnum[] | CustomPaperMessageScalarFieldEnum
    having?: CustomPaperMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomPaperMessageCountAggregateInputType | true
    _min?: CustomPaperMessageMinAggregateInputType
    _max?: CustomPaperMessageMaxAggregateInputType
  }

  export type CustomPaperMessageGroupByOutputType = {
    id: string
    customPaperId: string
    senderId: string
    content: string
    attachments: string[]
    isFromAdmin: boolean
    isRead: boolean
    createdAt: Date
    _count: CustomPaperMessageCountAggregateOutputType | null
    _min: CustomPaperMessageMinAggregateOutputType | null
    _max: CustomPaperMessageMaxAggregateOutputType | null
  }

  type GetCustomPaperMessageGroupByPayload<T extends CustomPaperMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomPaperMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomPaperMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomPaperMessageGroupByOutputType[P]>
            : GetScalarType<T[P], CustomPaperMessageGroupByOutputType[P]>
        }
      >
    >


  export type CustomPaperMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customPaperId?: boolean
    senderId?: boolean
    content?: boolean
    attachments?: boolean
    isFromAdmin?: boolean
    isRead?: boolean
    createdAt?: boolean
    customPaper?: boolean | CustomPaperDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customPaperMessage"]>

  export type CustomPaperMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customPaperId?: boolean
    senderId?: boolean
    content?: boolean
    attachments?: boolean
    isFromAdmin?: boolean
    isRead?: boolean
    createdAt?: boolean
    customPaper?: boolean | CustomPaperDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customPaperMessage"]>

  export type CustomPaperMessageSelectScalar = {
    id?: boolean
    customPaperId?: boolean
    senderId?: boolean
    content?: boolean
    attachments?: boolean
    isFromAdmin?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type CustomPaperMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customPaper?: boolean | CustomPaperDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CustomPaperMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customPaper?: boolean | CustomPaperDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CustomPaperMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomPaperMessage"
    objects: {
      customPaper: Prisma.$CustomPaperPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customPaperId: string
      senderId: string
      content: string
      attachments: string[]
      isFromAdmin: boolean
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["customPaperMessage"]>
    composites: {}
  }

  type CustomPaperMessageGetPayload<S extends boolean | null | undefined | CustomPaperMessageDefaultArgs> = $Result.GetResult<Prisma.$CustomPaperMessagePayload, S>

  type CustomPaperMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomPaperMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomPaperMessageCountAggregateInputType | true
    }

  export interface CustomPaperMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomPaperMessage'], meta: { name: 'CustomPaperMessage' } }
    /**
     * Find zero or one CustomPaperMessage that matches the filter.
     * @param {CustomPaperMessageFindUniqueArgs} args - Arguments to find a CustomPaperMessage
     * @example
     * // Get one CustomPaperMessage
     * const customPaperMessage = await prisma.customPaperMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomPaperMessageFindUniqueArgs>(args: SelectSubset<T, CustomPaperMessageFindUniqueArgs<ExtArgs>>): Prisma__CustomPaperMessageClient<$Result.GetResult<Prisma.$CustomPaperMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomPaperMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomPaperMessageFindUniqueOrThrowArgs} args - Arguments to find a CustomPaperMessage
     * @example
     * // Get one CustomPaperMessage
     * const customPaperMessage = await prisma.customPaperMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomPaperMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomPaperMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomPaperMessageClient<$Result.GetResult<Prisma.$CustomPaperMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomPaperMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPaperMessageFindFirstArgs} args - Arguments to find a CustomPaperMessage
     * @example
     * // Get one CustomPaperMessage
     * const customPaperMessage = await prisma.customPaperMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomPaperMessageFindFirstArgs>(args?: SelectSubset<T, CustomPaperMessageFindFirstArgs<ExtArgs>>): Prisma__CustomPaperMessageClient<$Result.GetResult<Prisma.$CustomPaperMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomPaperMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPaperMessageFindFirstOrThrowArgs} args - Arguments to find a CustomPaperMessage
     * @example
     * // Get one CustomPaperMessage
     * const customPaperMessage = await prisma.customPaperMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomPaperMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomPaperMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomPaperMessageClient<$Result.GetResult<Prisma.$CustomPaperMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomPaperMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPaperMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomPaperMessages
     * const customPaperMessages = await prisma.customPaperMessage.findMany()
     * 
     * // Get first 10 CustomPaperMessages
     * const customPaperMessages = await prisma.customPaperMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customPaperMessageWithIdOnly = await prisma.customPaperMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomPaperMessageFindManyArgs>(args?: SelectSubset<T, CustomPaperMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomPaperMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomPaperMessage.
     * @param {CustomPaperMessageCreateArgs} args - Arguments to create a CustomPaperMessage.
     * @example
     * // Create one CustomPaperMessage
     * const CustomPaperMessage = await prisma.customPaperMessage.create({
     *   data: {
     *     // ... data to create a CustomPaperMessage
     *   }
     * })
     * 
     */
    create<T extends CustomPaperMessageCreateArgs>(args: SelectSubset<T, CustomPaperMessageCreateArgs<ExtArgs>>): Prisma__CustomPaperMessageClient<$Result.GetResult<Prisma.$CustomPaperMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomPaperMessages.
     * @param {CustomPaperMessageCreateManyArgs} args - Arguments to create many CustomPaperMessages.
     * @example
     * // Create many CustomPaperMessages
     * const customPaperMessage = await prisma.customPaperMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomPaperMessageCreateManyArgs>(args?: SelectSubset<T, CustomPaperMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomPaperMessages and returns the data saved in the database.
     * @param {CustomPaperMessageCreateManyAndReturnArgs} args - Arguments to create many CustomPaperMessages.
     * @example
     * // Create many CustomPaperMessages
     * const customPaperMessage = await prisma.customPaperMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomPaperMessages and only return the `id`
     * const customPaperMessageWithIdOnly = await prisma.customPaperMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomPaperMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomPaperMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomPaperMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomPaperMessage.
     * @param {CustomPaperMessageDeleteArgs} args - Arguments to delete one CustomPaperMessage.
     * @example
     * // Delete one CustomPaperMessage
     * const CustomPaperMessage = await prisma.customPaperMessage.delete({
     *   where: {
     *     // ... filter to delete one CustomPaperMessage
     *   }
     * })
     * 
     */
    delete<T extends CustomPaperMessageDeleteArgs>(args: SelectSubset<T, CustomPaperMessageDeleteArgs<ExtArgs>>): Prisma__CustomPaperMessageClient<$Result.GetResult<Prisma.$CustomPaperMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomPaperMessage.
     * @param {CustomPaperMessageUpdateArgs} args - Arguments to update one CustomPaperMessage.
     * @example
     * // Update one CustomPaperMessage
     * const customPaperMessage = await prisma.customPaperMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomPaperMessageUpdateArgs>(args: SelectSubset<T, CustomPaperMessageUpdateArgs<ExtArgs>>): Prisma__CustomPaperMessageClient<$Result.GetResult<Prisma.$CustomPaperMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomPaperMessages.
     * @param {CustomPaperMessageDeleteManyArgs} args - Arguments to filter CustomPaperMessages to delete.
     * @example
     * // Delete a few CustomPaperMessages
     * const { count } = await prisma.customPaperMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomPaperMessageDeleteManyArgs>(args?: SelectSubset<T, CustomPaperMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomPaperMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPaperMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomPaperMessages
     * const customPaperMessage = await prisma.customPaperMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomPaperMessageUpdateManyArgs>(args: SelectSubset<T, CustomPaperMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomPaperMessage.
     * @param {CustomPaperMessageUpsertArgs} args - Arguments to update or create a CustomPaperMessage.
     * @example
     * // Update or create a CustomPaperMessage
     * const customPaperMessage = await prisma.customPaperMessage.upsert({
     *   create: {
     *     // ... data to create a CustomPaperMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomPaperMessage we want to update
     *   }
     * })
     */
    upsert<T extends CustomPaperMessageUpsertArgs>(args: SelectSubset<T, CustomPaperMessageUpsertArgs<ExtArgs>>): Prisma__CustomPaperMessageClient<$Result.GetResult<Prisma.$CustomPaperMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomPaperMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPaperMessageCountArgs} args - Arguments to filter CustomPaperMessages to count.
     * @example
     * // Count the number of CustomPaperMessages
     * const count = await prisma.customPaperMessage.count({
     *   where: {
     *     // ... the filter for the CustomPaperMessages we want to count
     *   }
     * })
    **/
    count<T extends CustomPaperMessageCountArgs>(
      args?: Subset<T, CustomPaperMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomPaperMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomPaperMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPaperMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomPaperMessageAggregateArgs>(args: Subset<T, CustomPaperMessageAggregateArgs>): Prisma.PrismaPromise<GetCustomPaperMessageAggregateType<T>>

    /**
     * Group by CustomPaperMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomPaperMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomPaperMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomPaperMessageGroupByArgs['orderBy'] }
        : { orderBy?: CustomPaperMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomPaperMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomPaperMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomPaperMessage model
   */
  readonly fields: CustomPaperMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomPaperMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomPaperMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customPaper<T extends CustomPaperDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomPaperDefaultArgs<ExtArgs>>): Prisma__CustomPaperClient<$Result.GetResult<Prisma.$CustomPaperPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomPaperMessage model
   */ 
  interface CustomPaperMessageFieldRefs {
    readonly id: FieldRef<"CustomPaperMessage", 'String'>
    readonly customPaperId: FieldRef<"CustomPaperMessage", 'String'>
    readonly senderId: FieldRef<"CustomPaperMessage", 'String'>
    readonly content: FieldRef<"CustomPaperMessage", 'String'>
    readonly attachments: FieldRef<"CustomPaperMessage", 'String[]'>
    readonly isFromAdmin: FieldRef<"CustomPaperMessage", 'Boolean'>
    readonly isRead: FieldRef<"CustomPaperMessage", 'Boolean'>
    readonly createdAt: FieldRef<"CustomPaperMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomPaperMessage findUnique
   */
  export type CustomPaperMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaperMessage
     */
    select?: CustomPaperMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperMessageInclude<ExtArgs> | null
    /**
     * Filter, which CustomPaperMessage to fetch.
     */
    where: CustomPaperMessageWhereUniqueInput
  }

  /**
   * CustomPaperMessage findUniqueOrThrow
   */
  export type CustomPaperMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaperMessage
     */
    select?: CustomPaperMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperMessageInclude<ExtArgs> | null
    /**
     * Filter, which CustomPaperMessage to fetch.
     */
    where: CustomPaperMessageWhereUniqueInput
  }

  /**
   * CustomPaperMessage findFirst
   */
  export type CustomPaperMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaperMessage
     */
    select?: CustomPaperMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperMessageInclude<ExtArgs> | null
    /**
     * Filter, which CustomPaperMessage to fetch.
     */
    where?: CustomPaperMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomPaperMessages to fetch.
     */
    orderBy?: CustomPaperMessageOrderByWithRelationInput | CustomPaperMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomPaperMessages.
     */
    cursor?: CustomPaperMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomPaperMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomPaperMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomPaperMessages.
     */
    distinct?: CustomPaperMessageScalarFieldEnum | CustomPaperMessageScalarFieldEnum[]
  }

  /**
   * CustomPaperMessage findFirstOrThrow
   */
  export type CustomPaperMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaperMessage
     */
    select?: CustomPaperMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperMessageInclude<ExtArgs> | null
    /**
     * Filter, which CustomPaperMessage to fetch.
     */
    where?: CustomPaperMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomPaperMessages to fetch.
     */
    orderBy?: CustomPaperMessageOrderByWithRelationInput | CustomPaperMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomPaperMessages.
     */
    cursor?: CustomPaperMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomPaperMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomPaperMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomPaperMessages.
     */
    distinct?: CustomPaperMessageScalarFieldEnum | CustomPaperMessageScalarFieldEnum[]
  }

  /**
   * CustomPaperMessage findMany
   */
  export type CustomPaperMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaperMessage
     */
    select?: CustomPaperMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperMessageInclude<ExtArgs> | null
    /**
     * Filter, which CustomPaperMessages to fetch.
     */
    where?: CustomPaperMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomPaperMessages to fetch.
     */
    orderBy?: CustomPaperMessageOrderByWithRelationInput | CustomPaperMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomPaperMessages.
     */
    cursor?: CustomPaperMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomPaperMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomPaperMessages.
     */
    skip?: number
    distinct?: CustomPaperMessageScalarFieldEnum | CustomPaperMessageScalarFieldEnum[]
  }

  /**
   * CustomPaperMessage create
   */
  export type CustomPaperMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaperMessage
     */
    select?: CustomPaperMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomPaperMessage.
     */
    data: XOR<CustomPaperMessageCreateInput, CustomPaperMessageUncheckedCreateInput>
  }

  /**
   * CustomPaperMessage createMany
   */
  export type CustomPaperMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomPaperMessages.
     */
    data: CustomPaperMessageCreateManyInput | CustomPaperMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomPaperMessage createManyAndReturn
   */
  export type CustomPaperMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaperMessage
     */
    select?: CustomPaperMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomPaperMessages.
     */
    data: CustomPaperMessageCreateManyInput | CustomPaperMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomPaperMessage update
   */
  export type CustomPaperMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaperMessage
     */
    select?: CustomPaperMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomPaperMessage.
     */
    data: XOR<CustomPaperMessageUpdateInput, CustomPaperMessageUncheckedUpdateInput>
    /**
     * Choose, which CustomPaperMessage to update.
     */
    where: CustomPaperMessageWhereUniqueInput
  }

  /**
   * CustomPaperMessage updateMany
   */
  export type CustomPaperMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomPaperMessages.
     */
    data: XOR<CustomPaperMessageUpdateManyMutationInput, CustomPaperMessageUncheckedUpdateManyInput>
    /**
     * Filter which CustomPaperMessages to update
     */
    where?: CustomPaperMessageWhereInput
  }

  /**
   * CustomPaperMessage upsert
   */
  export type CustomPaperMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaperMessage
     */
    select?: CustomPaperMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomPaperMessage to update in case it exists.
     */
    where: CustomPaperMessageWhereUniqueInput
    /**
     * In case the CustomPaperMessage found by the `where` argument doesn't exist, create a new CustomPaperMessage with this data.
     */
    create: XOR<CustomPaperMessageCreateInput, CustomPaperMessageUncheckedCreateInput>
    /**
     * In case the CustomPaperMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomPaperMessageUpdateInput, CustomPaperMessageUncheckedUpdateInput>
  }

  /**
   * CustomPaperMessage delete
   */
  export type CustomPaperMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaperMessage
     */
    select?: CustomPaperMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperMessageInclude<ExtArgs> | null
    /**
     * Filter which CustomPaperMessage to delete.
     */
    where: CustomPaperMessageWhereUniqueInput
  }

  /**
   * CustomPaperMessage deleteMany
   */
  export type CustomPaperMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomPaperMessages to delete
     */
    where?: CustomPaperMessageWhereInput
  }

  /**
   * CustomPaperMessage without action
   */
  export type CustomPaperMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomPaperMessage
     */
    select?: CustomPaperMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomPaperMessageInclude<ExtArgs> | null
  }


  /**
   * Model CourseModule
   */

  export type AggregateCourseModule = {
    _count: CourseModuleCountAggregateOutputType | null
    _avg: CourseModuleAvgAggregateOutputType | null
    _sum: CourseModuleSumAggregateOutputType | null
    _min: CourseModuleMinAggregateOutputType | null
    _max: CourseModuleMaxAggregateOutputType | null
  }

  export type CourseModuleAvgAggregateOutputType = {
    order: number | null
  }

  export type CourseModuleSumAggregateOutputType = {
    order: number | null
  }

  export type CourseModuleMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    title: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseModuleMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    title: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseModuleCountAggregateOutputType = {
    id: number
    courseId: number
    title: number
    description: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseModuleAvgAggregateInputType = {
    order?: true
  }

  export type CourseModuleSumAggregateInputType = {
    order?: true
  }

  export type CourseModuleMinAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseModuleMaxAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseModuleCountAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseModule to aggregate.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseModules
    **/
    _count?: true | CourseModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseModuleMaxAggregateInputType
  }

  export type GetCourseModuleAggregateType<T extends CourseModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseModule[P]>
      : GetScalarType<T[P], AggregateCourseModule[P]>
  }




  export type CourseModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseModuleWhereInput
    orderBy?: CourseModuleOrderByWithAggregationInput | CourseModuleOrderByWithAggregationInput[]
    by: CourseModuleScalarFieldEnum[] | CourseModuleScalarFieldEnum
    having?: CourseModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseModuleCountAggregateInputType | true
    _avg?: CourseModuleAvgAggregateInputType
    _sum?: CourseModuleSumAggregateInputType
    _min?: CourseModuleMinAggregateInputType
    _max?: CourseModuleMaxAggregateInputType
  }

  export type CourseModuleGroupByOutputType = {
    id: string
    courseId: string
    title: string
    description: string | null
    order: number
    createdAt: Date
    updatedAt: Date
    _count: CourseModuleCountAggregateOutputType | null
    _avg: CourseModuleAvgAggregateOutputType | null
    _sum: CourseModuleSumAggregateOutputType | null
    _min: CourseModuleMinAggregateOutputType | null
    _max: CourseModuleMaxAggregateOutputType | null
  }

  type GetCourseModuleGroupByPayload<T extends CourseModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseModuleGroupByOutputType[P]>
            : GetScalarType<T[P], CourseModuleGroupByOutputType[P]>
        }
      >
    >


  export type CourseModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    lessons?: boolean | CourseModule$lessonsArgs<ExtArgs>
    _count?: boolean | CourseModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseModule"]>

  export type CourseModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseModule"]>

  export type CourseModuleSelectScalar = {
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    lessons?: boolean | CourseModule$lessonsArgs<ExtArgs>
    _count?: boolean | CourseModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseModule"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      lessons: Prisma.$CourseLessonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      title: string
      description: string | null
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["courseModule"]>
    composites: {}
  }

  type CourseModuleGetPayload<S extends boolean | null | undefined | CourseModuleDefaultArgs> = $Result.GetResult<Prisma.$CourseModulePayload, S>

  type CourseModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseModuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseModuleCountAggregateInputType | true
    }

  export interface CourseModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseModule'], meta: { name: 'CourseModule' } }
    /**
     * Find zero or one CourseModule that matches the filter.
     * @param {CourseModuleFindUniqueArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseModuleFindUniqueArgs>(args: SelectSubset<T, CourseModuleFindUniqueArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseModule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseModuleFindUniqueOrThrowArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleFindFirstArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseModuleFindFirstArgs>(args?: SelectSubset<T, CourseModuleFindFirstArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleFindFirstOrThrowArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseModules
     * const courseModules = await prisma.courseModule.findMany()
     * 
     * // Get first 10 CourseModules
     * const courseModules = await prisma.courseModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseModuleWithIdOnly = await prisma.courseModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseModuleFindManyArgs>(args?: SelectSubset<T, CourseModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseModule.
     * @param {CourseModuleCreateArgs} args - Arguments to create a CourseModule.
     * @example
     * // Create one CourseModule
     * const CourseModule = await prisma.courseModule.create({
     *   data: {
     *     // ... data to create a CourseModule
     *   }
     * })
     * 
     */
    create<T extends CourseModuleCreateArgs>(args: SelectSubset<T, CourseModuleCreateArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseModules.
     * @param {CourseModuleCreateManyArgs} args - Arguments to create many CourseModules.
     * @example
     * // Create many CourseModules
     * const courseModule = await prisma.courseModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseModuleCreateManyArgs>(args?: SelectSubset<T, CourseModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseModules and returns the data saved in the database.
     * @param {CourseModuleCreateManyAndReturnArgs} args - Arguments to create many CourseModules.
     * @example
     * // Create many CourseModules
     * const courseModule = await prisma.courseModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseModules and only return the `id`
     * const courseModuleWithIdOnly = await prisma.courseModule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseModule.
     * @param {CourseModuleDeleteArgs} args - Arguments to delete one CourseModule.
     * @example
     * // Delete one CourseModule
     * const CourseModule = await prisma.courseModule.delete({
     *   where: {
     *     // ... filter to delete one CourseModule
     *   }
     * })
     * 
     */
    delete<T extends CourseModuleDeleteArgs>(args: SelectSubset<T, CourseModuleDeleteArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseModule.
     * @param {CourseModuleUpdateArgs} args - Arguments to update one CourseModule.
     * @example
     * // Update one CourseModule
     * const courseModule = await prisma.courseModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseModuleUpdateArgs>(args: SelectSubset<T, CourseModuleUpdateArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseModules.
     * @param {CourseModuleDeleteManyArgs} args - Arguments to filter CourseModules to delete.
     * @example
     * // Delete a few CourseModules
     * const { count } = await prisma.courseModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseModuleDeleteManyArgs>(args?: SelectSubset<T, CourseModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseModules
     * const courseModule = await prisma.courseModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseModuleUpdateManyArgs>(args: SelectSubset<T, CourseModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseModule.
     * @param {CourseModuleUpsertArgs} args - Arguments to update or create a CourseModule.
     * @example
     * // Update or create a CourseModule
     * const courseModule = await prisma.courseModule.upsert({
     *   create: {
     *     // ... data to create a CourseModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseModule we want to update
     *   }
     * })
     */
    upsert<T extends CourseModuleUpsertArgs>(args: SelectSubset<T, CourseModuleUpsertArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleCountArgs} args - Arguments to filter CourseModules to count.
     * @example
     * // Count the number of CourseModules
     * const count = await prisma.courseModule.count({
     *   where: {
     *     // ... the filter for the CourseModules we want to count
     *   }
     * })
    **/
    count<T extends CourseModuleCountArgs>(
      args?: Subset<T, CourseModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseModuleAggregateArgs>(args: Subset<T, CourseModuleAggregateArgs>): Prisma.PrismaPromise<GetCourseModuleAggregateType<T>>

    /**
     * Group by CourseModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseModuleGroupByArgs['orderBy'] }
        : { orderBy?: CourseModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseModule model
   */
  readonly fields: CourseModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lessons<T extends CourseModule$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, CourseModule$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLessonPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseModule model
   */ 
  interface CourseModuleFieldRefs {
    readonly id: FieldRef<"CourseModule", 'String'>
    readonly courseId: FieldRef<"CourseModule", 'String'>
    readonly title: FieldRef<"CourseModule", 'String'>
    readonly description: FieldRef<"CourseModule", 'String'>
    readonly order: FieldRef<"CourseModule", 'Int'>
    readonly createdAt: FieldRef<"CourseModule", 'DateTime'>
    readonly updatedAt: FieldRef<"CourseModule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseModule findUnique
   */
  export type CourseModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule findUniqueOrThrow
   */
  export type CourseModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule findFirst
   */
  export type CourseModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseModules.
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseModules.
     */
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * CourseModule findFirstOrThrow
   */
  export type CourseModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseModules.
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseModules.
     */
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * CourseModule findMany
   */
  export type CourseModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModules to fetch.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseModules.
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * CourseModule create
   */
  export type CourseModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseModule.
     */
    data: XOR<CourseModuleCreateInput, CourseModuleUncheckedCreateInput>
  }

  /**
   * CourseModule createMany
   */
  export type CourseModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseModules.
     */
    data: CourseModuleCreateManyInput | CourseModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseModule createManyAndReturn
   */
  export type CourseModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseModules.
     */
    data: CourseModuleCreateManyInput | CourseModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseModule update
   */
  export type CourseModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseModule.
     */
    data: XOR<CourseModuleUpdateInput, CourseModuleUncheckedUpdateInput>
    /**
     * Choose, which CourseModule to update.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule updateMany
   */
  export type CourseModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseModules.
     */
    data: XOR<CourseModuleUpdateManyMutationInput, CourseModuleUncheckedUpdateManyInput>
    /**
     * Filter which CourseModules to update
     */
    where?: CourseModuleWhereInput
  }

  /**
   * CourseModule upsert
   */
  export type CourseModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseModule to update in case it exists.
     */
    where: CourseModuleWhereUniqueInput
    /**
     * In case the CourseModule found by the `where` argument doesn't exist, create a new CourseModule with this data.
     */
    create: XOR<CourseModuleCreateInput, CourseModuleUncheckedCreateInput>
    /**
     * In case the CourseModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseModuleUpdateInput, CourseModuleUncheckedUpdateInput>
  }

  /**
   * CourseModule delete
   */
  export type CourseModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter which CourseModule to delete.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule deleteMany
   */
  export type CourseModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseModules to delete
     */
    where?: CourseModuleWhereInput
  }

  /**
   * CourseModule.lessons
   */
  export type CourseModule$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLesson
     */
    select?: CourseLessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLessonInclude<ExtArgs> | null
    where?: CourseLessonWhereInput
    orderBy?: CourseLessonOrderByWithRelationInput | CourseLessonOrderByWithRelationInput[]
    cursor?: CourseLessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseLessonScalarFieldEnum | CourseLessonScalarFieldEnum[]
  }

  /**
   * CourseModule without action
   */
  export type CourseModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
  }


  /**
   * Model CourseLesson
   */

  export type AggregateCourseLesson = {
    _count: CourseLessonCountAggregateOutputType | null
    _avg: CourseLessonAvgAggregateOutputType | null
    _sum: CourseLessonSumAggregateOutputType | null
    _min: CourseLessonMinAggregateOutputType | null
    _max: CourseLessonMaxAggregateOutputType | null
  }

  export type CourseLessonAvgAggregateOutputType = {
    duration: number | null
    order: number | null
  }

  export type CourseLessonSumAggregateOutputType = {
    duration: number | null
    order: number | null
  }

  export type CourseLessonMinAggregateOutputType = {
    id: string | null
    moduleId: string | null
    title: string | null
    description: string | null
    videoUrl: string | null
    content: string | null
    duration: number | null
    order: number | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseLessonMaxAggregateOutputType = {
    id: string | null
    moduleId: string | null
    title: string | null
    description: string | null
    videoUrl: string | null
    content: string | null
    duration: number | null
    order: number | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseLessonCountAggregateOutputType = {
    id: number
    moduleId: number
    title: number
    description: number
    videoUrl: number
    content: number
    duration: number
    order: number
    isEnabled: number
    attachments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseLessonAvgAggregateInputType = {
    duration?: true
    order?: true
  }

  export type CourseLessonSumAggregateInputType = {
    duration?: true
    order?: true
  }

  export type CourseLessonMinAggregateInputType = {
    id?: true
    moduleId?: true
    title?: true
    description?: true
    videoUrl?: true
    content?: true
    duration?: true
    order?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseLessonMaxAggregateInputType = {
    id?: true
    moduleId?: true
    title?: true
    description?: true
    videoUrl?: true
    content?: true
    duration?: true
    order?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseLessonCountAggregateInputType = {
    id?: true
    moduleId?: true
    title?: true
    description?: true
    videoUrl?: true
    content?: true
    duration?: true
    order?: true
    isEnabled?: true
    attachments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseLessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseLesson to aggregate.
     */
    where?: CourseLessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLessons to fetch.
     */
    orderBy?: CourseLessonOrderByWithRelationInput | CourseLessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseLessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseLessons
    **/
    _count?: true | CourseLessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseLessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseLessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseLessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseLessonMaxAggregateInputType
  }

  export type GetCourseLessonAggregateType<T extends CourseLessonAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseLesson[P]>
      : GetScalarType<T[P], AggregateCourseLesson[P]>
  }




  export type CourseLessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseLessonWhereInput
    orderBy?: CourseLessonOrderByWithAggregationInput | CourseLessonOrderByWithAggregationInput[]
    by: CourseLessonScalarFieldEnum[] | CourseLessonScalarFieldEnum
    having?: CourseLessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseLessonCountAggregateInputType | true
    _avg?: CourseLessonAvgAggregateInputType
    _sum?: CourseLessonSumAggregateInputType
    _min?: CourseLessonMinAggregateInputType
    _max?: CourseLessonMaxAggregateInputType
  }

  export type CourseLessonGroupByOutputType = {
    id: string
    moduleId: string
    title: string
    description: string | null
    videoUrl: string | null
    content: string | null
    duration: number | null
    order: number
    isEnabled: boolean
    attachments: string[]
    createdAt: Date
    updatedAt: Date
    _count: CourseLessonCountAggregateOutputType | null
    _avg: CourseLessonAvgAggregateOutputType | null
    _sum: CourseLessonSumAggregateOutputType | null
    _min: CourseLessonMinAggregateOutputType | null
    _max: CourseLessonMaxAggregateOutputType | null
  }

  type GetCourseLessonGroupByPayload<T extends CourseLessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseLessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseLessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseLessonGroupByOutputType[P]>
            : GetScalarType<T[P], CourseLessonGroupByOutputType[P]>
        }
      >
    >


  export type CourseLessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    videoUrl?: boolean
    content?: boolean
    duration?: boolean
    order?: boolean
    isEnabled?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
    progress?: boolean | CourseLesson$progressArgs<ExtArgs>
    _count?: boolean | CourseLessonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseLesson"]>

  export type CourseLessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    videoUrl?: boolean
    content?: boolean
    duration?: boolean
    order?: boolean
    isEnabled?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseLesson"]>

  export type CourseLessonSelectScalar = {
    id?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    videoUrl?: boolean
    content?: boolean
    duration?: boolean
    order?: boolean
    isEnabled?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseLessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
    progress?: boolean | CourseLesson$progressArgs<ExtArgs>
    _count?: boolean | CourseLessonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseLessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }

  export type $CourseLessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseLesson"
    objects: {
      module: Prisma.$CourseModulePayload<ExtArgs>
      progress: Prisma.$CourseProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      moduleId: string
      title: string
      description: string | null
      videoUrl: string | null
      content: string | null
      duration: number | null
      order: number
      isEnabled: boolean
      attachments: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["courseLesson"]>
    composites: {}
  }

  type CourseLessonGetPayload<S extends boolean | null | undefined | CourseLessonDefaultArgs> = $Result.GetResult<Prisma.$CourseLessonPayload, S>

  type CourseLessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseLessonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseLessonCountAggregateInputType | true
    }

  export interface CourseLessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseLesson'], meta: { name: 'CourseLesson' } }
    /**
     * Find zero or one CourseLesson that matches the filter.
     * @param {CourseLessonFindUniqueArgs} args - Arguments to find a CourseLesson
     * @example
     * // Get one CourseLesson
     * const courseLesson = await prisma.courseLesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseLessonFindUniqueArgs>(args: SelectSubset<T, CourseLessonFindUniqueArgs<ExtArgs>>): Prisma__CourseLessonClient<$Result.GetResult<Prisma.$CourseLessonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseLesson that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseLessonFindUniqueOrThrowArgs} args - Arguments to find a CourseLesson
     * @example
     * // Get one CourseLesson
     * const courseLesson = await prisma.courseLesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseLessonFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseLessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseLessonClient<$Result.GetResult<Prisma.$CourseLessonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseLesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLessonFindFirstArgs} args - Arguments to find a CourseLesson
     * @example
     * // Get one CourseLesson
     * const courseLesson = await prisma.courseLesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseLessonFindFirstArgs>(args?: SelectSubset<T, CourseLessonFindFirstArgs<ExtArgs>>): Prisma__CourseLessonClient<$Result.GetResult<Prisma.$CourseLessonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseLesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLessonFindFirstOrThrowArgs} args - Arguments to find a CourseLesson
     * @example
     * // Get one CourseLesson
     * const courseLesson = await prisma.courseLesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseLessonFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseLessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseLessonClient<$Result.GetResult<Prisma.$CourseLessonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseLessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseLessons
     * const courseLessons = await prisma.courseLesson.findMany()
     * 
     * // Get first 10 CourseLessons
     * const courseLessons = await prisma.courseLesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseLessonWithIdOnly = await prisma.courseLesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseLessonFindManyArgs>(args?: SelectSubset<T, CourseLessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLessonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseLesson.
     * @param {CourseLessonCreateArgs} args - Arguments to create a CourseLesson.
     * @example
     * // Create one CourseLesson
     * const CourseLesson = await prisma.courseLesson.create({
     *   data: {
     *     // ... data to create a CourseLesson
     *   }
     * })
     * 
     */
    create<T extends CourseLessonCreateArgs>(args: SelectSubset<T, CourseLessonCreateArgs<ExtArgs>>): Prisma__CourseLessonClient<$Result.GetResult<Prisma.$CourseLessonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseLessons.
     * @param {CourseLessonCreateManyArgs} args - Arguments to create many CourseLessons.
     * @example
     * // Create many CourseLessons
     * const courseLesson = await prisma.courseLesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseLessonCreateManyArgs>(args?: SelectSubset<T, CourseLessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseLessons and returns the data saved in the database.
     * @param {CourseLessonCreateManyAndReturnArgs} args - Arguments to create many CourseLessons.
     * @example
     * // Create many CourseLessons
     * const courseLesson = await prisma.courseLesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseLessons and only return the `id`
     * const courseLessonWithIdOnly = await prisma.courseLesson.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseLessonCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseLessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLessonPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseLesson.
     * @param {CourseLessonDeleteArgs} args - Arguments to delete one CourseLesson.
     * @example
     * // Delete one CourseLesson
     * const CourseLesson = await prisma.courseLesson.delete({
     *   where: {
     *     // ... filter to delete one CourseLesson
     *   }
     * })
     * 
     */
    delete<T extends CourseLessonDeleteArgs>(args: SelectSubset<T, CourseLessonDeleteArgs<ExtArgs>>): Prisma__CourseLessonClient<$Result.GetResult<Prisma.$CourseLessonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseLesson.
     * @param {CourseLessonUpdateArgs} args - Arguments to update one CourseLesson.
     * @example
     * // Update one CourseLesson
     * const courseLesson = await prisma.courseLesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseLessonUpdateArgs>(args: SelectSubset<T, CourseLessonUpdateArgs<ExtArgs>>): Prisma__CourseLessonClient<$Result.GetResult<Prisma.$CourseLessonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseLessons.
     * @param {CourseLessonDeleteManyArgs} args - Arguments to filter CourseLessons to delete.
     * @example
     * // Delete a few CourseLessons
     * const { count } = await prisma.courseLesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseLessonDeleteManyArgs>(args?: SelectSubset<T, CourseLessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseLessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseLessons
     * const courseLesson = await prisma.courseLesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseLessonUpdateManyArgs>(args: SelectSubset<T, CourseLessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseLesson.
     * @param {CourseLessonUpsertArgs} args - Arguments to update or create a CourseLesson.
     * @example
     * // Update or create a CourseLesson
     * const courseLesson = await prisma.courseLesson.upsert({
     *   create: {
     *     // ... data to create a CourseLesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseLesson we want to update
     *   }
     * })
     */
    upsert<T extends CourseLessonUpsertArgs>(args: SelectSubset<T, CourseLessonUpsertArgs<ExtArgs>>): Prisma__CourseLessonClient<$Result.GetResult<Prisma.$CourseLessonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseLessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLessonCountArgs} args - Arguments to filter CourseLessons to count.
     * @example
     * // Count the number of CourseLessons
     * const count = await prisma.courseLesson.count({
     *   where: {
     *     // ... the filter for the CourseLessons we want to count
     *   }
     * })
    **/
    count<T extends CourseLessonCountArgs>(
      args?: Subset<T, CourseLessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseLessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseLesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseLessonAggregateArgs>(args: Subset<T, CourseLessonAggregateArgs>): Prisma.PrismaPromise<GetCourseLessonAggregateType<T>>

    /**
     * Group by CourseLesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseLessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseLessonGroupByArgs['orderBy'] }
        : { orderBy?: CourseLessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseLessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseLesson model
   */
  readonly fields: CourseLessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseLesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseLessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends CourseModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseModuleDefaultArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    progress<T extends CourseLesson$progressArgs<ExtArgs> = {}>(args?: Subset<T, CourseLesson$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseLesson model
   */ 
  interface CourseLessonFieldRefs {
    readonly id: FieldRef<"CourseLesson", 'String'>
    readonly moduleId: FieldRef<"CourseLesson", 'String'>
    readonly title: FieldRef<"CourseLesson", 'String'>
    readonly description: FieldRef<"CourseLesson", 'String'>
    readonly videoUrl: FieldRef<"CourseLesson", 'String'>
    readonly content: FieldRef<"CourseLesson", 'String'>
    readonly duration: FieldRef<"CourseLesson", 'Int'>
    readonly order: FieldRef<"CourseLesson", 'Int'>
    readonly isEnabled: FieldRef<"CourseLesson", 'Boolean'>
    readonly attachments: FieldRef<"CourseLesson", 'String[]'>
    readonly createdAt: FieldRef<"CourseLesson", 'DateTime'>
    readonly updatedAt: FieldRef<"CourseLesson", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseLesson findUnique
   */
  export type CourseLessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLesson
     */
    select?: CourseLessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLessonInclude<ExtArgs> | null
    /**
     * Filter, which CourseLesson to fetch.
     */
    where: CourseLessonWhereUniqueInput
  }

  /**
   * CourseLesson findUniqueOrThrow
   */
  export type CourseLessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLesson
     */
    select?: CourseLessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLessonInclude<ExtArgs> | null
    /**
     * Filter, which CourseLesson to fetch.
     */
    where: CourseLessonWhereUniqueInput
  }

  /**
   * CourseLesson findFirst
   */
  export type CourseLessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLesson
     */
    select?: CourseLessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLessonInclude<ExtArgs> | null
    /**
     * Filter, which CourseLesson to fetch.
     */
    where?: CourseLessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLessons to fetch.
     */
    orderBy?: CourseLessonOrderByWithRelationInput | CourseLessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseLessons.
     */
    cursor?: CourseLessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseLessons.
     */
    distinct?: CourseLessonScalarFieldEnum | CourseLessonScalarFieldEnum[]
  }

  /**
   * CourseLesson findFirstOrThrow
   */
  export type CourseLessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLesson
     */
    select?: CourseLessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLessonInclude<ExtArgs> | null
    /**
     * Filter, which CourseLesson to fetch.
     */
    where?: CourseLessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLessons to fetch.
     */
    orderBy?: CourseLessonOrderByWithRelationInput | CourseLessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseLessons.
     */
    cursor?: CourseLessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseLessons.
     */
    distinct?: CourseLessonScalarFieldEnum | CourseLessonScalarFieldEnum[]
  }

  /**
   * CourseLesson findMany
   */
  export type CourseLessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLesson
     */
    select?: CourseLessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLessonInclude<ExtArgs> | null
    /**
     * Filter, which CourseLessons to fetch.
     */
    where?: CourseLessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLessons to fetch.
     */
    orderBy?: CourseLessonOrderByWithRelationInput | CourseLessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseLessons.
     */
    cursor?: CourseLessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLessons.
     */
    skip?: number
    distinct?: CourseLessonScalarFieldEnum | CourseLessonScalarFieldEnum[]
  }

  /**
   * CourseLesson create
   */
  export type CourseLessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLesson
     */
    select?: CourseLessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLessonInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseLesson.
     */
    data: XOR<CourseLessonCreateInput, CourseLessonUncheckedCreateInput>
  }

  /**
   * CourseLesson createMany
   */
  export type CourseLessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseLessons.
     */
    data: CourseLessonCreateManyInput | CourseLessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseLesson createManyAndReturn
   */
  export type CourseLessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLesson
     */
    select?: CourseLessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseLessons.
     */
    data: CourseLessonCreateManyInput | CourseLessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseLesson update
   */
  export type CourseLessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLesson
     */
    select?: CourseLessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLessonInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseLesson.
     */
    data: XOR<CourseLessonUpdateInput, CourseLessonUncheckedUpdateInput>
    /**
     * Choose, which CourseLesson to update.
     */
    where: CourseLessonWhereUniqueInput
  }

  /**
   * CourseLesson updateMany
   */
  export type CourseLessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseLessons.
     */
    data: XOR<CourseLessonUpdateManyMutationInput, CourseLessonUncheckedUpdateManyInput>
    /**
     * Filter which CourseLessons to update
     */
    where?: CourseLessonWhereInput
  }

  /**
   * CourseLesson upsert
   */
  export type CourseLessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLesson
     */
    select?: CourseLessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLessonInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseLesson to update in case it exists.
     */
    where: CourseLessonWhereUniqueInput
    /**
     * In case the CourseLesson found by the `where` argument doesn't exist, create a new CourseLesson with this data.
     */
    create: XOR<CourseLessonCreateInput, CourseLessonUncheckedCreateInput>
    /**
     * In case the CourseLesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseLessonUpdateInput, CourseLessonUncheckedUpdateInput>
  }

  /**
   * CourseLesson delete
   */
  export type CourseLessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLesson
     */
    select?: CourseLessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLessonInclude<ExtArgs> | null
    /**
     * Filter which CourseLesson to delete.
     */
    where: CourseLessonWhereUniqueInput
  }

  /**
   * CourseLesson deleteMany
   */
  export type CourseLessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseLessons to delete
     */
    where?: CourseLessonWhereInput
  }

  /**
   * CourseLesson.progress
   */
  export type CourseLesson$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    where?: CourseProgressWhereInput
    orderBy?: CourseProgressOrderByWithRelationInput | CourseProgressOrderByWithRelationInput[]
    cursor?: CourseProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseProgressScalarFieldEnum | CourseProgressScalarFieldEnum[]
  }

  /**
   * CourseLesson without action
   */
  export type CourseLessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLesson
     */
    select?: CourseLessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLessonInclude<ExtArgs> | null
  }


  /**
   * Model CourseProgress
   */

  export type AggregateCourseProgress = {
    _count: CourseProgressCountAggregateOutputType | null
    _avg: CourseProgressAvgAggregateOutputType | null
    _sum: CourseProgressSumAggregateOutputType | null
    _min: CourseProgressMinAggregateOutputType | null
    _max: CourseProgressMaxAggregateOutputType | null
  }

  export type CourseProgressAvgAggregateOutputType = {
    watchTime: number | null
  }

  export type CourseProgressSumAggregateOutputType = {
    watchTime: number | null
  }

  export type CourseProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    lessonId: string | null
    completed: boolean | null
    watchTime: number | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    lessonId: string | null
    completed: boolean | null
    watchTime: number | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseProgressCountAggregateOutputType = {
    id: number
    userId: number
    lessonId: number
    completed: number
    watchTime: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseProgressAvgAggregateInputType = {
    watchTime?: true
  }

  export type CourseProgressSumAggregateInputType = {
    watchTime?: true
  }

  export type CourseProgressMinAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    completed?: true
    watchTime?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    completed?: true
    watchTime?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseProgressCountAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    completed?: true
    watchTime?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseProgress to aggregate.
     */
    where?: CourseProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseProgresses to fetch.
     */
    orderBy?: CourseProgressOrderByWithRelationInput | CourseProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseProgresses
    **/
    _count?: true | CourseProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseProgressMaxAggregateInputType
  }

  export type GetCourseProgressAggregateType<T extends CourseProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseProgress[P]>
      : GetScalarType<T[P], AggregateCourseProgress[P]>
  }




  export type CourseProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseProgressWhereInput
    orderBy?: CourseProgressOrderByWithAggregationInput | CourseProgressOrderByWithAggregationInput[]
    by: CourseProgressScalarFieldEnum[] | CourseProgressScalarFieldEnum
    having?: CourseProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseProgressCountAggregateInputType | true
    _avg?: CourseProgressAvgAggregateInputType
    _sum?: CourseProgressSumAggregateInputType
    _min?: CourseProgressMinAggregateInputType
    _max?: CourseProgressMaxAggregateInputType
  }

  export type CourseProgressGroupByOutputType = {
    id: string
    userId: string
    lessonId: string
    completed: boolean
    watchTime: number
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CourseProgressCountAggregateOutputType | null
    _avg: CourseProgressAvgAggregateOutputType | null
    _sum: CourseProgressSumAggregateOutputType | null
    _min: CourseProgressMinAggregateOutputType | null
    _max: CourseProgressMaxAggregateOutputType | null
  }

  type GetCourseProgressGroupByPayload<T extends CourseProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseProgressGroupByOutputType[P]>
            : GetScalarType<T[P], CourseProgressGroupByOutputType[P]>
        }
      >
    >


  export type CourseProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    completed?: boolean
    watchTime?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | CourseLessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseProgress"]>

  export type CourseProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    completed?: boolean
    watchTime?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | CourseLessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseProgress"]>

  export type CourseProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    completed?: boolean
    watchTime?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | CourseLessonDefaultArgs<ExtArgs>
  }
  export type CourseProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | CourseLessonDefaultArgs<ExtArgs>
  }

  export type $CourseProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      lesson: Prisma.$CourseLessonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      lessonId: string
      completed: boolean
      watchTime: number
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["courseProgress"]>
    composites: {}
  }

  type CourseProgressGetPayload<S extends boolean | null | undefined | CourseProgressDefaultArgs> = $Result.GetResult<Prisma.$CourseProgressPayload, S>

  type CourseProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseProgressCountAggregateInputType | true
    }

  export interface CourseProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseProgress'], meta: { name: 'CourseProgress' } }
    /**
     * Find zero or one CourseProgress that matches the filter.
     * @param {CourseProgressFindUniqueArgs} args - Arguments to find a CourseProgress
     * @example
     * // Get one CourseProgress
     * const courseProgress = await prisma.courseProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseProgressFindUniqueArgs>(args: SelectSubset<T, CourseProgressFindUniqueArgs<ExtArgs>>): Prisma__CourseProgressClient<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseProgressFindUniqueOrThrowArgs} args - Arguments to find a CourseProgress
     * @example
     * // Get one CourseProgress
     * const courseProgress = await prisma.courseProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseProgressClient<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProgressFindFirstArgs} args - Arguments to find a CourseProgress
     * @example
     * // Get one CourseProgress
     * const courseProgress = await prisma.courseProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseProgressFindFirstArgs>(args?: SelectSubset<T, CourseProgressFindFirstArgs<ExtArgs>>): Prisma__CourseProgressClient<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProgressFindFirstOrThrowArgs} args - Arguments to find a CourseProgress
     * @example
     * // Get one CourseProgress
     * const courseProgress = await prisma.courseProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseProgressClient<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseProgresses
     * const courseProgresses = await prisma.courseProgress.findMany()
     * 
     * // Get first 10 CourseProgresses
     * const courseProgresses = await prisma.courseProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseProgressWithIdOnly = await prisma.courseProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseProgressFindManyArgs>(args?: SelectSubset<T, CourseProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseProgress.
     * @param {CourseProgressCreateArgs} args - Arguments to create a CourseProgress.
     * @example
     * // Create one CourseProgress
     * const CourseProgress = await prisma.courseProgress.create({
     *   data: {
     *     // ... data to create a CourseProgress
     *   }
     * })
     * 
     */
    create<T extends CourseProgressCreateArgs>(args: SelectSubset<T, CourseProgressCreateArgs<ExtArgs>>): Prisma__CourseProgressClient<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseProgresses.
     * @param {CourseProgressCreateManyArgs} args - Arguments to create many CourseProgresses.
     * @example
     * // Create many CourseProgresses
     * const courseProgress = await prisma.courseProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseProgressCreateManyArgs>(args?: SelectSubset<T, CourseProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseProgresses and returns the data saved in the database.
     * @param {CourseProgressCreateManyAndReturnArgs} args - Arguments to create many CourseProgresses.
     * @example
     * // Create many CourseProgresses
     * const courseProgress = await prisma.courseProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseProgresses and only return the `id`
     * const courseProgressWithIdOnly = await prisma.courseProgress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseProgress.
     * @param {CourseProgressDeleteArgs} args - Arguments to delete one CourseProgress.
     * @example
     * // Delete one CourseProgress
     * const CourseProgress = await prisma.courseProgress.delete({
     *   where: {
     *     // ... filter to delete one CourseProgress
     *   }
     * })
     * 
     */
    delete<T extends CourseProgressDeleteArgs>(args: SelectSubset<T, CourseProgressDeleteArgs<ExtArgs>>): Prisma__CourseProgressClient<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseProgress.
     * @param {CourseProgressUpdateArgs} args - Arguments to update one CourseProgress.
     * @example
     * // Update one CourseProgress
     * const courseProgress = await prisma.courseProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseProgressUpdateArgs>(args: SelectSubset<T, CourseProgressUpdateArgs<ExtArgs>>): Prisma__CourseProgressClient<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseProgresses.
     * @param {CourseProgressDeleteManyArgs} args - Arguments to filter CourseProgresses to delete.
     * @example
     * // Delete a few CourseProgresses
     * const { count } = await prisma.courseProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseProgressDeleteManyArgs>(args?: SelectSubset<T, CourseProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseProgresses
     * const courseProgress = await prisma.courseProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseProgressUpdateManyArgs>(args: SelectSubset<T, CourseProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseProgress.
     * @param {CourseProgressUpsertArgs} args - Arguments to update or create a CourseProgress.
     * @example
     * // Update or create a CourseProgress
     * const courseProgress = await prisma.courseProgress.upsert({
     *   create: {
     *     // ... data to create a CourseProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseProgress we want to update
     *   }
     * })
     */
    upsert<T extends CourseProgressUpsertArgs>(args: SelectSubset<T, CourseProgressUpsertArgs<ExtArgs>>): Prisma__CourseProgressClient<$Result.GetResult<Prisma.$CourseProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProgressCountArgs} args - Arguments to filter CourseProgresses to count.
     * @example
     * // Count the number of CourseProgresses
     * const count = await prisma.courseProgress.count({
     *   where: {
     *     // ... the filter for the CourseProgresses we want to count
     *   }
     * })
    **/
    count<T extends CourseProgressCountArgs>(
      args?: Subset<T, CourseProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseProgressAggregateArgs>(args: Subset<T, CourseProgressAggregateArgs>): Prisma.PrismaPromise<GetCourseProgressAggregateType<T>>

    /**
     * Group by CourseProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseProgressGroupByArgs['orderBy'] }
        : { orderBy?: CourseProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseProgress model
   */
  readonly fields: CourseProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lesson<T extends CourseLessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseLessonDefaultArgs<ExtArgs>>): Prisma__CourseLessonClient<$Result.GetResult<Prisma.$CourseLessonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseProgress model
   */ 
  interface CourseProgressFieldRefs {
    readonly id: FieldRef<"CourseProgress", 'String'>
    readonly userId: FieldRef<"CourseProgress", 'String'>
    readonly lessonId: FieldRef<"CourseProgress", 'String'>
    readonly completed: FieldRef<"CourseProgress", 'Boolean'>
    readonly watchTime: FieldRef<"CourseProgress", 'Int'>
    readonly completedAt: FieldRef<"CourseProgress", 'DateTime'>
    readonly createdAt: FieldRef<"CourseProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"CourseProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseProgress findUnique
   */
  export type CourseProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which CourseProgress to fetch.
     */
    where: CourseProgressWhereUniqueInput
  }

  /**
   * CourseProgress findUniqueOrThrow
   */
  export type CourseProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which CourseProgress to fetch.
     */
    where: CourseProgressWhereUniqueInput
  }

  /**
   * CourseProgress findFirst
   */
  export type CourseProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which CourseProgress to fetch.
     */
    where?: CourseProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseProgresses to fetch.
     */
    orderBy?: CourseProgressOrderByWithRelationInput | CourseProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseProgresses.
     */
    cursor?: CourseProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseProgresses.
     */
    distinct?: CourseProgressScalarFieldEnum | CourseProgressScalarFieldEnum[]
  }

  /**
   * CourseProgress findFirstOrThrow
   */
  export type CourseProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which CourseProgress to fetch.
     */
    where?: CourseProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseProgresses to fetch.
     */
    orderBy?: CourseProgressOrderByWithRelationInput | CourseProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseProgresses.
     */
    cursor?: CourseProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseProgresses.
     */
    distinct?: CourseProgressScalarFieldEnum | CourseProgressScalarFieldEnum[]
  }

  /**
   * CourseProgress findMany
   */
  export type CourseProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which CourseProgresses to fetch.
     */
    where?: CourseProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseProgresses to fetch.
     */
    orderBy?: CourseProgressOrderByWithRelationInput | CourseProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseProgresses.
     */
    cursor?: CourseProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseProgresses.
     */
    skip?: number
    distinct?: CourseProgressScalarFieldEnum | CourseProgressScalarFieldEnum[]
  }

  /**
   * CourseProgress create
   */
  export type CourseProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseProgress.
     */
    data: XOR<CourseProgressCreateInput, CourseProgressUncheckedCreateInput>
  }

  /**
   * CourseProgress createMany
   */
  export type CourseProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseProgresses.
     */
    data: CourseProgressCreateManyInput | CourseProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseProgress createManyAndReturn
   */
  export type CourseProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseProgresses.
     */
    data: CourseProgressCreateManyInput | CourseProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseProgress update
   */
  export type CourseProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseProgress.
     */
    data: XOR<CourseProgressUpdateInput, CourseProgressUncheckedUpdateInput>
    /**
     * Choose, which CourseProgress to update.
     */
    where: CourseProgressWhereUniqueInput
  }

  /**
   * CourseProgress updateMany
   */
  export type CourseProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseProgresses.
     */
    data: XOR<CourseProgressUpdateManyMutationInput, CourseProgressUncheckedUpdateManyInput>
    /**
     * Filter which CourseProgresses to update
     */
    where?: CourseProgressWhereInput
  }

  /**
   * CourseProgress upsert
   */
  export type CourseProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseProgress to update in case it exists.
     */
    where: CourseProgressWhereUniqueInput
    /**
     * In case the CourseProgress found by the `where` argument doesn't exist, create a new CourseProgress with this data.
     */
    create: XOR<CourseProgressCreateInput, CourseProgressUncheckedCreateInput>
    /**
     * In case the CourseProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseProgressUpdateInput, CourseProgressUncheckedUpdateInput>
  }

  /**
   * CourseProgress delete
   */
  export type CourseProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
    /**
     * Filter which CourseProgress to delete.
     */
    where: CourseProgressWhereUniqueInput
  }

  /**
   * CourseProgress deleteMany
   */
  export type CourseProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseProgresses to delete
     */
    where?: CourseProgressWhereInput
  }

  /**
   * CourseProgress without action
   */
  export type CourseProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseProgress
     */
    select?: CourseProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseProgressInclude<ExtArgs> | null
  }


  /**
   * Model CourseEnrollment
   */

  export type AggregateCourseEnrollment = {
    _count: CourseEnrollmentCountAggregateOutputType | null
    _avg: CourseEnrollmentAvgAggregateOutputType | null
    _sum: CourseEnrollmentSumAggregateOutputType | null
    _min: CourseEnrollmentMinAggregateOutputType | null
    _max: CourseEnrollmentMaxAggregateOutputType | null
  }

  export type CourseEnrollmentAvgAggregateOutputType = {
    progress: number | null
  }

  export type CourseEnrollmentSumAggregateOutputType = {
    progress: number | null
  }

  export type CourseEnrollmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    enrolledAt: Date | null
    completedAt: Date | null
    progress: number | null
  }

  export type CourseEnrollmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    enrolledAt: Date | null
    completedAt: Date | null
    progress: number | null
  }

  export type CourseEnrollmentCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    enrolledAt: number
    completedAt: number
    progress: number
    _all: number
  }


  export type CourseEnrollmentAvgAggregateInputType = {
    progress?: true
  }

  export type CourseEnrollmentSumAggregateInputType = {
    progress?: true
  }

  export type CourseEnrollmentMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrolledAt?: true
    completedAt?: true
    progress?: true
  }

  export type CourseEnrollmentMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrolledAt?: true
    completedAt?: true
    progress?: true
  }

  export type CourseEnrollmentCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrolledAt?: true
    completedAt?: true
    progress?: true
    _all?: true
  }

  export type CourseEnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseEnrollment to aggregate.
     */
    where?: CourseEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseEnrollments to fetch.
     */
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseEnrollments
    **/
    _count?: true | CourseEnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseEnrollmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseEnrollmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseEnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseEnrollmentMaxAggregateInputType
  }

  export type GetCourseEnrollmentAggregateType<T extends CourseEnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseEnrollment[P]>
      : GetScalarType<T[P], AggregateCourseEnrollment[P]>
  }




  export type CourseEnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseEnrollmentWhereInput
    orderBy?: CourseEnrollmentOrderByWithAggregationInput | CourseEnrollmentOrderByWithAggregationInput[]
    by: CourseEnrollmentScalarFieldEnum[] | CourseEnrollmentScalarFieldEnum
    having?: CourseEnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseEnrollmentCountAggregateInputType | true
    _avg?: CourseEnrollmentAvgAggregateInputType
    _sum?: CourseEnrollmentSumAggregateInputType
    _min?: CourseEnrollmentMinAggregateInputType
    _max?: CourseEnrollmentMaxAggregateInputType
  }

  export type CourseEnrollmentGroupByOutputType = {
    id: string
    userId: string
    courseId: string
    enrolledAt: Date
    completedAt: Date | null
    progress: number
    _count: CourseEnrollmentCountAggregateOutputType | null
    _avg: CourseEnrollmentAvgAggregateOutputType | null
    _sum: CourseEnrollmentSumAggregateOutputType | null
    _min: CourseEnrollmentMinAggregateOutputType | null
    _max: CourseEnrollmentMaxAggregateOutputType | null
  }

  type GetCourseEnrollmentGroupByPayload<T extends CourseEnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseEnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseEnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseEnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], CourseEnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type CourseEnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    progress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseEnrollment"]>

  export type CourseEnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    progress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseEnrollment"]>

  export type CourseEnrollmentSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    progress?: boolean
  }

  export type CourseEnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseEnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseEnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseEnrollment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      courseId: string
      enrolledAt: Date
      completedAt: Date | null
      progress: number
    }, ExtArgs["result"]["courseEnrollment"]>
    composites: {}
  }

  type CourseEnrollmentGetPayload<S extends boolean | null | undefined | CourseEnrollmentDefaultArgs> = $Result.GetResult<Prisma.$CourseEnrollmentPayload, S>

  type CourseEnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseEnrollmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseEnrollmentCountAggregateInputType | true
    }

  export interface CourseEnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseEnrollment'], meta: { name: 'CourseEnrollment' } }
    /**
     * Find zero or one CourseEnrollment that matches the filter.
     * @param {CourseEnrollmentFindUniqueArgs} args - Arguments to find a CourseEnrollment
     * @example
     * // Get one CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseEnrollmentFindUniqueArgs>(args: SelectSubset<T, CourseEnrollmentFindUniqueArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseEnrollment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseEnrollmentFindUniqueOrThrowArgs} args - Arguments to find a CourseEnrollment
     * @example
     * // Get one CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseEnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseEnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseEnrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentFindFirstArgs} args - Arguments to find a CourseEnrollment
     * @example
     * // Get one CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseEnrollmentFindFirstArgs>(args?: SelectSubset<T, CourseEnrollmentFindFirstArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseEnrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentFindFirstOrThrowArgs} args - Arguments to find a CourseEnrollment
     * @example
     * // Get one CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseEnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseEnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollment.findMany()
     * 
     * // Get first 10 CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseEnrollmentWithIdOnly = await prisma.courseEnrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseEnrollmentFindManyArgs>(args?: SelectSubset<T, CourseEnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseEnrollment.
     * @param {CourseEnrollmentCreateArgs} args - Arguments to create a CourseEnrollment.
     * @example
     * // Create one CourseEnrollment
     * const CourseEnrollment = await prisma.courseEnrollment.create({
     *   data: {
     *     // ... data to create a CourseEnrollment
     *   }
     * })
     * 
     */
    create<T extends CourseEnrollmentCreateArgs>(args: SelectSubset<T, CourseEnrollmentCreateArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseEnrollments.
     * @param {CourseEnrollmentCreateManyArgs} args - Arguments to create many CourseEnrollments.
     * @example
     * // Create many CourseEnrollments
     * const courseEnrollment = await prisma.courseEnrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseEnrollmentCreateManyArgs>(args?: SelectSubset<T, CourseEnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseEnrollments and returns the data saved in the database.
     * @param {CourseEnrollmentCreateManyAndReturnArgs} args - Arguments to create many CourseEnrollments.
     * @example
     * // Create many CourseEnrollments
     * const courseEnrollment = await prisma.courseEnrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseEnrollments and only return the `id`
     * const courseEnrollmentWithIdOnly = await prisma.courseEnrollment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseEnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseEnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseEnrollment.
     * @param {CourseEnrollmentDeleteArgs} args - Arguments to delete one CourseEnrollment.
     * @example
     * // Delete one CourseEnrollment
     * const CourseEnrollment = await prisma.courseEnrollment.delete({
     *   where: {
     *     // ... filter to delete one CourseEnrollment
     *   }
     * })
     * 
     */
    delete<T extends CourseEnrollmentDeleteArgs>(args: SelectSubset<T, CourseEnrollmentDeleteArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseEnrollment.
     * @param {CourseEnrollmentUpdateArgs} args - Arguments to update one CourseEnrollment.
     * @example
     * // Update one CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseEnrollmentUpdateArgs>(args: SelectSubset<T, CourseEnrollmentUpdateArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseEnrollments.
     * @param {CourseEnrollmentDeleteManyArgs} args - Arguments to filter CourseEnrollments to delete.
     * @example
     * // Delete a few CourseEnrollments
     * const { count } = await prisma.courseEnrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseEnrollmentDeleteManyArgs>(args?: SelectSubset<T, CourseEnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseEnrollments
     * const courseEnrollment = await prisma.courseEnrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseEnrollmentUpdateManyArgs>(args: SelectSubset<T, CourseEnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseEnrollment.
     * @param {CourseEnrollmentUpsertArgs} args - Arguments to update or create a CourseEnrollment.
     * @example
     * // Update or create a CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.upsert({
     *   create: {
     *     // ... data to create a CourseEnrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseEnrollment we want to update
     *   }
     * })
     */
    upsert<T extends CourseEnrollmentUpsertArgs>(args: SelectSubset<T, CourseEnrollmentUpsertArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentCountArgs} args - Arguments to filter CourseEnrollments to count.
     * @example
     * // Count the number of CourseEnrollments
     * const count = await prisma.courseEnrollment.count({
     *   where: {
     *     // ... the filter for the CourseEnrollments we want to count
     *   }
     * })
    **/
    count<T extends CourseEnrollmentCountArgs>(
      args?: Subset<T, CourseEnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseEnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseEnrollmentAggregateArgs>(args: Subset<T, CourseEnrollmentAggregateArgs>): Prisma.PrismaPromise<GetCourseEnrollmentAggregateType<T>>

    /**
     * Group by CourseEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseEnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseEnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: CourseEnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseEnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseEnrollment model
   */
  readonly fields: CourseEnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseEnrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseEnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseEnrollment model
   */ 
  interface CourseEnrollmentFieldRefs {
    readonly id: FieldRef<"CourseEnrollment", 'String'>
    readonly userId: FieldRef<"CourseEnrollment", 'String'>
    readonly courseId: FieldRef<"CourseEnrollment", 'String'>
    readonly enrolledAt: FieldRef<"CourseEnrollment", 'DateTime'>
    readonly completedAt: FieldRef<"CourseEnrollment", 'DateTime'>
    readonly progress: FieldRef<"CourseEnrollment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CourseEnrollment findUnique
   */
  export type CourseEnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which CourseEnrollment to fetch.
     */
    where: CourseEnrollmentWhereUniqueInput
  }

  /**
   * CourseEnrollment findUniqueOrThrow
   */
  export type CourseEnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which CourseEnrollment to fetch.
     */
    where: CourseEnrollmentWhereUniqueInput
  }

  /**
   * CourseEnrollment findFirst
   */
  export type CourseEnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which CourseEnrollment to fetch.
     */
    where?: CourseEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseEnrollments to fetch.
     */
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseEnrollments.
     */
    cursor?: CourseEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseEnrollments.
     */
    distinct?: CourseEnrollmentScalarFieldEnum | CourseEnrollmentScalarFieldEnum[]
  }

  /**
   * CourseEnrollment findFirstOrThrow
   */
  export type CourseEnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which CourseEnrollment to fetch.
     */
    where?: CourseEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseEnrollments to fetch.
     */
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseEnrollments.
     */
    cursor?: CourseEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseEnrollments.
     */
    distinct?: CourseEnrollmentScalarFieldEnum | CourseEnrollmentScalarFieldEnum[]
  }

  /**
   * CourseEnrollment findMany
   */
  export type CourseEnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which CourseEnrollments to fetch.
     */
    where?: CourseEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseEnrollments to fetch.
     */
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseEnrollments.
     */
    cursor?: CourseEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseEnrollments.
     */
    skip?: number
    distinct?: CourseEnrollmentScalarFieldEnum | CourseEnrollmentScalarFieldEnum[]
  }

  /**
   * CourseEnrollment create
   */
  export type CourseEnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseEnrollment.
     */
    data: XOR<CourseEnrollmentCreateInput, CourseEnrollmentUncheckedCreateInput>
  }

  /**
   * CourseEnrollment createMany
   */
  export type CourseEnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseEnrollments.
     */
    data: CourseEnrollmentCreateManyInput | CourseEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseEnrollment createManyAndReturn
   */
  export type CourseEnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseEnrollments.
     */
    data: CourseEnrollmentCreateManyInput | CourseEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseEnrollment update
   */
  export type CourseEnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseEnrollment.
     */
    data: XOR<CourseEnrollmentUpdateInput, CourseEnrollmentUncheckedUpdateInput>
    /**
     * Choose, which CourseEnrollment to update.
     */
    where: CourseEnrollmentWhereUniqueInput
  }

  /**
   * CourseEnrollment updateMany
   */
  export type CourseEnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseEnrollments.
     */
    data: XOR<CourseEnrollmentUpdateManyMutationInput, CourseEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which CourseEnrollments to update
     */
    where?: CourseEnrollmentWhereInput
  }

  /**
   * CourseEnrollment upsert
   */
  export type CourseEnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseEnrollment to update in case it exists.
     */
    where: CourseEnrollmentWhereUniqueInput
    /**
     * In case the CourseEnrollment found by the `where` argument doesn't exist, create a new CourseEnrollment with this data.
     */
    create: XOR<CourseEnrollmentCreateInput, CourseEnrollmentUncheckedCreateInput>
    /**
     * In case the CourseEnrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseEnrollmentUpdateInput, CourseEnrollmentUncheckedUpdateInput>
  }

  /**
   * CourseEnrollment delete
   */
  export type CourseEnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter which CourseEnrollment to delete.
     */
    where: CourseEnrollmentWhereUniqueInput
  }

  /**
   * CourseEnrollment deleteMany
   */
  export type CourseEnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseEnrollments to delete
     */
    where?: CourseEnrollmentWhereInput
  }

  /**
   * CourseEnrollment without action
   */
  export type CourseEnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model PostAnalytics
   */

  export type AggregatePostAnalytics = {
    _count: PostAnalyticsCountAggregateOutputType | null
    _avg: PostAnalyticsAvgAggregateOutputType | null
    _sum: PostAnalyticsSumAggregateOutputType | null
    _min: PostAnalyticsMinAggregateOutputType | null
    _max: PostAnalyticsMaxAggregateOutputType | null
  }

  export type PostAnalyticsAvgAggregateOutputType = {
    views: number | null
    uniqueViews: number | null
    shares: number | null
    avgTimeOnPage: number | null
    bounceRate: number | null
  }

  export type PostAnalyticsSumAggregateOutputType = {
    views: number | null
    uniqueViews: number | null
    shares: number | null
    avgTimeOnPage: number | null
    bounceRate: number | null
  }

  export type PostAnalyticsMinAggregateOutputType = {
    id: string | null
    postId: string | null
    date: Date | null
    views: number | null
    uniqueViews: number | null
    shares: number | null
    avgTimeOnPage: number | null
    bounceRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostAnalyticsMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    date: Date | null
    views: number | null
    uniqueViews: number | null
    shares: number | null
    avgTimeOnPage: number | null
    bounceRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostAnalyticsCountAggregateOutputType = {
    id: number
    postId: number
    date: number
    views: number
    uniqueViews: number
    shares: number
    avgTimeOnPage: number
    bounceRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostAnalyticsAvgAggregateInputType = {
    views?: true
    uniqueViews?: true
    shares?: true
    avgTimeOnPage?: true
    bounceRate?: true
  }

  export type PostAnalyticsSumAggregateInputType = {
    views?: true
    uniqueViews?: true
    shares?: true
    avgTimeOnPage?: true
    bounceRate?: true
  }

  export type PostAnalyticsMinAggregateInputType = {
    id?: true
    postId?: true
    date?: true
    views?: true
    uniqueViews?: true
    shares?: true
    avgTimeOnPage?: true
    bounceRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostAnalyticsMaxAggregateInputType = {
    id?: true
    postId?: true
    date?: true
    views?: true
    uniqueViews?: true
    shares?: true
    avgTimeOnPage?: true
    bounceRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostAnalyticsCountAggregateInputType = {
    id?: true
    postId?: true
    date?: true
    views?: true
    uniqueViews?: true
    shares?: true
    avgTimeOnPage?: true
    bounceRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostAnalytics to aggregate.
     */
    where?: PostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAnalytics to fetch.
     */
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostAnalytics
    **/
    _count?: true | PostAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostAnalyticsMaxAggregateInputType
  }

  export type GetPostAnalyticsAggregateType<T extends PostAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregatePostAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostAnalytics[P]>
      : GetScalarType<T[P], AggregatePostAnalytics[P]>
  }




  export type PostAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostAnalyticsWhereInput
    orderBy?: PostAnalyticsOrderByWithAggregationInput | PostAnalyticsOrderByWithAggregationInput[]
    by: PostAnalyticsScalarFieldEnum[] | PostAnalyticsScalarFieldEnum
    having?: PostAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostAnalyticsCountAggregateInputType | true
    _avg?: PostAnalyticsAvgAggregateInputType
    _sum?: PostAnalyticsSumAggregateInputType
    _min?: PostAnalyticsMinAggregateInputType
    _max?: PostAnalyticsMaxAggregateInputType
  }

  export type PostAnalyticsGroupByOutputType = {
    id: string
    postId: string
    date: Date
    views: number
    uniqueViews: number
    shares: number
    avgTimeOnPage: number
    bounceRate: number
    createdAt: Date
    updatedAt: Date
    _count: PostAnalyticsCountAggregateOutputType | null
    _avg: PostAnalyticsAvgAggregateOutputType | null
    _sum: PostAnalyticsSumAggregateOutputType | null
    _min: PostAnalyticsMinAggregateOutputType | null
    _max: PostAnalyticsMaxAggregateOutputType | null
  }

  type GetPostAnalyticsGroupByPayload<T extends PostAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], PostAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type PostAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    date?: boolean
    views?: boolean
    uniqueViews?: boolean
    shares?: boolean
    avgTimeOnPage?: boolean
    bounceRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postAnalytics"]>

  export type PostAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    date?: boolean
    views?: boolean
    uniqueViews?: boolean
    shares?: boolean
    avgTimeOnPage?: boolean
    bounceRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postAnalytics"]>

  export type PostAnalyticsSelectScalar = {
    id?: boolean
    postId?: boolean
    date?: boolean
    views?: boolean
    uniqueViews?: boolean
    shares?: boolean
    avgTimeOnPage?: boolean
    bounceRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type PostAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }

  export type $PostAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostAnalytics"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      date: Date
      views: number
      uniqueViews: number
      shares: number
      avgTimeOnPage: number
      bounceRate: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["postAnalytics"]>
    composites: {}
  }

  type PostAnalyticsGetPayload<S extends boolean | null | undefined | PostAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$PostAnalyticsPayload, S>

  type PostAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostAnalyticsCountAggregateInputType | true
    }

  export interface PostAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostAnalytics'], meta: { name: 'PostAnalytics' } }
    /**
     * Find zero or one PostAnalytics that matches the filter.
     * @param {PostAnalyticsFindUniqueArgs} args - Arguments to find a PostAnalytics
     * @example
     * // Get one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostAnalyticsFindUniqueArgs>(args: SelectSubset<T, PostAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a PostAnalytics
     * @example
     * // Get one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, PostAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsFindFirstArgs} args - Arguments to find a PostAnalytics
     * @example
     * // Get one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostAnalyticsFindFirstArgs>(args?: SelectSubset<T, PostAnalyticsFindFirstArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsFindFirstOrThrowArgs} args - Arguments to find a PostAnalytics
     * @example
     * // Get one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, PostAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findMany()
     * 
     * // Get first 10 PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postAnalyticsWithIdOnly = await prisma.postAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostAnalyticsFindManyArgs>(args?: SelectSubset<T, PostAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostAnalytics.
     * @param {PostAnalyticsCreateArgs} args - Arguments to create a PostAnalytics.
     * @example
     * // Create one PostAnalytics
     * const PostAnalytics = await prisma.postAnalytics.create({
     *   data: {
     *     // ... data to create a PostAnalytics
     *   }
     * })
     * 
     */
    create<T extends PostAnalyticsCreateArgs>(args: SelectSubset<T, PostAnalyticsCreateArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostAnalytics.
     * @param {PostAnalyticsCreateManyArgs} args - Arguments to create many PostAnalytics.
     * @example
     * // Create many PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostAnalyticsCreateManyArgs>(args?: SelectSubset<T, PostAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostAnalytics and returns the data saved in the database.
     * @param {PostAnalyticsCreateManyAndReturnArgs} args - Arguments to create many PostAnalytics.
     * @example
     * // Create many PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostAnalytics and only return the `id`
     * const postAnalyticsWithIdOnly = await prisma.postAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, PostAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostAnalytics.
     * @param {PostAnalyticsDeleteArgs} args - Arguments to delete one PostAnalytics.
     * @example
     * // Delete one PostAnalytics
     * const PostAnalytics = await prisma.postAnalytics.delete({
     *   where: {
     *     // ... filter to delete one PostAnalytics
     *   }
     * })
     * 
     */
    delete<T extends PostAnalyticsDeleteArgs>(args: SelectSubset<T, PostAnalyticsDeleteArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostAnalytics.
     * @param {PostAnalyticsUpdateArgs} args - Arguments to update one PostAnalytics.
     * @example
     * // Update one PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostAnalyticsUpdateArgs>(args: SelectSubset<T, PostAnalyticsUpdateArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostAnalytics.
     * @param {PostAnalyticsDeleteManyArgs} args - Arguments to filter PostAnalytics to delete.
     * @example
     * // Delete a few PostAnalytics
     * const { count } = await prisma.postAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostAnalyticsDeleteManyArgs>(args?: SelectSubset<T, PostAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostAnalyticsUpdateManyArgs>(args: SelectSubset<T, PostAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostAnalytics.
     * @param {PostAnalyticsUpsertArgs} args - Arguments to update or create a PostAnalytics.
     * @example
     * // Update or create a PostAnalytics
     * const postAnalytics = await prisma.postAnalytics.upsert({
     *   create: {
     *     // ... data to create a PostAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends PostAnalyticsUpsertArgs>(args: SelectSubset<T, PostAnalyticsUpsertArgs<ExtArgs>>): Prisma__PostAnalyticsClient<$Result.GetResult<Prisma.$PostAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsCountArgs} args - Arguments to filter PostAnalytics to count.
     * @example
     * // Count the number of PostAnalytics
     * const count = await prisma.postAnalytics.count({
     *   where: {
     *     // ... the filter for the PostAnalytics we want to count
     *   }
     * })
    **/
    count<T extends PostAnalyticsCountArgs>(
      args?: Subset<T, PostAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAnalyticsAggregateArgs>(args: Subset<T, PostAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetPostAnalyticsAggregateType<T>>

    /**
     * Group by PostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: PostAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostAnalytics model
   */
  readonly fields: PostAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostAnalytics model
   */ 
  interface PostAnalyticsFieldRefs {
    readonly id: FieldRef<"PostAnalytics", 'String'>
    readonly postId: FieldRef<"PostAnalytics", 'String'>
    readonly date: FieldRef<"PostAnalytics", 'DateTime'>
    readonly views: FieldRef<"PostAnalytics", 'Int'>
    readonly uniqueViews: FieldRef<"PostAnalytics", 'Int'>
    readonly shares: FieldRef<"PostAnalytics", 'Int'>
    readonly avgTimeOnPage: FieldRef<"PostAnalytics", 'Int'>
    readonly bounceRate: FieldRef<"PostAnalytics", 'Float'>
    readonly createdAt: FieldRef<"PostAnalytics", 'DateTime'>
    readonly updatedAt: FieldRef<"PostAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostAnalytics findUnique
   */
  export type PostAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where: PostAnalyticsWhereUniqueInput
  }

  /**
   * PostAnalytics findUniqueOrThrow
   */
  export type PostAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where: PostAnalyticsWhereUniqueInput
  }

  /**
   * PostAnalytics findFirst
   */
  export type PostAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where?: PostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAnalytics to fetch.
     */
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostAnalytics.
     */
    cursor?: PostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostAnalytics.
     */
    distinct?: PostAnalyticsScalarFieldEnum | PostAnalyticsScalarFieldEnum[]
  }

  /**
   * PostAnalytics findFirstOrThrow
   */
  export type PostAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where?: PostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAnalytics to fetch.
     */
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostAnalytics.
     */
    cursor?: PostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostAnalytics.
     */
    distinct?: PostAnalyticsScalarFieldEnum | PostAnalyticsScalarFieldEnum[]
  }

  /**
   * PostAnalytics findMany
   */
  export type PostAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PostAnalytics to fetch.
     */
    where?: PostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAnalytics to fetch.
     */
    orderBy?: PostAnalyticsOrderByWithRelationInput | PostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostAnalytics.
     */
    cursor?: PostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAnalytics.
     */
    skip?: number
    distinct?: PostAnalyticsScalarFieldEnum | PostAnalyticsScalarFieldEnum[]
  }

  /**
   * PostAnalytics create
   */
  export type PostAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a PostAnalytics.
     */
    data: XOR<PostAnalyticsCreateInput, PostAnalyticsUncheckedCreateInput>
  }

  /**
   * PostAnalytics createMany
   */
  export type PostAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostAnalytics.
     */
    data: PostAnalyticsCreateManyInput | PostAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostAnalytics createManyAndReturn
   */
  export type PostAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostAnalytics.
     */
    data: PostAnalyticsCreateManyInput | PostAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostAnalytics update
   */
  export type PostAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a PostAnalytics.
     */
    data: XOR<PostAnalyticsUpdateInput, PostAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which PostAnalytics to update.
     */
    where: PostAnalyticsWhereUniqueInput
  }

  /**
   * PostAnalytics updateMany
   */
  export type PostAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostAnalytics.
     */
    data: XOR<PostAnalyticsUpdateManyMutationInput, PostAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which PostAnalytics to update
     */
    where?: PostAnalyticsWhereInput
  }

  /**
   * PostAnalytics upsert
   */
  export type PostAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the PostAnalytics to update in case it exists.
     */
    where: PostAnalyticsWhereUniqueInput
    /**
     * In case the PostAnalytics found by the `where` argument doesn't exist, create a new PostAnalytics with this data.
     */
    create: XOR<PostAnalyticsCreateInput, PostAnalyticsUncheckedCreateInput>
    /**
     * In case the PostAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostAnalyticsUpdateInput, PostAnalyticsUncheckedUpdateInput>
  }

  /**
   * PostAnalytics delete
   */
  export type PostAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which PostAnalytics to delete.
     */
    where: PostAnalyticsWhereUniqueInput
  }

  /**
   * PostAnalytics deleteMany
   */
  export type PostAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostAnalytics to delete
     */
    where?: PostAnalyticsWhereInput
  }

  /**
   * PostAnalytics without action
   */
  export type PostAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAnalytics
     */
    select?: PostAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model NewsletterSubscriber
   */

  export type AggregateNewsletterSubscriber = {
    _count: NewsletterSubscriberCountAggregateOutputType | null
    _min: NewsletterSubscriberMinAggregateOutputType | null
    _max: NewsletterSubscriberMaxAggregateOutputType | null
  }

  export type NewsletterSubscriberMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsletterSubscriberMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsletterSubscriberCountAggregateOutputType = {
    id: number
    email: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NewsletterSubscriberMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsletterSubscriberMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsletterSubscriberCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NewsletterSubscriberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsletterSubscriber to aggregate.
     */
    where?: NewsletterSubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscribers to fetch.
     */
    orderBy?: NewsletterSubscriberOrderByWithRelationInput | NewsletterSubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsletterSubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsletterSubscribers
    **/
    _count?: true | NewsletterSubscriberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsletterSubscriberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsletterSubscriberMaxAggregateInputType
  }

  export type GetNewsletterSubscriberAggregateType<T extends NewsletterSubscriberAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsletterSubscriber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsletterSubscriber[P]>
      : GetScalarType<T[P], AggregateNewsletterSubscriber[P]>
  }




  export type NewsletterSubscriberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsletterSubscriberWhereInput
    orderBy?: NewsletterSubscriberOrderByWithAggregationInput | NewsletterSubscriberOrderByWithAggregationInput[]
    by: NewsletterSubscriberScalarFieldEnum[] | NewsletterSubscriberScalarFieldEnum
    having?: NewsletterSubscriberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsletterSubscriberCountAggregateInputType | true
    _min?: NewsletterSubscriberMinAggregateInputType
    _max?: NewsletterSubscriberMaxAggregateInputType
  }

  export type NewsletterSubscriberGroupByOutputType = {
    id: string
    email: string
    name: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: NewsletterSubscriberCountAggregateOutputType | null
    _min: NewsletterSubscriberMinAggregateOutputType | null
    _max: NewsletterSubscriberMaxAggregateOutputType | null
  }

  type GetNewsletterSubscriberGroupByPayload<T extends NewsletterSubscriberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsletterSubscriberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsletterSubscriberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsletterSubscriberGroupByOutputType[P]>
            : GetScalarType<T[P], NewsletterSubscriberGroupByOutputType[P]>
        }
      >
    >


  export type NewsletterSubscriberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptions?: boolean | NewsletterSubscriber$subscriptionsArgs<ExtArgs>
    _count?: boolean | NewsletterSubscriberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsletterSubscriber"]>

  export type NewsletterSubscriberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["newsletterSubscriber"]>

  export type NewsletterSubscriberSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NewsletterSubscriberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | NewsletterSubscriber$subscriptionsArgs<ExtArgs>
    _count?: boolean | NewsletterSubscriberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NewsletterSubscriberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NewsletterSubscriberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsletterSubscriber"
    objects: {
      subscriptions: Prisma.$NewsletterSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["newsletterSubscriber"]>
    composites: {}
  }

  type NewsletterSubscriberGetPayload<S extends boolean | null | undefined | NewsletterSubscriberDefaultArgs> = $Result.GetResult<Prisma.$NewsletterSubscriberPayload, S>

  type NewsletterSubscriberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsletterSubscriberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsletterSubscriberCountAggregateInputType | true
    }

  export interface NewsletterSubscriberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsletterSubscriber'], meta: { name: 'NewsletterSubscriber' } }
    /**
     * Find zero or one NewsletterSubscriber that matches the filter.
     * @param {NewsletterSubscriberFindUniqueArgs} args - Arguments to find a NewsletterSubscriber
     * @example
     * // Get one NewsletterSubscriber
     * const newsletterSubscriber = await prisma.newsletterSubscriber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsletterSubscriberFindUniqueArgs>(args: SelectSubset<T, NewsletterSubscriberFindUniqueArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsletterSubscriber that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsletterSubscriberFindUniqueOrThrowArgs} args - Arguments to find a NewsletterSubscriber
     * @example
     * // Get one NewsletterSubscriber
     * const newsletterSubscriber = await prisma.newsletterSubscriber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsletterSubscriberFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsletterSubscriberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsletterSubscriber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriberFindFirstArgs} args - Arguments to find a NewsletterSubscriber
     * @example
     * // Get one NewsletterSubscriber
     * const newsletterSubscriber = await prisma.newsletterSubscriber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsletterSubscriberFindFirstArgs>(args?: SelectSubset<T, NewsletterSubscriberFindFirstArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsletterSubscriber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriberFindFirstOrThrowArgs} args - Arguments to find a NewsletterSubscriber
     * @example
     * // Get one NewsletterSubscriber
     * const newsletterSubscriber = await prisma.newsletterSubscriber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsletterSubscriberFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsletterSubscriberFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsletterSubscribers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsletterSubscribers
     * const newsletterSubscribers = await prisma.newsletterSubscriber.findMany()
     * 
     * // Get first 10 NewsletterSubscribers
     * const newsletterSubscribers = await prisma.newsletterSubscriber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsletterSubscriberWithIdOnly = await prisma.newsletterSubscriber.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsletterSubscriberFindManyArgs>(args?: SelectSubset<T, NewsletterSubscriberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsletterSubscriber.
     * @param {NewsletterSubscriberCreateArgs} args - Arguments to create a NewsletterSubscriber.
     * @example
     * // Create one NewsletterSubscriber
     * const NewsletterSubscriber = await prisma.newsletterSubscriber.create({
     *   data: {
     *     // ... data to create a NewsletterSubscriber
     *   }
     * })
     * 
     */
    create<T extends NewsletterSubscriberCreateArgs>(args: SelectSubset<T, NewsletterSubscriberCreateArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsletterSubscribers.
     * @param {NewsletterSubscriberCreateManyArgs} args - Arguments to create many NewsletterSubscribers.
     * @example
     * // Create many NewsletterSubscribers
     * const newsletterSubscriber = await prisma.newsletterSubscriber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsletterSubscriberCreateManyArgs>(args?: SelectSubset<T, NewsletterSubscriberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsletterSubscribers and returns the data saved in the database.
     * @param {NewsletterSubscriberCreateManyAndReturnArgs} args - Arguments to create many NewsletterSubscribers.
     * @example
     * // Create many NewsletterSubscribers
     * const newsletterSubscriber = await prisma.newsletterSubscriber.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsletterSubscribers and only return the `id`
     * const newsletterSubscriberWithIdOnly = await prisma.newsletterSubscriber.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsletterSubscriberCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsletterSubscriberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsletterSubscriber.
     * @param {NewsletterSubscriberDeleteArgs} args - Arguments to delete one NewsletterSubscriber.
     * @example
     * // Delete one NewsletterSubscriber
     * const NewsletterSubscriber = await prisma.newsletterSubscriber.delete({
     *   where: {
     *     // ... filter to delete one NewsletterSubscriber
     *   }
     * })
     * 
     */
    delete<T extends NewsletterSubscriberDeleteArgs>(args: SelectSubset<T, NewsletterSubscriberDeleteArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsletterSubscriber.
     * @param {NewsletterSubscriberUpdateArgs} args - Arguments to update one NewsletterSubscriber.
     * @example
     * // Update one NewsletterSubscriber
     * const newsletterSubscriber = await prisma.newsletterSubscriber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsletterSubscriberUpdateArgs>(args: SelectSubset<T, NewsletterSubscriberUpdateArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsletterSubscribers.
     * @param {NewsletterSubscriberDeleteManyArgs} args - Arguments to filter NewsletterSubscribers to delete.
     * @example
     * // Delete a few NewsletterSubscribers
     * const { count } = await prisma.newsletterSubscriber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsletterSubscriberDeleteManyArgs>(args?: SelectSubset<T, NewsletterSubscriberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsletterSubscribers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsletterSubscribers
     * const newsletterSubscriber = await prisma.newsletterSubscriber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsletterSubscriberUpdateManyArgs>(args: SelectSubset<T, NewsletterSubscriberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsletterSubscriber.
     * @param {NewsletterSubscriberUpsertArgs} args - Arguments to update or create a NewsletterSubscriber.
     * @example
     * // Update or create a NewsletterSubscriber
     * const newsletterSubscriber = await prisma.newsletterSubscriber.upsert({
     *   create: {
     *     // ... data to create a NewsletterSubscriber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsletterSubscriber we want to update
     *   }
     * })
     */
    upsert<T extends NewsletterSubscriberUpsertArgs>(args: SelectSubset<T, NewsletterSubscriberUpsertArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsletterSubscribers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriberCountArgs} args - Arguments to filter NewsletterSubscribers to count.
     * @example
     * // Count the number of NewsletterSubscribers
     * const count = await prisma.newsletterSubscriber.count({
     *   where: {
     *     // ... the filter for the NewsletterSubscribers we want to count
     *   }
     * })
    **/
    count<T extends NewsletterSubscriberCountArgs>(
      args?: Subset<T, NewsletterSubscriberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsletterSubscriberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsletterSubscriber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsletterSubscriberAggregateArgs>(args: Subset<T, NewsletterSubscriberAggregateArgs>): Prisma.PrismaPromise<GetNewsletterSubscriberAggregateType<T>>

    /**
     * Group by NewsletterSubscriber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsletterSubscriberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsletterSubscriberGroupByArgs['orderBy'] }
        : { orderBy?: NewsletterSubscriberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsletterSubscriberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsletterSubscriberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsletterSubscriber model
   */
  readonly fields: NewsletterSubscriberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsletterSubscriber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsletterSubscriberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends NewsletterSubscriber$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, NewsletterSubscriber$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsletterSubscriber model
   */ 
  interface NewsletterSubscriberFieldRefs {
    readonly id: FieldRef<"NewsletterSubscriber", 'String'>
    readonly email: FieldRef<"NewsletterSubscriber", 'String'>
    readonly name: FieldRef<"NewsletterSubscriber", 'String'>
    readonly active: FieldRef<"NewsletterSubscriber", 'Boolean'>
    readonly createdAt: FieldRef<"NewsletterSubscriber", 'DateTime'>
    readonly updatedAt: FieldRef<"NewsletterSubscriber", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsletterSubscriber findUnique
   */
  export type NewsletterSubscriberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriberInclude<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscriber to fetch.
     */
    where: NewsletterSubscriberWhereUniqueInput
  }

  /**
   * NewsletterSubscriber findUniqueOrThrow
   */
  export type NewsletterSubscriberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriberInclude<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscriber to fetch.
     */
    where: NewsletterSubscriberWhereUniqueInput
  }

  /**
   * NewsletterSubscriber findFirst
   */
  export type NewsletterSubscriberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriberInclude<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscriber to fetch.
     */
    where?: NewsletterSubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscribers to fetch.
     */
    orderBy?: NewsletterSubscriberOrderByWithRelationInput | NewsletterSubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsletterSubscribers.
     */
    cursor?: NewsletterSubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsletterSubscribers.
     */
    distinct?: NewsletterSubscriberScalarFieldEnum | NewsletterSubscriberScalarFieldEnum[]
  }

  /**
   * NewsletterSubscriber findFirstOrThrow
   */
  export type NewsletterSubscriberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriberInclude<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscriber to fetch.
     */
    where?: NewsletterSubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscribers to fetch.
     */
    orderBy?: NewsletterSubscriberOrderByWithRelationInput | NewsletterSubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsletterSubscribers.
     */
    cursor?: NewsletterSubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsletterSubscribers.
     */
    distinct?: NewsletterSubscriberScalarFieldEnum | NewsletterSubscriberScalarFieldEnum[]
  }

  /**
   * NewsletterSubscriber findMany
   */
  export type NewsletterSubscriberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriberInclude<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscribers to fetch.
     */
    where?: NewsletterSubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscribers to fetch.
     */
    orderBy?: NewsletterSubscriberOrderByWithRelationInput | NewsletterSubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsletterSubscribers.
     */
    cursor?: NewsletterSubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscribers.
     */
    skip?: number
    distinct?: NewsletterSubscriberScalarFieldEnum | NewsletterSubscriberScalarFieldEnum[]
  }

  /**
   * NewsletterSubscriber create
   */
  export type NewsletterSubscriberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriberInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsletterSubscriber.
     */
    data: XOR<NewsletterSubscriberCreateInput, NewsletterSubscriberUncheckedCreateInput>
  }

  /**
   * NewsletterSubscriber createMany
   */
  export type NewsletterSubscriberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsletterSubscribers.
     */
    data: NewsletterSubscriberCreateManyInput | NewsletterSubscriberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsletterSubscriber createManyAndReturn
   */
  export type NewsletterSubscriberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsletterSubscribers.
     */
    data: NewsletterSubscriberCreateManyInput | NewsletterSubscriberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsletterSubscriber update
   */
  export type NewsletterSubscriberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriberInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsletterSubscriber.
     */
    data: XOR<NewsletterSubscriberUpdateInput, NewsletterSubscriberUncheckedUpdateInput>
    /**
     * Choose, which NewsletterSubscriber to update.
     */
    where: NewsletterSubscriberWhereUniqueInput
  }

  /**
   * NewsletterSubscriber updateMany
   */
  export type NewsletterSubscriberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsletterSubscribers.
     */
    data: XOR<NewsletterSubscriberUpdateManyMutationInput, NewsletterSubscriberUncheckedUpdateManyInput>
    /**
     * Filter which NewsletterSubscribers to update
     */
    where?: NewsletterSubscriberWhereInput
  }

  /**
   * NewsletterSubscriber upsert
   */
  export type NewsletterSubscriberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriberInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsletterSubscriber to update in case it exists.
     */
    where: NewsletterSubscriberWhereUniqueInput
    /**
     * In case the NewsletterSubscriber found by the `where` argument doesn't exist, create a new NewsletterSubscriber with this data.
     */
    create: XOR<NewsletterSubscriberCreateInput, NewsletterSubscriberUncheckedCreateInput>
    /**
     * In case the NewsletterSubscriber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsletterSubscriberUpdateInput, NewsletterSubscriberUncheckedUpdateInput>
  }

  /**
   * NewsletterSubscriber delete
   */
  export type NewsletterSubscriberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriberInclude<ExtArgs> | null
    /**
     * Filter which NewsletterSubscriber to delete.
     */
    where: NewsletterSubscriberWhereUniqueInput
  }

  /**
   * NewsletterSubscriber deleteMany
   */
  export type NewsletterSubscriberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsletterSubscribers to delete
     */
    where?: NewsletterSubscriberWhereInput
  }

  /**
   * NewsletterSubscriber.subscriptions
   */
  export type NewsletterSubscriber$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriptionInclude<ExtArgs> | null
    where?: NewsletterSubscriptionWhereInput
    orderBy?: NewsletterSubscriptionOrderByWithRelationInput | NewsletterSubscriptionOrderByWithRelationInput[]
    cursor?: NewsletterSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsletterSubscriptionScalarFieldEnum | NewsletterSubscriptionScalarFieldEnum[]
  }

  /**
   * NewsletterSubscriber without action
   */
  export type NewsletterSubscriberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscriber
     */
    select?: NewsletterSubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriberInclude<ExtArgs> | null
  }


  /**
   * Model NewsletterSubscription
   */

  export type AggregateNewsletterSubscription = {
    _count: NewsletterSubscriptionCountAggregateOutputType | null
    _min: NewsletterSubscriptionMinAggregateOutputType | null
    _max: NewsletterSubscriptionMaxAggregateOutputType | null
  }

  export type NewsletterSubscriptionMinAggregateOutputType = {
    subscriberId: string | null
    categoryId: string | null
    createdAt: Date | null
  }

  export type NewsletterSubscriptionMaxAggregateOutputType = {
    subscriberId: string | null
    categoryId: string | null
    createdAt: Date | null
  }

  export type NewsletterSubscriptionCountAggregateOutputType = {
    subscriberId: number
    categoryId: number
    createdAt: number
    _all: number
  }


  export type NewsletterSubscriptionMinAggregateInputType = {
    subscriberId?: true
    categoryId?: true
    createdAt?: true
  }

  export type NewsletterSubscriptionMaxAggregateInputType = {
    subscriberId?: true
    categoryId?: true
    createdAt?: true
  }

  export type NewsletterSubscriptionCountAggregateInputType = {
    subscriberId?: true
    categoryId?: true
    createdAt?: true
    _all?: true
  }

  export type NewsletterSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsletterSubscription to aggregate.
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscriptions to fetch.
     */
    orderBy?: NewsletterSubscriptionOrderByWithRelationInput | NewsletterSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsletterSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsletterSubscriptions
    **/
    _count?: true | NewsletterSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsletterSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsletterSubscriptionMaxAggregateInputType
  }

  export type GetNewsletterSubscriptionAggregateType<T extends NewsletterSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsletterSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsletterSubscription[P]>
      : GetScalarType<T[P], AggregateNewsletterSubscription[P]>
  }




  export type NewsletterSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsletterSubscriptionWhereInput
    orderBy?: NewsletterSubscriptionOrderByWithAggregationInput | NewsletterSubscriptionOrderByWithAggregationInput[]
    by: NewsletterSubscriptionScalarFieldEnum[] | NewsletterSubscriptionScalarFieldEnum
    having?: NewsletterSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsletterSubscriptionCountAggregateInputType | true
    _min?: NewsletterSubscriptionMinAggregateInputType
    _max?: NewsletterSubscriptionMaxAggregateInputType
  }

  export type NewsletterSubscriptionGroupByOutputType = {
    subscriberId: string
    categoryId: string
    createdAt: Date
    _count: NewsletterSubscriptionCountAggregateOutputType | null
    _min: NewsletterSubscriptionMinAggregateOutputType | null
    _max: NewsletterSubscriptionMaxAggregateOutputType | null
  }

  type GetNewsletterSubscriptionGroupByPayload<T extends NewsletterSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsletterSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsletterSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsletterSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], NewsletterSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type NewsletterSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subscriberId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    subscriber?: boolean | NewsletterSubscriberDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsletterSubscription"]>

  export type NewsletterSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subscriberId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    subscriber?: boolean | NewsletterSubscriberDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsletterSubscription"]>

  export type NewsletterSubscriptionSelectScalar = {
    subscriberId?: boolean
    categoryId?: boolean
    createdAt?: boolean
  }

  export type NewsletterSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriber?: boolean | NewsletterSubscriberDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type NewsletterSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriber?: boolean | NewsletterSubscriberDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $NewsletterSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsletterSubscription"
    objects: {
      subscriber: Prisma.$NewsletterSubscriberPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      subscriberId: string
      categoryId: string
      createdAt: Date
    }, ExtArgs["result"]["newsletterSubscription"]>
    composites: {}
  }

  type NewsletterSubscriptionGetPayload<S extends boolean | null | undefined | NewsletterSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$NewsletterSubscriptionPayload, S>

  type NewsletterSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsletterSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsletterSubscriptionCountAggregateInputType | true
    }

  export interface NewsletterSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsletterSubscription'], meta: { name: 'NewsletterSubscription' } }
    /**
     * Find zero or one NewsletterSubscription that matches the filter.
     * @param {NewsletterSubscriptionFindUniqueArgs} args - Arguments to find a NewsletterSubscription
     * @example
     * // Get one NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsletterSubscriptionFindUniqueArgs>(args: SelectSubset<T, NewsletterSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsletterSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsletterSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a NewsletterSubscription
     * @example
     * // Get one NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsletterSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsletterSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsletterSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionFindFirstArgs} args - Arguments to find a NewsletterSubscription
     * @example
     * // Get one NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsletterSubscriptionFindFirstArgs>(args?: SelectSubset<T, NewsletterSubscriptionFindFirstArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsletterSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionFindFirstOrThrowArgs} args - Arguments to find a NewsletterSubscription
     * @example
     * // Get one NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsletterSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsletterSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsletterSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsletterSubscriptions
     * const newsletterSubscriptions = await prisma.newsletterSubscription.findMany()
     * 
     * // Get first 10 NewsletterSubscriptions
     * const newsletterSubscriptions = await prisma.newsletterSubscription.findMany({ take: 10 })
     * 
     * // Only select the `subscriberId`
     * const newsletterSubscriptionWithSubscriberIdOnly = await prisma.newsletterSubscription.findMany({ select: { subscriberId: true } })
     * 
     */
    findMany<T extends NewsletterSubscriptionFindManyArgs>(args?: SelectSubset<T, NewsletterSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsletterSubscription.
     * @param {NewsletterSubscriptionCreateArgs} args - Arguments to create a NewsletterSubscription.
     * @example
     * // Create one NewsletterSubscription
     * const NewsletterSubscription = await prisma.newsletterSubscription.create({
     *   data: {
     *     // ... data to create a NewsletterSubscription
     *   }
     * })
     * 
     */
    create<T extends NewsletterSubscriptionCreateArgs>(args: SelectSubset<T, NewsletterSubscriptionCreateArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsletterSubscriptions.
     * @param {NewsletterSubscriptionCreateManyArgs} args - Arguments to create many NewsletterSubscriptions.
     * @example
     * // Create many NewsletterSubscriptions
     * const newsletterSubscription = await prisma.newsletterSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsletterSubscriptionCreateManyArgs>(args?: SelectSubset<T, NewsletterSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsletterSubscriptions and returns the data saved in the database.
     * @param {NewsletterSubscriptionCreateManyAndReturnArgs} args - Arguments to create many NewsletterSubscriptions.
     * @example
     * // Create many NewsletterSubscriptions
     * const newsletterSubscription = await prisma.newsletterSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsletterSubscriptions and only return the `subscriberId`
     * const newsletterSubscriptionWithSubscriberIdOnly = await prisma.newsletterSubscription.createManyAndReturn({ 
     *   select: { subscriberId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsletterSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsletterSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsletterSubscription.
     * @param {NewsletterSubscriptionDeleteArgs} args - Arguments to delete one NewsletterSubscription.
     * @example
     * // Delete one NewsletterSubscription
     * const NewsletterSubscription = await prisma.newsletterSubscription.delete({
     *   where: {
     *     // ... filter to delete one NewsletterSubscription
     *   }
     * })
     * 
     */
    delete<T extends NewsletterSubscriptionDeleteArgs>(args: SelectSubset<T, NewsletterSubscriptionDeleteArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsletterSubscription.
     * @param {NewsletterSubscriptionUpdateArgs} args - Arguments to update one NewsletterSubscription.
     * @example
     * // Update one NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsletterSubscriptionUpdateArgs>(args: SelectSubset<T, NewsletterSubscriptionUpdateArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsletterSubscriptions.
     * @param {NewsletterSubscriptionDeleteManyArgs} args - Arguments to filter NewsletterSubscriptions to delete.
     * @example
     * // Delete a few NewsletterSubscriptions
     * const { count } = await prisma.newsletterSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsletterSubscriptionDeleteManyArgs>(args?: SelectSubset<T, NewsletterSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsletterSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsletterSubscriptions
     * const newsletterSubscription = await prisma.newsletterSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsletterSubscriptionUpdateManyArgs>(args: SelectSubset<T, NewsletterSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsletterSubscription.
     * @param {NewsletterSubscriptionUpsertArgs} args - Arguments to update or create a NewsletterSubscription.
     * @example
     * // Update or create a NewsletterSubscription
     * const newsletterSubscription = await prisma.newsletterSubscription.upsert({
     *   create: {
     *     // ... data to create a NewsletterSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsletterSubscription we want to update
     *   }
     * })
     */
    upsert<T extends NewsletterSubscriptionUpsertArgs>(args: SelectSubset<T, NewsletterSubscriptionUpsertArgs<ExtArgs>>): Prisma__NewsletterSubscriptionClient<$Result.GetResult<Prisma.$NewsletterSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsletterSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionCountArgs} args - Arguments to filter NewsletterSubscriptions to count.
     * @example
     * // Count the number of NewsletterSubscriptions
     * const count = await prisma.newsletterSubscription.count({
     *   where: {
     *     // ... the filter for the NewsletterSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends NewsletterSubscriptionCountArgs>(
      args?: Subset<T, NewsletterSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsletterSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsletterSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsletterSubscriptionAggregateArgs>(args: Subset<T, NewsletterSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetNewsletterSubscriptionAggregateType<T>>

    /**
     * Group by NewsletterSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsletterSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsletterSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: NewsletterSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsletterSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsletterSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsletterSubscription model
   */
  readonly fields: NewsletterSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsletterSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsletterSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriber<T extends NewsletterSubscriberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsletterSubscriberDefaultArgs<ExtArgs>>): Prisma__NewsletterSubscriberClient<$Result.GetResult<Prisma.$NewsletterSubscriberPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsletterSubscription model
   */ 
  interface NewsletterSubscriptionFieldRefs {
    readonly subscriberId: FieldRef<"NewsletterSubscription", 'String'>
    readonly categoryId: FieldRef<"NewsletterSubscription", 'String'>
    readonly createdAt: FieldRef<"NewsletterSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsletterSubscription findUnique
   */
  export type NewsletterSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscription to fetch.
     */
    where: NewsletterSubscriptionWhereUniqueInput
  }

  /**
   * NewsletterSubscription findUniqueOrThrow
   */
  export type NewsletterSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscription to fetch.
     */
    where: NewsletterSubscriptionWhereUniqueInput
  }

  /**
   * NewsletterSubscription findFirst
   */
  export type NewsletterSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscription to fetch.
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscriptions to fetch.
     */
    orderBy?: NewsletterSubscriptionOrderByWithRelationInput | NewsletterSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsletterSubscriptions.
     */
    cursor?: NewsletterSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsletterSubscriptions.
     */
    distinct?: NewsletterSubscriptionScalarFieldEnum | NewsletterSubscriptionScalarFieldEnum[]
  }

  /**
   * NewsletterSubscription findFirstOrThrow
   */
  export type NewsletterSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscription to fetch.
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscriptions to fetch.
     */
    orderBy?: NewsletterSubscriptionOrderByWithRelationInput | NewsletterSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsletterSubscriptions.
     */
    cursor?: NewsletterSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsletterSubscriptions.
     */
    distinct?: NewsletterSubscriptionScalarFieldEnum | NewsletterSubscriptionScalarFieldEnum[]
  }

  /**
   * NewsletterSubscription findMany
   */
  export type NewsletterSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which NewsletterSubscriptions to fetch.
     */
    where?: NewsletterSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsletterSubscriptions to fetch.
     */
    orderBy?: NewsletterSubscriptionOrderByWithRelationInput | NewsletterSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsletterSubscriptions.
     */
    cursor?: NewsletterSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsletterSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsletterSubscriptions.
     */
    skip?: number
    distinct?: NewsletterSubscriptionScalarFieldEnum | NewsletterSubscriptionScalarFieldEnum[]
  }

  /**
   * NewsletterSubscription create
   */
  export type NewsletterSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsletterSubscription.
     */
    data: XOR<NewsletterSubscriptionCreateInput, NewsletterSubscriptionUncheckedCreateInput>
  }

  /**
   * NewsletterSubscription createMany
   */
  export type NewsletterSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsletterSubscriptions.
     */
    data: NewsletterSubscriptionCreateManyInput | NewsletterSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsletterSubscription createManyAndReturn
   */
  export type NewsletterSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsletterSubscriptions.
     */
    data: NewsletterSubscriptionCreateManyInput | NewsletterSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsletterSubscription update
   */
  export type NewsletterSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsletterSubscription.
     */
    data: XOR<NewsletterSubscriptionUpdateInput, NewsletterSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which NewsletterSubscription to update.
     */
    where: NewsletterSubscriptionWhereUniqueInput
  }

  /**
   * NewsletterSubscription updateMany
   */
  export type NewsletterSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsletterSubscriptions.
     */
    data: XOR<NewsletterSubscriptionUpdateManyMutationInput, NewsletterSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which NewsletterSubscriptions to update
     */
    where?: NewsletterSubscriptionWhereInput
  }

  /**
   * NewsletterSubscription upsert
   */
  export type NewsletterSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsletterSubscription to update in case it exists.
     */
    where: NewsletterSubscriptionWhereUniqueInput
    /**
     * In case the NewsletterSubscription found by the `where` argument doesn't exist, create a new NewsletterSubscription with this data.
     */
    create: XOR<NewsletterSubscriptionCreateInput, NewsletterSubscriptionUncheckedCreateInput>
    /**
     * In case the NewsletterSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsletterSubscriptionUpdateInput, NewsletterSubscriptionUncheckedUpdateInput>
  }

  /**
   * NewsletterSubscription delete
   */
  export type NewsletterSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which NewsletterSubscription to delete.
     */
    where: NewsletterSubscriptionWhereUniqueInput
  }

  /**
   * NewsletterSubscription deleteMany
   */
  export type NewsletterSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsletterSubscriptions to delete
     */
    where?: NewsletterSubscriptionWhereInput
  }

  /**
   * NewsletterSubscription without action
   */
  export type NewsletterSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsletterSubscription
     */
    select?: NewsletterSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsletterSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model PostNotification
   */

  export type AggregatePostNotification = {
    _count: PostNotificationCountAggregateOutputType | null
    _avg: PostNotificationAvgAggregateOutputType | null
    _sum: PostNotificationSumAggregateOutputType | null
    _min: PostNotificationMinAggregateOutputType | null
    _max: PostNotificationMaxAggregateOutputType | null
  }

  export type PostNotificationAvgAggregateOutputType = {
    subscriberCount: number | null
  }

  export type PostNotificationSumAggregateOutputType = {
    subscriberCount: number | null
  }

  export type PostNotificationMinAggregateOutputType = {
    id: string | null
    postId: string | null
    sentAt: Date | null
    subscriberCount: number | null
    subject: string | null
    emailContent: string | null
    createdAt: Date | null
  }

  export type PostNotificationMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    sentAt: Date | null
    subscriberCount: number | null
    subject: string | null
    emailContent: string | null
    createdAt: Date | null
  }

  export type PostNotificationCountAggregateOutputType = {
    id: number
    postId: number
    sentAt: number
    subscriberCount: number
    subject: number
    emailContent: number
    createdAt: number
    _all: number
  }


  export type PostNotificationAvgAggregateInputType = {
    subscriberCount?: true
  }

  export type PostNotificationSumAggregateInputType = {
    subscriberCount?: true
  }

  export type PostNotificationMinAggregateInputType = {
    id?: true
    postId?: true
    sentAt?: true
    subscriberCount?: true
    subject?: true
    emailContent?: true
    createdAt?: true
  }

  export type PostNotificationMaxAggregateInputType = {
    id?: true
    postId?: true
    sentAt?: true
    subscriberCount?: true
    subject?: true
    emailContent?: true
    createdAt?: true
  }

  export type PostNotificationCountAggregateInputType = {
    id?: true
    postId?: true
    sentAt?: true
    subscriberCount?: true
    subject?: true
    emailContent?: true
    createdAt?: true
    _all?: true
  }

  export type PostNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostNotification to aggregate.
     */
    where?: PostNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostNotifications to fetch.
     */
    orderBy?: PostNotificationOrderByWithRelationInput | PostNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostNotifications
    **/
    _count?: true | PostNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostNotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostNotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostNotificationMaxAggregateInputType
  }

  export type GetPostNotificationAggregateType<T extends PostNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregatePostNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostNotification[P]>
      : GetScalarType<T[P], AggregatePostNotification[P]>
  }




  export type PostNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostNotificationWhereInput
    orderBy?: PostNotificationOrderByWithAggregationInput | PostNotificationOrderByWithAggregationInput[]
    by: PostNotificationScalarFieldEnum[] | PostNotificationScalarFieldEnum
    having?: PostNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostNotificationCountAggregateInputType | true
    _avg?: PostNotificationAvgAggregateInputType
    _sum?: PostNotificationSumAggregateInputType
    _min?: PostNotificationMinAggregateInputType
    _max?: PostNotificationMaxAggregateInputType
  }

  export type PostNotificationGroupByOutputType = {
    id: string
    postId: string
    sentAt: Date | null
    subscriberCount: number
    subject: string | null
    emailContent: string | null
    createdAt: Date
    _count: PostNotificationCountAggregateOutputType | null
    _avg: PostNotificationAvgAggregateOutputType | null
    _sum: PostNotificationSumAggregateOutputType | null
    _min: PostNotificationMinAggregateOutputType | null
    _max: PostNotificationMaxAggregateOutputType | null
  }

  type GetPostNotificationGroupByPayload<T extends PostNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], PostNotificationGroupByOutputType[P]>
        }
      >
    >


  export type PostNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    sentAt?: boolean
    subscriberCount?: boolean
    subject?: boolean
    emailContent?: boolean
    createdAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postNotification"]>

  export type PostNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    sentAt?: boolean
    subscriberCount?: boolean
    subject?: boolean
    emailContent?: boolean
    createdAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postNotification"]>

  export type PostNotificationSelectScalar = {
    id?: boolean
    postId?: boolean
    sentAt?: boolean
    subscriberCount?: boolean
    subject?: boolean
    emailContent?: boolean
    createdAt?: boolean
  }

  export type PostNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type PostNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }

  export type $PostNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostNotification"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      sentAt: Date | null
      subscriberCount: number
      subject: string | null
      emailContent: string | null
      createdAt: Date
    }, ExtArgs["result"]["postNotification"]>
    composites: {}
  }

  type PostNotificationGetPayload<S extends boolean | null | undefined | PostNotificationDefaultArgs> = $Result.GetResult<Prisma.$PostNotificationPayload, S>

  type PostNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostNotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostNotificationCountAggregateInputType | true
    }

  export interface PostNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostNotification'], meta: { name: 'PostNotification' } }
    /**
     * Find zero or one PostNotification that matches the filter.
     * @param {PostNotificationFindUniqueArgs} args - Arguments to find a PostNotification
     * @example
     * // Get one PostNotification
     * const postNotification = await prisma.postNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostNotificationFindUniqueArgs>(args: SelectSubset<T, PostNotificationFindUniqueArgs<ExtArgs>>): Prisma__PostNotificationClient<$Result.GetResult<Prisma.$PostNotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostNotification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostNotificationFindUniqueOrThrowArgs} args - Arguments to find a PostNotification
     * @example
     * // Get one PostNotification
     * const postNotification = await prisma.postNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, PostNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostNotificationClient<$Result.GetResult<Prisma.$PostNotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostNotificationFindFirstArgs} args - Arguments to find a PostNotification
     * @example
     * // Get one PostNotification
     * const postNotification = await prisma.postNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostNotificationFindFirstArgs>(args?: SelectSubset<T, PostNotificationFindFirstArgs<ExtArgs>>): Prisma__PostNotificationClient<$Result.GetResult<Prisma.$PostNotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostNotificationFindFirstOrThrowArgs} args - Arguments to find a PostNotification
     * @example
     * // Get one PostNotification
     * const postNotification = await prisma.postNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, PostNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostNotificationClient<$Result.GetResult<Prisma.$PostNotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostNotifications
     * const postNotifications = await prisma.postNotification.findMany()
     * 
     * // Get first 10 PostNotifications
     * const postNotifications = await prisma.postNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postNotificationWithIdOnly = await prisma.postNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostNotificationFindManyArgs>(args?: SelectSubset<T, PostNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostNotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostNotification.
     * @param {PostNotificationCreateArgs} args - Arguments to create a PostNotification.
     * @example
     * // Create one PostNotification
     * const PostNotification = await prisma.postNotification.create({
     *   data: {
     *     // ... data to create a PostNotification
     *   }
     * })
     * 
     */
    create<T extends PostNotificationCreateArgs>(args: SelectSubset<T, PostNotificationCreateArgs<ExtArgs>>): Prisma__PostNotificationClient<$Result.GetResult<Prisma.$PostNotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostNotifications.
     * @param {PostNotificationCreateManyArgs} args - Arguments to create many PostNotifications.
     * @example
     * // Create many PostNotifications
     * const postNotification = await prisma.postNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostNotificationCreateManyArgs>(args?: SelectSubset<T, PostNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostNotifications and returns the data saved in the database.
     * @param {PostNotificationCreateManyAndReturnArgs} args - Arguments to create many PostNotifications.
     * @example
     * // Create many PostNotifications
     * const postNotification = await prisma.postNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostNotifications and only return the `id`
     * const postNotificationWithIdOnly = await prisma.postNotification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, PostNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostNotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostNotification.
     * @param {PostNotificationDeleteArgs} args - Arguments to delete one PostNotification.
     * @example
     * // Delete one PostNotification
     * const PostNotification = await prisma.postNotification.delete({
     *   where: {
     *     // ... filter to delete one PostNotification
     *   }
     * })
     * 
     */
    delete<T extends PostNotificationDeleteArgs>(args: SelectSubset<T, PostNotificationDeleteArgs<ExtArgs>>): Prisma__PostNotificationClient<$Result.GetResult<Prisma.$PostNotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostNotification.
     * @param {PostNotificationUpdateArgs} args - Arguments to update one PostNotification.
     * @example
     * // Update one PostNotification
     * const postNotification = await prisma.postNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostNotificationUpdateArgs>(args: SelectSubset<T, PostNotificationUpdateArgs<ExtArgs>>): Prisma__PostNotificationClient<$Result.GetResult<Prisma.$PostNotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostNotifications.
     * @param {PostNotificationDeleteManyArgs} args - Arguments to filter PostNotifications to delete.
     * @example
     * // Delete a few PostNotifications
     * const { count } = await prisma.postNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostNotificationDeleteManyArgs>(args?: SelectSubset<T, PostNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostNotifications
     * const postNotification = await prisma.postNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostNotificationUpdateManyArgs>(args: SelectSubset<T, PostNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostNotification.
     * @param {PostNotificationUpsertArgs} args - Arguments to update or create a PostNotification.
     * @example
     * // Update or create a PostNotification
     * const postNotification = await prisma.postNotification.upsert({
     *   create: {
     *     // ... data to create a PostNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostNotification we want to update
     *   }
     * })
     */
    upsert<T extends PostNotificationUpsertArgs>(args: SelectSubset<T, PostNotificationUpsertArgs<ExtArgs>>): Prisma__PostNotificationClient<$Result.GetResult<Prisma.$PostNotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostNotificationCountArgs} args - Arguments to filter PostNotifications to count.
     * @example
     * // Count the number of PostNotifications
     * const count = await prisma.postNotification.count({
     *   where: {
     *     // ... the filter for the PostNotifications we want to count
     *   }
     * })
    **/
    count<T extends PostNotificationCountArgs>(
      args?: Subset<T, PostNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostNotificationAggregateArgs>(args: Subset<T, PostNotificationAggregateArgs>): Prisma.PrismaPromise<GetPostNotificationAggregateType<T>>

    /**
     * Group by PostNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostNotificationGroupByArgs['orderBy'] }
        : { orderBy?: PostNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostNotification model
   */
  readonly fields: PostNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostNotification model
   */ 
  interface PostNotificationFieldRefs {
    readonly id: FieldRef<"PostNotification", 'String'>
    readonly postId: FieldRef<"PostNotification", 'String'>
    readonly sentAt: FieldRef<"PostNotification", 'DateTime'>
    readonly subscriberCount: FieldRef<"PostNotification", 'Int'>
    readonly subject: FieldRef<"PostNotification", 'String'>
    readonly emailContent: FieldRef<"PostNotification", 'String'>
    readonly createdAt: FieldRef<"PostNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostNotification findUnique
   */
  export type PostNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostNotification
     */
    select?: PostNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostNotificationInclude<ExtArgs> | null
    /**
     * Filter, which PostNotification to fetch.
     */
    where: PostNotificationWhereUniqueInput
  }

  /**
   * PostNotification findUniqueOrThrow
   */
  export type PostNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostNotification
     */
    select?: PostNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostNotificationInclude<ExtArgs> | null
    /**
     * Filter, which PostNotification to fetch.
     */
    where: PostNotificationWhereUniqueInput
  }

  /**
   * PostNotification findFirst
   */
  export type PostNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostNotification
     */
    select?: PostNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostNotificationInclude<ExtArgs> | null
    /**
     * Filter, which PostNotification to fetch.
     */
    where?: PostNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostNotifications to fetch.
     */
    orderBy?: PostNotificationOrderByWithRelationInput | PostNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostNotifications.
     */
    cursor?: PostNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostNotifications.
     */
    distinct?: PostNotificationScalarFieldEnum | PostNotificationScalarFieldEnum[]
  }

  /**
   * PostNotification findFirstOrThrow
   */
  export type PostNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostNotification
     */
    select?: PostNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostNotificationInclude<ExtArgs> | null
    /**
     * Filter, which PostNotification to fetch.
     */
    where?: PostNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostNotifications to fetch.
     */
    orderBy?: PostNotificationOrderByWithRelationInput | PostNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostNotifications.
     */
    cursor?: PostNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostNotifications.
     */
    distinct?: PostNotificationScalarFieldEnum | PostNotificationScalarFieldEnum[]
  }

  /**
   * PostNotification findMany
   */
  export type PostNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostNotification
     */
    select?: PostNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostNotificationInclude<ExtArgs> | null
    /**
     * Filter, which PostNotifications to fetch.
     */
    where?: PostNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostNotifications to fetch.
     */
    orderBy?: PostNotificationOrderByWithRelationInput | PostNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostNotifications.
     */
    cursor?: PostNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostNotifications.
     */
    skip?: number
    distinct?: PostNotificationScalarFieldEnum | PostNotificationScalarFieldEnum[]
  }

  /**
   * PostNotification create
   */
  export type PostNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostNotification
     */
    select?: PostNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a PostNotification.
     */
    data: XOR<PostNotificationCreateInput, PostNotificationUncheckedCreateInput>
  }

  /**
   * PostNotification createMany
   */
  export type PostNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostNotifications.
     */
    data: PostNotificationCreateManyInput | PostNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostNotification createManyAndReturn
   */
  export type PostNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostNotification
     */
    select?: PostNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostNotifications.
     */
    data: PostNotificationCreateManyInput | PostNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostNotification update
   */
  export type PostNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostNotification
     */
    select?: PostNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a PostNotification.
     */
    data: XOR<PostNotificationUpdateInput, PostNotificationUncheckedUpdateInput>
    /**
     * Choose, which PostNotification to update.
     */
    where: PostNotificationWhereUniqueInput
  }

  /**
   * PostNotification updateMany
   */
  export type PostNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostNotifications.
     */
    data: XOR<PostNotificationUpdateManyMutationInput, PostNotificationUncheckedUpdateManyInput>
    /**
     * Filter which PostNotifications to update
     */
    where?: PostNotificationWhereInput
  }

  /**
   * PostNotification upsert
   */
  export type PostNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostNotification
     */
    select?: PostNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the PostNotification to update in case it exists.
     */
    where: PostNotificationWhereUniqueInput
    /**
     * In case the PostNotification found by the `where` argument doesn't exist, create a new PostNotification with this data.
     */
    create: XOR<PostNotificationCreateInput, PostNotificationUncheckedCreateInput>
    /**
     * In case the PostNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostNotificationUpdateInput, PostNotificationUncheckedUpdateInput>
  }

  /**
   * PostNotification delete
   */
  export type PostNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostNotification
     */
    select?: PostNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostNotificationInclude<ExtArgs> | null
    /**
     * Filter which PostNotification to delete.
     */
    where: PostNotificationWhereUniqueInput
  }

  /**
   * PostNotification deleteMany
   */
  export type PostNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostNotifications to delete
     */
    where?: PostNotificationWhereInput
  }

  /**
   * PostNotification without action
   */
  export type PostNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostNotification
     */
    select?: PostNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostNotificationInclude<ExtArgs> | null
  }


  /**
   * Model Evaluation
   */

  export type AggregateEvaluation = {
    _count: EvaluationCountAggregateOutputType | null
    _avg: EvaluationAvgAggregateOutputType | null
    _sum: EvaluationSumAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  export type EvaluationAvgAggregateOutputType = {
    experienceScore: number | null
    skillsScore: number | null
    educationScore: number | null
    culturalFitScore: number | null
    totalScore: number | null
  }

  export type EvaluationSumAggregateOutputType = {
    experienceScore: number | null
    skillsScore: number | null
    educationScore: number | null
    culturalFitScore: number | null
    totalScore: number | null
  }

  export type EvaluationMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    evaluatorId: string | null
    experienceScore: number | null
    skillsScore: number | null
    educationScore: number | null
    culturalFitScore: number | null
    totalScore: number | null
    recommendation: $Enums.EvaluationRecommendation | null
    comments: string | null
    createdAt: Date | null
  }

  export type EvaluationMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    evaluatorId: string | null
    experienceScore: number | null
    skillsScore: number | null
    educationScore: number | null
    culturalFitScore: number | null
    totalScore: number | null
    recommendation: $Enums.EvaluationRecommendation | null
    comments: string | null
    createdAt: Date | null
  }

  export type EvaluationCountAggregateOutputType = {
    id: number
    applicationId: number
    evaluatorId: number
    experienceScore: number
    skillsScore: number
    educationScore: number
    culturalFitScore: number
    totalScore: number
    recommendation: number
    comments: number
    createdAt: number
    _all: number
  }


  export type EvaluationAvgAggregateInputType = {
    experienceScore?: true
    skillsScore?: true
    educationScore?: true
    culturalFitScore?: true
    totalScore?: true
  }

  export type EvaluationSumAggregateInputType = {
    experienceScore?: true
    skillsScore?: true
    educationScore?: true
    culturalFitScore?: true
    totalScore?: true
  }

  export type EvaluationMinAggregateInputType = {
    id?: true
    applicationId?: true
    evaluatorId?: true
    experienceScore?: true
    skillsScore?: true
    educationScore?: true
    culturalFitScore?: true
    totalScore?: true
    recommendation?: true
    comments?: true
    createdAt?: true
  }

  export type EvaluationMaxAggregateInputType = {
    id?: true
    applicationId?: true
    evaluatorId?: true
    experienceScore?: true
    skillsScore?: true
    educationScore?: true
    culturalFitScore?: true
    totalScore?: true
    recommendation?: true
    comments?: true
    createdAt?: true
  }

  export type EvaluationCountAggregateInputType = {
    id?: true
    applicationId?: true
    evaluatorId?: true
    experienceScore?: true
    skillsScore?: true
    educationScore?: true
    culturalFitScore?: true
    totalScore?: true
    recommendation?: true
    comments?: true
    createdAt?: true
    _all?: true
  }

  export type EvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluation to aggregate.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evaluations
    **/
    _count?: true | EvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationMaxAggregateInputType
  }

  export type GetEvaluationAggregateType<T extends EvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluation[P]>
      : GetScalarType<T[P], AggregateEvaluation[P]>
  }




  export type EvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithAggregationInput | EvaluationOrderByWithAggregationInput[]
    by: EvaluationScalarFieldEnum[] | EvaluationScalarFieldEnum
    having?: EvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationCountAggregateInputType | true
    _avg?: EvaluationAvgAggregateInputType
    _sum?: EvaluationSumAggregateInputType
    _min?: EvaluationMinAggregateInputType
    _max?: EvaluationMaxAggregateInputType
  }

  export type EvaluationGroupByOutputType = {
    id: string
    applicationId: string
    evaluatorId: string
    experienceScore: number
    skillsScore: number
    educationScore: number
    culturalFitScore: number
    totalScore: number
    recommendation: $Enums.EvaluationRecommendation
    comments: string
    createdAt: Date
    _count: EvaluationCountAggregateOutputType | null
    _avg: EvaluationAvgAggregateOutputType | null
    _sum: EvaluationSumAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  type GetEvaluationGroupByPayload<T extends EvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    evaluatorId?: boolean
    experienceScore?: boolean
    skillsScore?: boolean
    educationScore?: boolean
    culturalFitScore?: boolean
    totalScore?: boolean
    recommendation?: boolean
    comments?: boolean
    createdAt?: boolean
    application?: boolean | CollaboratorApplicationDefaultArgs<ExtArgs>
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluation"]>

  export type EvaluationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    evaluatorId?: boolean
    experienceScore?: boolean
    skillsScore?: boolean
    educationScore?: boolean
    culturalFitScore?: boolean
    totalScore?: boolean
    recommendation?: boolean
    comments?: boolean
    createdAt?: boolean
    application?: boolean | CollaboratorApplicationDefaultArgs<ExtArgs>
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluation"]>

  export type EvaluationSelectScalar = {
    id?: boolean
    applicationId?: boolean
    evaluatorId?: boolean
    experienceScore?: boolean
    skillsScore?: boolean
    educationScore?: boolean
    culturalFitScore?: boolean
    totalScore?: boolean
    recommendation?: boolean
    comments?: boolean
    createdAt?: boolean
  }

  export type EvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | CollaboratorApplicationDefaultArgs<ExtArgs>
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EvaluationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | CollaboratorApplicationDefaultArgs<ExtArgs>
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evaluation"
    objects: {
      application: Prisma.$CollaboratorApplicationPayload<ExtArgs>
      evaluator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      evaluatorId: string
      experienceScore: number
      skillsScore: number
      educationScore: number
      culturalFitScore: number
      totalScore: number
      recommendation: $Enums.EvaluationRecommendation
      comments: string
      createdAt: Date
    }, ExtArgs["result"]["evaluation"]>
    composites: {}
  }

  type EvaluationGetPayload<S extends boolean | null | undefined | EvaluationDefaultArgs> = $Result.GetResult<Prisma.$EvaluationPayload, S>

  type EvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvaluationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvaluationCountAggregateInputType | true
    }

  export interface EvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evaluation'], meta: { name: 'Evaluation' } }
    /**
     * Find zero or one Evaluation that matches the filter.
     * @param {EvaluationFindUniqueArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluationFindUniqueArgs>(args: SelectSubset<T, EvaluationFindUniqueArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Evaluation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvaluationFindUniqueOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluationFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Evaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluationFindFirstArgs>(args?: SelectSubset<T, EvaluationFindFirstArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Evaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluationFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Evaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evaluations
     * const evaluations = await prisma.evaluation.findMany()
     * 
     * // Get first 10 Evaluations
     * const evaluations = await prisma.evaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationWithIdOnly = await prisma.evaluation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaluationFindManyArgs>(args?: SelectSubset<T, EvaluationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Evaluation.
     * @param {EvaluationCreateArgs} args - Arguments to create a Evaluation.
     * @example
     * // Create one Evaluation
     * const Evaluation = await prisma.evaluation.create({
     *   data: {
     *     // ... data to create a Evaluation
     *   }
     * })
     * 
     */
    create<T extends EvaluationCreateArgs>(args: SelectSubset<T, EvaluationCreateArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Evaluations.
     * @param {EvaluationCreateManyArgs} args - Arguments to create many Evaluations.
     * @example
     * // Create many Evaluations
     * const evaluation = await prisma.evaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluationCreateManyArgs>(args?: SelectSubset<T, EvaluationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evaluations and returns the data saved in the database.
     * @param {EvaluationCreateManyAndReturnArgs} args - Arguments to create many Evaluations.
     * @example
     * // Create many Evaluations
     * const evaluation = await prisma.evaluation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evaluations and only return the `id`
     * const evaluationWithIdOnly = await prisma.evaluation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvaluationCreateManyAndReturnArgs>(args?: SelectSubset<T, EvaluationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Evaluation.
     * @param {EvaluationDeleteArgs} args - Arguments to delete one Evaluation.
     * @example
     * // Delete one Evaluation
     * const Evaluation = await prisma.evaluation.delete({
     *   where: {
     *     // ... filter to delete one Evaluation
     *   }
     * })
     * 
     */
    delete<T extends EvaluationDeleteArgs>(args: SelectSubset<T, EvaluationDeleteArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Evaluation.
     * @param {EvaluationUpdateArgs} args - Arguments to update one Evaluation.
     * @example
     * // Update one Evaluation
     * const evaluation = await prisma.evaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluationUpdateArgs>(args: SelectSubset<T, EvaluationUpdateArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Evaluations.
     * @param {EvaluationDeleteManyArgs} args - Arguments to filter Evaluations to delete.
     * @example
     * // Delete a few Evaluations
     * const { count } = await prisma.evaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluationDeleteManyArgs>(args?: SelectSubset<T, EvaluationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evaluations
     * const evaluation = await prisma.evaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluationUpdateManyArgs>(args: SelectSubset<T, EvaluationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evaluation.
     * @param {EvaluationUpsertArgs} args - Arguments to update or create a Evaluation.
     * @example
     * // Update or create a Evaluation
     * const evaluation = await prisma.evaluation.upsert({
     *   create: {
     *     // ... data to create a Evaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evaluation we want to update
     *   }
     * })
     */
    upsert<T extends EvaluationUpsertArgs>(args: SelectSubset<T, EvaluationUpsertArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationCountArgs} args - Arguments to filter Evaluations to count.
     * @example
     * // Count the number of Evaluations
     * const count = await prisma.evaluation.count({
     *   where: {
     *     // ... the filter for the Evaluations we want to count
     *   }
     * })
    **/
    count<T extends EvaluationCountArgs>(
      args?: Subset<T, EvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationAggregateArgs>(args: Subset<T, EvaluationAggregateArgs>): Prisma.PrismaPromise<GetEvaluationAggregateType<T>>

    /**
     * Group by Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evaluation model
   */
  readonly fields: EvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends CollaboratorApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollaboratorApplicationDefaultArgs<ExtArgs>>): Prisma__CollaboratorApplicationClient<$Result.GetResult<Prisma.$CollaboratorApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    evaluator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evaluation model
   */ 
  interface EvaluationFieldRefs {
    readonly id: FieldRef<"Evaluation", 'String'>
    readonly applicationId: FieldRef<"Evaluation", 'String'>
    readonly evaluatorId: FieldRef<"Evaluation", 'String'>
    readonly experienceScore: FieldRef<"Evaluation", 'Int'>
    readonly skillsScore: FieldRef<"Evaluation", 'Int'>
    readonly educationScore: FieldRef<"Evaluation", 'Int'>
    readonly culturalFitScore: FieldRef<"Evaluation", 'Int'>
    readonly totalScore: FieldRef<"Evaluation", 'Int'>
    readonly recommendation: FieldRef<"Evaluation", 'EvaluationRecommendation'>
    readonly comments: FieldRef<"Evaluation", 'String'>
    readonly createdAt: FieldRef<"Evaluation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Evaluation findUnique
   */
  export type EvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation findUniqueOrThrow
   */
  export type EvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation findFirst
   */
  export type EvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation findFirstOrThrow
   */
  export type EvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation findMany
   */
  export type EvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluations to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation create
   */
  export type EvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a Evaluation.
     */
    data: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
  }

  /**
   * Evaluation createMany
   */
  export type EvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evaluations.
     */
    data: EvaluationCreateManyInput | EvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evaluation createManyAndReturn
   */
  export type EvaluationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Evaluations.
     */
    data: EvaluationCreateManyInput | EvaluationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evaluation update
   */
  export type EvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a Evaluation.
     */
    data: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
    /**
     * Choose, which Evaluation to update.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation updateMany
   */
  export type EvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evaluations.
     */
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyInput>
    /**
     * Filter which Evaluations to update
     */
    where?: EvaluationWhereInput
  }

  /**
   * Evaluation upsert
   */
  export type EvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the Evaluation to update in case it exists.
     */
    where: EvaluationWhereUniqueInput
    /**
     * In case the Evaluation found by the `where` argument doesn't exist, create a new Evaluation with this data.
     */
    create: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
    /**
     * In case the Evaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
  }

  /**
   * Evaluation delete
   */
  export type EvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter which Evaluation to delete.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation deleteMany
   */
  export type EvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluations to delete
     */
    where?: EvaluationWhereInput
  }

  /**
   * Evaluation without action
   */
  export type EvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
  }


  /**
   * Model Note
   */

  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  export type NoteMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    authorId: string | null
    content: string | null
    isPrivate: boolean | null
    createdAt: Date | null
  }

  export type NoteMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    authorId: string | null
    content: string | null
    isPrivate: boolean | null
    createdAt: Date | null
  }

  export type NoteCountAggregateOutputType = {
    id: number
    applicationId: number
    authorId: number
    content: number
    isPrivate: number
    createdAt: number
    _all: number
  }


  export type NoteMinAggregateInputType = {
    id?: true
    applicationId?: true
    authorId?: true
    content?: true
    isPrivate?: true
    createdAt?: true
  }

  export type NoteMaxAggregateInputType = {
    id?: true
    applicationId?: true
    authorId?: true
    content?: true
    isPrivate?: true
    createdAt?: true
  }

  export type NoteCountAggregateInputType = {
    id?: true
    applicationId?: true
    authorId?: true
    content?: true
    isPrivate?: true
    createdAt?: true
    _all?: true
  }

  export type NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note to aggregate.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteMaxAggregateInputType
  }

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>
  }




  export type NoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithAggregationInput | NoteOrderByWithAggregationInput[]
    by: NoteScalarFieldEnum[] | NoteScalarFieldEnum
    having?: NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteCountAggregateInputType | true
    _min?: NoteMinAggregateInputType
    _max?: NoteMaxAggregateInputType
  }

  export type NoteGroupByOutputType = {
    id: string
    applicationId: string
    authorId: string
    content: string
    isPrivate: boolean
    createdAt: Date
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  type GetNoteGroupByPayload<T extends NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteGroupByOutputType[P]>
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
        }
      >
    >


  export type NoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    authorId?: boolean
    content?: boolean
    isPrivate?: boolean
    createdAt?: boolean
    application?: boolean | CollaboratorApplicationDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    authorId?: boolean
    content?: boolean
    isPrivate?: boolean
    createdAt?: boolean
    application?: boolean | CollaboratorApplicationDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectScalar = {
    id?: boolean
    applicationId?: boolean
    authorId?: boolean
    content?: boolean
    isPrivate?: boolean
    createdAt?: boolean
  }

  export type NoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | CollaboratorApplicationDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | CollaboratorApplicationDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Note"
    objects: {
      application: Prisma.$CollaboratorApplicationPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      authorId: string
      content: string
      isPrivate: boolean
      createdAt: Date
    }, ExtArgs["result"]["note"]>
    composites: {}
  }

  type NoteGetPayload<S extends boolean | null | undefined | NoteDefaultArgs> = $Result.GetResult<Prisma.$NotePayload, S>

  type NoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NoteCountAggregateInputType | true
    }

  export interface NoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Note'], meta: { name: 'Note' } }
    /**
     * Find zero or one Note that matches the filter.
     * @param {NoteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteFindUniqueArgs>(args: SelectSubset<T, NoteFindUniqueArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Note that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NoteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteFindFirstArgs>(args?: SelectSubset<T, NoteFindFirstArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteWithIdOnly = await prisma.note.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteFindManyArgs>(args?: SelectSubset<T, NoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Note.
     * @param {NoteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     * 
     */
    create<T extends NoteCreateArgs>(args: SelectSubset<T, NoteCreateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notes.
     * @param {NoteCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteCreateManyArgs>(args?: SelectSubset<T, NoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notes and returns the data saved in the database.
     * @param {NoteCreateManyAndReturnArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notes and only return the `id`
     * const noteWithIdOnly = await prisma.note.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoteCreateManyAndReturnArgs>(args?: SelectSubset<T, NoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Note.
     * @param {NoteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     * 
     */
    delete<T extends NoteDeleteArgs>(args: SelectSubset<T, NoteDeleteArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Note.
     * @param {NoteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteUpdateArgs>(args: SelectSubset<T, NoteUpdateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notes.
     * @param {NoteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteDeleteManyArgs>(args?: SelectSubset<T, NoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteUpdateManyArgs>(args: SelectSubset<T, NoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Note.
     * @param {NoteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
     */
    upsert<T extends NoteUpsertArgs>(args: SelectSubset<T, NoteUpsertArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NoteCountArgs>(
      args?: Subset<T, NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteAggregateArgs>(args: Subset<T, NoteAggregateArgs>): Prisma.PrismaPromise<GetNoteAggregateType<T>>

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteGroupByArgs['orderBy'] }
        : { orderBy?: NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Note model
   */
  readonly fields: NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends CollaboratorApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollaboratorApplicationDefaultArgs<ExtArgs>>): Prisma__CollaboratorApplicationClient<$Result.GetResult<Prisma.$CollaboratorApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Note model
   */ 
  interface NoteFieldRefs {
    readonly id: FieldRef<"Note", 'String'>
    readonly applicationId: FieldRef<"Note", 'String'>
    readonly authorId: FieldRef<"Note", 'String'>
    readonly content: FieldRef<"Note", 'String'>
    readonly isPrivate: FieldRef<"Note", 'Boolean'>
    readonly createdAt: FieldRef<"Note", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Note findUnique
   */
  export type NoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findUniqueOrThrow
   */
  export type NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findFirst
   */
  export type NoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findFirstOrThrow
   */
  export type NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findMany
   */
  export type NoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note create
   */
  export type NoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Note.
     */
    data: XOR<NoteCreateInput, NoteUncheckedCreateInput>
  }

  /**
   * Note createMany
   */
  export type NoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Note createManyAndReturn
   */
  export type NoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Note update
   */
  export type NoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Note.
     */
    data: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
    /**
     * Choose, which Note to update.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note updateMany
   */
  export type NoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
  }

  /**
   * Note upsert
   */
  export type NoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Note to update in case it exists.
     */
    where: NoteWhereUniqueInput
    /**
     * In case the Note found by the `where` argument doesn't exist, create a new Note with this data.
     */
    create: XOR<NoteCreateInput, NoteUncheckedCreateInput>
    /**
     * In case the Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
  }

  /**
   * Note delete
   */
  export type NoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter which Note to delete.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note deleteMany
   */
  export type NoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NoteWhereInput
  }

  /**
   * Note without action
   */
  export type NoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
  }


  /**
   * Model Interview
   */

  export type AggregateInterview = {
    _count: InterviewCountAggregateOutputType | null
    _avg: InterviewAvgAggregateOutputType | null
    _sum: InterviewSumAggregateOutputType | null
    _min: InterviewMinAggregateOutputType | null
    _max: InterviewMaxAggregateOutputType | null
  }

  export type InterviewAvgAggregateOutputType = {
    duration: number | null
  }

  export type InterviewSumAggregateOutputType = {
    duration: number | null
  }

  export type InterviewMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    scheduledAt: Date | null
    duration: number | null
    type: $Enums.InterviewType | null
    location: string | null
    meetingUrl: string | null
    interviewerId: string | null
    status: $Enums.InterviewStatus | null
    feedback: string | null
    result: $Enums.InterviewResult | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterviewMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    scheduledAt: Date | null
    duration: number | null
    type: $Enums.InterviewType | null
    location: string | null
    meetingUrl: string | null
    interviewerId: string | null
    status: $Enums.InterviewStatus | null
    feedback: string | null
    result: $Enums.InterviewResult | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterviewCountAggregateOutputType = {
    id: number
    applicationId: number
    scheduledAt: number
    duration: number
    type: number
    location: number
    meetingUrl: number
    interviewerId: number
    status: number
    feedback: number
    result: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InterviewAvgAggregateInputType = {
    duration?: true
  }

  export type InterviewSumAggregateInputType = {
    duration?: true
  }

  export type InterviewMinAggregateInputType = {
    id?: true
    applicationId?: true
    scheduledAt?: true
    duration?: true
    type?: true
    location?: true
    meetingUrl?: true
    interviewerId?: true
    status?: true
    feedback?: true
    result?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterviewMaxAggregateInputType = {
    id?: true
    applicationId?: true
    scheduledAt?: true
    duration?: true
    type?: true
    location?: true
    meetingUrl?: true
    interviewerId?: true
    status?: true
    feedback?: true
    result?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterviewCountAggregateInputType = {
    id?: true
    applicationId?: true
    scheduledAt?: true
    duration?: true
    type?: true
    location?: true
    meetingUrl?: true
    interviewerId?: true
    status?: true
    feedback?: true
    result?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InterviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interview to aggregate.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interviews
    **/
    _count?: true | InterviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewMaxAggregateInputType
  }

  export type GetInterviewAggregateType<T extends InterviewAggregateArgs> = {
        [P in keyof T & keyof AggregateInterview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterview[P]>
      : GetScalarType<T[P], AggregateInterview[P]>
  }




  export type InterviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewWhereInput
    orderBy?: InterviewOrderByWithAggregationInput | InterviewOrderByWithAggregationInput[]
    by: InterviewScalarFieldEnum[] | InterviewScalarFieldEnum
    having?: InterviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewCountAggregateInputType | true
    _avg?: InterviewAvgAggregateInputType
    _sum?: InterviewSumAggregateInputType
    _min?: InterviewMinAggregateInputType
    _max?: InterviewMaxAggregateInputType
  }

  export type InterviewGroupByOutputType = {
    id: string
    applicationId: string
    scheduledAt: Date
    duration: number
    type: $Enums.InterviewType
    location: string | null
    meetingUrl: string | null
    interviewerId: string
    status: $Enums.InterviewStatus
    feedback: string | null
    result: $Enums.InterviewResult | null
    createdAt: Date
    updatedAt: Date
    _count: InterviewCountAggregateOutputType | null
    _avg: InterviewAvgAggregateOutputType | null
    _sum: InterviewSumAggregateOutputType | null
    _min: InterviewMinAggregateOutputType | null
    _max: InterviewMaxAggregateOutputType | null
  }

  type GetInterviewGroupByPayload<T extends InterviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewGroupByOutputType[P]>
        }
      >
    >


  export type InterviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    type?: boolean
    location?: boolean
    meetingUrl?: boolean
    interviewerId?: boolean
    status?: boolean
    feedback?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    application?: boolean | CollaboratorApplicationDefaultArgs<ExtArgs>
    interviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interview"]>

  export type InterviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    type?: boolean
    location?: boolean
    meetingUrl?: boolean
    interviewerId?: boolean
    status?: boolean
    feedback?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    application?: boolean | CollaboratorApplicationDefaultArgs<ExtArgs>
    interviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interview"]>

  export type InterviewSelectScalar = {
    id?: boolean
    applicationId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    type?: boolean
    location?: boolean
    meetingUrl?: boolean
    interviewerId?: boolean
    status?: boolean
    feedback?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InterviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | CollaboratorApplicationDefaultArgs<ExtArgs>
    interviewer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InterviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | CollaboratorApplicationDefaultArgs<ExtArgs>
    interviewer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InterviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interview"
    objects: {
      application: Prisma.$CollaboratorApplicationPayload<ExtArgs>
      interviewer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      scheduledAt: Date
      duration: number
      type: $Enums.InterviewType
      location: string | null
      meetingUrl: string | null
      interviewerId: string
      status: $Enums.InterviewStatus
      feedback: string | null
      result: $Enums.InterviewResult | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["interview"]>
    composites: {}
  }

  type InterviewGetPayload<S extends boolean | null | undefined | InterviewDefaultArgs> = $Result.GetResult<Prisma.$InterviewPayload, S>

  type InterviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InterviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InterviewCountAggregateInputType | true
    }

  export interface InterviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interview'], meta: { name: 'Interview' } }
    /**
     * Find zero or one Interview that matches the filter.
     * @param {InterviewFindUniqueArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterviewFindUniqueArgs>(args: SelectSubset<T, InterviewFindUniqueArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Interview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InterviewFindUniqueOrThrowArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterviewFindUniqueOrThrowArgs>(args: SelectSubset<T, InterviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Interview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFindFirstArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterviewFindFirstArgs>(args?: SelectSubset<T, InterviewFindFirstArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Interview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFindFirstOrThrowArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterviewFindFirstOrThrowArgs>(args?: SelectSubset<T, InterviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Interviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interviews
     * const interviews = await prisma.interview.findMany()
     * 
     * // Get first 10 Interviews
     * const interviews = await prisma.interview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewWithIdOnly = await prisma.interview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterviewFindManyArgs>(args?: SelectSubset<T, InterviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Interview.
     * @param {InterviewCreateArgs} args - Arguments to create a Interview.
     * @example
     * // Create one Interview
     * const Interview = await prisma.interview.create({
     *   data: {
     *     // ... data to create a Interview
     *   }
     * })
     * 
     */
    create<T extends InterviewCreateArgs>(args: SelectSubset<T, InterviewCreateArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Interviews.
     * @param {InterviewCreateManyArgs} args - Arguments to create many Interviews.
     * @example
     * // Create many Interviews
     * const interview = await prisma.interview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterviewCreateManyArgs>(args?: SelectSubset<T, InterviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interviews and returns the data saved in the database.
     * @param {InterviewCreateManyAndReturnArgs} args - Arguments to create many Interviews.
     * @example
     * // Create many Interviews
     * const interview = await prisma.interview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interviews and only return the `id`
     * const interviewWithIdOnly = await prisma.interview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterviewCreateManyAndReturnArgs>(args?: SelectSubset<T, InterviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Interview.
     * @param {InterviewDeleteArgs} args - Arguments to delete one Interview.
     * @example
     * // Delete one Interview
     * const Interview = await prisma.interview.delete({
     *   where: {
     *     // ... filter to delete one Interview
     *   }
     * })
     * 
     */
    delete<T extends InterviewDeleteArgs>(args: SelectSubset<T, InterviewDeleteArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Interview.
     * @param {InterviewUpdateArgs} args - Arguments to update one Interview.
     * @example
     * // Update one Interview
     * const interview = await prisma.interview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterviewUpdateArgs>(args: SelectSubset<T, InterviewUpdateArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Interviews.
     * @param {InterviewDeleteManyArgs} args - Arguments to filter Interviews to delete.
     * @example
     * // Delete a few Interviews
     * const { count } = await prisma.interview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterviewDeleteManyArgs>(args?: SelectSubset<T, InterviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interviews
     * const interview = await prisma.interview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterviewUpdateManyArgs>(args: SelectSubset<T, InterviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Interview.
     * @param {InterviewUpsertArgs} args - Arguments to update or create a Interview.
     * @example
     * // Update or create a Interview
     * const interview = await prisma.interview.upsert({
     *   create: {
     *     // ... data to create a Interview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interview we want to update
     *   }
     * })
     */
    upsert<T extends InterviewUpsertArgs>(args: SelectSubset<T, InterviewUpsertArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Interviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewCountArgs} args - Arguments to filter Interviews to count.
     * @example
     * // Count the number of Interviews
     * const count = await prisma.interview.count({
     *   where: {
     *     // ... the filter for the Interviews we want to count
     *   }
     * })
    **/
    count<T extends InterviewCountArgs>(
      args?: Subset<T, InterviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewAggregateArgs>(args: Subset<T, InterviewAggregateArgs>): Prisma.PrismaPromise<GetInterviewAggregateType<T>>

    /**
     * Group by Interview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewGroupByArgs['orderBy'] }
        : { orderBy?: InterviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interview model
   */
  readonly fields: InterviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends CollaboratorApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollaboratorApplicationDefaultArgs<ExtArgs>>): Prisma__CollaboratorApplicationClient<$Result.GetResult<Prisma.$CollaboratorApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    interviewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interview model
   */ 
  interface InterviewFieldRefs {
    readonly id: FieldRef<"Interview", 'String'>
    readonly applicationId: FieldRef<"Interview", 'String'>
    readonly scheduledAt: FieldRef<"Interview", 'DateTime'>
    readonly duration: FieldRef<"Interview", 'Int'>
    readonly type: FieldRef<"Interview", 'InterviewType'>
    readonly location: FieldRef<"Interview", 'String'>
    readonly meetingUrl: FieldRef<"Interview", 'String'>
    readonly interviewerId: FieldRef<"Interview", 'String'>
    readonly status: FieldRef<"Interview", 'InterviewStatus'>
    readonly feedback: FieldRef<"Interview", 'String'>
    readonly result: FieldRef<"Interview", 'InterviewResult'>
    readonly createdAt: FieldRef<"Interview", 'DateTime'>
    readonly updatedAt: FieldRef<"Interview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Interview findUnique
   */
  export type InterviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter, which Interview to fetch.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview findUniqueOrThrow
   */
  export type InterviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter, which Interview to fetch.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview findFirst
   */
  export type InterviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter, which Interview to fetch.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interviews.
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interviews.
     */
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * Interview findFirstOrThrow
   */
  export type InterviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter, which Interview to fetch.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interviews.
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interviews.
     */
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * Interview findMany
   */
  export type InterviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter, which Interviews to fetch.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interviews.
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * Interview create
   */
  export type InterviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Interview.
     */
    data: XOR<InterviewCreateInput, InterviewUncheckedCreateInput>
  }

  /**
   * Interview createMany
   */
  export type InterviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interviews.
     */
    data: InterviewCreateManyInput | InterviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interview createManyAndReturn
   */
  export type InterviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Interviews.
     */
    data: InterviewCreateManyInput | InterviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interview update
   */
  export type InterviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Interview.
     */
    data: XOR<InterviewUpdateInput, InterviewUncheckedUpdateInput>
    /**
     * Choose, which Interview to update.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview updateMany
   */
  export type InterviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interviews.
     */
    data: XOR<InterviewUpdateManyMutationInput, InterviewUncheckedUpdateManyInput>
    /**
     * Filter which Interviews to update
     */
    where?: InterviewWhereInput
  }

  /**
   * Interview upsert
   */
  export type InterviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Interview to update in case it exists.
     */
    where: InterviewWhereUniqueInput
    /**
     * In case the Interview found by the `where` argument doesn't exist, create a new Interview with this data.
     */
    create: XOR<InterviewCreateInput, InterviewUncheckedCreateInput>
    /**
     * In case the Interview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewUpdateInput, InterviewUncheckedUpdateInput>
  }

  /**
   * Interview delete
   */
  export type InterviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter which Interview to delete.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview deleteMany
   */
  export type InterviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interviews to delete
     */
    where?: InterviewWhereInput
  }

  /**
   * Interview without action
   */
  export type InterviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
  }


  /**
   * Model ApiIntegration
   */

  export type AggregateApiIntegration = {
    _count: ApiIntegrationCountAggregateOutputType | null
    _min: ApiIntegrationMinAggregateOutputType | null
    _max: ApiIntegrationMaxAggregateOutputType | null
  }

  export type ApiIntegrationMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    apiKey: string | null
    apiSecret: string | null
    environment: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiIntegrationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    apiKey: string | null
    apiSecret: string | null
    environment: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiIntegrationCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    apiKey: number
    apiSecret: number
    environment: number
    isActive: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApiIntegrationMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    apiKey?: true
    apiSecret?: true
    environment?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiIntegrationMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    apiKey?: true
    apiSecret?: true
    environment?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiIntegrationCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    apiKey?: true
    apiSecret?: true
    environment?: true
    isActive?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApiIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiIntegration to aggregate.
     */
    where?: ApiIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiIntegrations to fetch.
     */
    orderBy?: ApiIntegrationOrderByWithRelationInput | ApiIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiIntegrations
    **/
    _count?: true | ApiIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiIntegrationMaxAggregateInputType
  }

  export type GetApiIntegrationAggregateType<T extends ApiIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateApiIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiIntegration[P]>
      : GetScalarType<T[P], AggregateApiIntegration[P]>
  }




  export type ApiIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiIntegrationWhereInput
    orderBy?: ApiIntegrationOrderByWithAggregationInput | ApiIntegrationOrderByWithAggregationInput[]
    by: ApiIntegrationScalarFieldEnum[] | ApiIntegrationScalarFieldEnum
    having?: ApiIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiIntegrationCountAggregateInputType | true
    _min?: ApiIntegrationMinAggregateInputType
    _max?: ApiIntegrationMaxAggregateInputType
  }

  export type ApiIntegrationGroupByOutputType = {
    id: string
    name: string
    displayName: string
    apiKey: string
    apiSecret: string | null
    environment: string
    isActive: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ApiIntegrationCountAggregateOutputType | null
    _min: ApiIntegrationMinAggregateOutputType | null
    _max: ApiIntegrationMaxAggregateOutputType | null
  }

  type GetApiIntegrationGroupByPayload<T extends ApiIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], ApiIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type ApiIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    apiKey?: boolean
    apiSecret?: boolean
    environment?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["apiIntegration"]>

  export type ApiIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    apiKey?: boolean
    apiSecret?: boolean
    environment?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["apiIntegration"]>

  export type ApiIntegrationSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    apiKey?: boolean
    apiSecret?: boolean
    environment?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ApiIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiIntegration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      apiKey: string
      apiSecret: string | null
      environment: string
      isActive: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["apiIntegration"]>
    composites: {}
  }

  type ApiIntegrationGetPayload<S extends boolean | null | undefined | ApiIntegrationDefaultArgs> = $Result.GetResult<Prisma.$ApiIntegrationPayload, S>

  type ApiIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiIntegrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiIntegrationCountAggregateInputType | true
    }

  export interface ApiIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiIntegration'], meta: { name: 'ApiIntegration' } }
    /**
     * Find zero or one ApiIntegration that matches the filter.
     * @param {ApiIntegrationFindUniqueArgs} args - Arguments to find a ApiIntegration
     * @example
     * // Get one ApiIntegration
     * const apiIntegration = await prisma.apiIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiIntegrationFindUniqueArgs>(args: SelectSubset<T, ApiIntegrationFindUniqueArgs<ExtArgs>>): Prisma__ApiIntegrationClient<$Result.GetResult<Prisma.$ApiIntegrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiIntegration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiIntegrationFindUniqueOrThrowArgs} args - Arguments to find a ApiIntegration
     * @example
     * // Get one ApiIntegration
     * const apiIntegration = await prisma.apiIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiIntegrationClient<$Result.GetResult<Prisma.$ApiIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiIntegrationFindFirstArgs} args - Arguments to find a ApiIntegration
     * @example
     * // Get one ApiIntegration
     * const apiIntegration = await prisma.apiIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiIntegrationFindFirstArgs>(args?: SelectSubset<T, ApiIntegrationFindFirstArgs<ExtArgs>>): Prisma__ApiIntegrationClient<$Result.GetResult<Prisma.$ApiIntegrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiIntegrationFindFirstOrThrowArgs} args - Arguments to find a ApiIntegration
     * @example
     * // Get one ApiIntegration
     * const apiIntegration = await prisma.apiIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiIntegrationClient<$Result.GetResult<Prisma.$ApiIntegrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiIntegrations
     * const apiIntegrations = await prisma.apiIntegration.findMany()
     * 
     * // Get first 10 ApiIntegrations
     * const apiIntegrations = await prisma.apiIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiIntegrationWithIdOnly = await prisma.apiIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiIntegrationFindManyArgs>(args?: SelectSubset<T, ApiIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiIntegrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiIntegration.
     * @param {ApiIntegrationCreateArgs} args - Arguments to create a ApiIntegration.
     * @example
     * // Create one ApiIntegration
     * const ApiIntegration = await prisma.apiIntegration.create({
     *   data: {
     *     // ... data to create a ApiIntegration
     *   }
     * })
     * 
     */
    create<T extends ApiIntegrationCreateArgs>(args: SelectSubset<T, ApiIntegrationCreateArgs<ExtArgs>>): Prisma__ApiIntegrationClient<$Result.GetResult<Prisma.$ApiIntegrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiIntegrations.
     * @param {ApiIntegrationCreateManyArgs} args - Arguments to create many ApiIntegrations.
     * @example
     * // Create many ApiIntegrations
     * const apiIntegration = await prisma.apiIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiIntegrationCreateManyArgs>(args?: SelectSubset<T, ApiIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiIntegrations and returns the data saved in the database.
     * @param {ApiIntegrationCreateManyAndReturnArgs} args - Arguments to create many ApiIntegrations.
     * @example
     * // Create many ApiIntegrations
     * const apiIntegration = await prisma.apiIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiIntegrations and only return the `id`
     * const apiIntegrationWithIdOnly = await prisma.apiIntegration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiIntegrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiIntegration.
     * @param {ApiIntegrationDeleteArgs} args - Arguments to delete one ApiIntegration.
     * @example
     * // Delete one ApiIntegration
     * const ApiIntegration = await prisma.apiIntegration.delete({
     *   where: {
     *     // ... filter to delete one ApiIntegration
     *   }
     * })
     * 
     */
    delete<T extends ApiIntegrationDeleteArgs>(args: SelectSubset<T, ApiIntegrationDeleteArgs<ExtArgs>>): Prisma__ApiIntegrationClient<$Result.GetResult<Prisma.$ApiIntegrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiIntegration.
     * @param {ApiIntegrationUpdateArgs} args - Arguments to update one ApiIntegration.
     * @example
     * // Update one ApiIntegration
     * const apiIntegration = await prisma.apiIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiIntegrationUpdateArgs>(args: SelectSubset<T, ApiIntegrationUpdateArgs<ExtArgs>>): Prisma__ApiIntegrationClient<$Result.GetResult<Prisma.$ApiIntegrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiIntegrations.
     * @param {ApiIntegrationDeleteManyArgs} args - Arguments to filter ApiIntegrations to delete.
     * @example
     * // Delete a few ApiIntegrations
     * const { count } = await prisma.apiIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiIntegrationDeleteManyArgs>(args?: SelectSubset<T, ApiIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiIntegrations
     * const apiIntegration = await prisma.apiIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiIntegrationUpdateManyArgs>(args: SelectSubset<T, ApiIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiIntegration.
     * @param {ApiIntegrationUpsertArgs} args - Arguments to update or create a ApiIntegration.
     * @example
     * // Update or create a ApiIntegration
     * const apiIntegration = await prisma.apiIntegration.upsert({
     *   create: {
     *     // ... data to create a ApiIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiIntegration we want to update
     *   }
     * })
     */
    upsert<T extends ApiIntegrationUpsertArgs>(args: SelectSubset<T, ApiIntegrationUpsertArgs<ExtArgs>>): Prisma__ApiIntegrationClient<$Result.GetResult<Prisma.$ApiIntegrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiIntegrationCountArgs} args - Arguments to filter ApiIntegrations to count.
     * @example
     * // Count the number of ApiIntegrations
     * const count = await prisma.apiIntegration.count({
     *   where: {
     *     // ... the filter for the ApiIntegrations we want to count
     *   }
     * })
    **/
    count<T extends ApiIntegrationCountArgs>(
      args?: Subset<T, ApiIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiIntegrationAggregateArgs>(args: Subset<T, ApiIntegrationAggregateArgs>): Prisma.PrismaPromise<GetApiIntegrationAggregateType<T>>

    /**
     * Group by ApiIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: ApiIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiIntegration model
   */
  readonly fields: ApiIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiIntegration model
   */ 
  interface ApiIntegrationFieldRefs {
    readonly id: FieldRef<"ApiIntegration", 'String'>
    readonly name: FieldRef<"ApiIntegration", 'String'>
    readonly displayName: FieldRef<"ApiIntegration", 'String'>
    readonly apiKey: FieldRef<"ApiIntegration", 'String'>
    readonly apiSecret: FieldRef<"ApiIntegration", 'String'>
    readonly environment: FieldRef<"ApiIntegration", 'String'>
    readonly isActive: FieldRef<"ApiIntegration", 'Boolean'>
    readonly metadata: FieldRef<"ApiIntegration", 'Json'>
    readonly createdAt: FieldRef<"ApiIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiIntegration findUnique
   */
  export type ApiIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiIntegration
     */
    select?: ApiIntegrationSelect<ExtArgs> | null
    /**
     * Filter, which ApiIntegration to fetch.
     */
    where: ApiIntegrationWhereUniqueInput
  }

  /**
   * ApiIntegration findUniqueOrThrow
   */
  export type ApiIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiIntegration
     */
    select?: ApiIntegrationSelect<ExtArgs> | null
    /**
     * Filter, which ApiIntegration to fetch.
     */
    where: ApiIntegrationWhereUniqueInput
  }

  /**
   * ApiIntegration findFirst
   */
  export type ApiIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiIntegration
     */
    select?: ApiIntegrationSelect<ExtArgs> | null
    /**
     * Filter, which ApiIntegration to fetch.
     */
    where?: ApiIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiIntegrations to fetch.
     */
    orderBy?: ApiIntegrationOrderByWithRelationInput | ApiIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiIntegrations.
     */
    cursor?: ApiIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiIntegrations.
     */
    distinct?: ApiIntegrationScalarFieldEnum | ApiIntegrationScalarFieldEnum[]
  }

  /**
   * ApiIntegration findFirstOrThrow
   */
  export type ApiIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiIntegration
     */
    select?: ApiIntegrationSelect<ExtArgs> | null
    /**
     * Filter, which ApiIntegration to fetch.
     */
    where?: ApiIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiIntegrations to fetch.
     */
    orderBy?: ApiIntegrationOrderByWithRelationInput | ApiIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiIntegrations.
     */
    cursor?: ApiIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiIntegrations.
     */
    distinct?: ApiIntegrationScalarFieldEnum | ApiIntegrationScalarFieldEnum[]
  }

  /**
   * ApiIntegration findMany
   */
  export type ApiIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiIntegration
     */
    select?: ApiIntegrationSelect<ExtArgs> | null
    /**
     * Filter, which ApiIntegrations to fetch.
     */
    where?: ApiIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiIntegrations to fetch.
     */
    orderBy?: ApiIntegrationOrderByWithRelationInput | ApiIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiIntegrations.
     */
    cursor?: ApiIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiIntegrations.
     */
    skip?: number
    distinct?: ApiIntegrationScalarFieldEnum | ApiIntegrationScalarFieldEnum[]
  }

  /**
   * ApiIntegration create
   */
  export type ApiIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiIntegration
     */
    select?: ApiIntegrationSelect<ExtArgs> | null
    /**
     * The data needed to create a ApiIntegration.
     */
    data: XOR<ApiIntegrationCreateInput, ApiIntegrationUncheckedCreateInput>
  }

  /**
   * ApiIntegration createMany
   */
  export type ApiIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiIntegrations.
     */
    data: ApiIntegrationCreateManyInput | ApiIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiIntegration createManyAndReturn
   */
  export type ApiIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiIntegration
     */
    select?: ApiIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiIntegrations.
     */
    data: ApiIntegrationCreateManyInput | ApiIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiIntegration update
   */
  export type ApiIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiIntegration
     */
    select?: ApiIntegrationSelect<ExtArgs> | null
    /**
     * The data needed to update a ApiIntegration.
     */
    data: XOR<ApiIntegrationUpdateInput, ApiIntegrationUncheckedUpdateInput>
    /**
     * Choose, which ApiIntegration to update.
     */
    where: ApiIntegrationWhereUniqueInput
  }

  /**
   * ApiIntegration updateMany
   */
  export type ApiIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiIntegrations.
     */
    data: XOR<ApiIntegrationUpdateManyMutationInput, ApiIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which ApiIntegrations to update
     */
    where?: ApiIntegrationWhereInput
  }

  /**
   * ApiIntegration upsert
   */
  export type ApiIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiIntegration
     */
    select?: ApiIntegrationSelect<ExtArgs> | null
    /**
     * The filter to search for the ApiIntegration to update in case it exists.
     */
    where: ApiIntegrationWhereUniqueInput
    /**
     * In case the ApiIntegration found by the `where` argument doesn't exist, create a new ApiIntegration with this data.
     */
    create: XOR<ApiIntegrationCreateInput, ApiIntegrationUncheckedCreateInput>
    /**
     * In case the ApiIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiIntegrationUpdateInput, ApiIntegrationUncheckedUpdateInput>
  }

  /**
   * ApiIntegration delete
   */
  export type ApiIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiIntegration
     */
    select?: ApiIntegrationSelect<ExtArgs> | null
    /**
     * Filter which ApiIntegration to delete.
     */
    where: ApiIntegrationWhereUniqueInput
  }

  /**
   * ApiIntegration deleteMany
   */
  export type ApiIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiIntegrations to delete
     */
    where?: ApiIntegrationWhereInput
  }

  /**
   * ApiIntegration without action
   */
  export type ApiIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiIntegration
     */
    select?: ApiIntegrationSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    verified: 'verified',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    phone: 'phone',
    birthDate: 'birthDate',
    profession: 'profession',
    profileImageUrl: 'profileImageUrl',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    country: 'country'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalAmount: 'totalAmount',
    status: 'status',
    paymentMethod: 'paymentMethod',
    paymentStatus: 'paymentStatus',
    customerName: 'customerName',
    customerEmail: 'customerEmail',
    customerCpfCnpj: 'customerCpfCnpj',
    customerPhone: 'customerPhone',
    pixCode: 'pixCode',
    boletoUrl: 'boletoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    title: 'title',
    description: 'description',
    price: 'price',
    paperId: 'paperId',
    courseId: 'courseId',
    ebookId: 'ebookId'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const PaperScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    paperType: 'paperType',
    academicArea: 'academicArea',
    price: 'price',
    pageCount: 'pageCount',
    authorName: 'authorName',
    language: 'language',
    keywords: 'keywords',
    previewUrl: 'previewUrl',
    fileUrl: 'fileUrl',
    thumbnailUrl: 'thumbnailUrl',
    isFree: 'isFree',
    createdAt: 'createdAt'
  };

  export type PaperScalarFieldEnum = (typeof PaperScalarFieldEnum)[keyof typeof PaperScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    academicArea: 'academicArea',
    instructorName: 'instructorName',
    instructorBio: 'instructorBio',
    price: 'price',
    duration: 'duration',
    level: 'level',
    thumbnailUrl: 'thumbnailUrl',
    videoUrl: 'videoUrl',
    status: 'status',
    isFeatured: 'isFeatured',
    createdAt: 'createdAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const EbookScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    academicArea: 'academicArea',
    authorName: 'authorName',
    price: 'price',
    pageCount: 'pageCount',
    fileUrl: 'fileUrl',
    coverUrl: 'coverUrl',
    createdAt: 'createdAt'
  };

  export type EbookScalarFieldEnum = (typeof EbookScalarFieldEnum)[keyof typeof EbookScalarFieldEnum]


  export const EbookFileScalarFieldEnum: {
    id: 'id',
    ebookId: 'ebookId',
    fileUrl: 'fileUrl',
    fileName: 'fileName',
    fileSize: 'fileSize',
    createdAt: 'createdAt'
  };

  export type EbookFileScalarFieldEnum = (typeof EbookFileScalarFieldEnum)[keyof typeof EbookFileScalarFieldEnum]


  export const CertificateScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    certificateNumber: 'certificateNumber',
    grade: 'grade',
    completionDate: 'completionDate',
    qrCodeUrl: 'qrCodeUrl',
    createdAt: 'createdAt'
  };

  export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


  export const LibraryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    itemType: 'itemType',
    itemId: 'itemId',
    downloadUrl: 'downloadUrl',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type LibraryScalarFieldEnum = (typeof LibraryScalarFieldEnum)[keyof typeof LibraryScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    slug: 'slug',
    excerpt: 'excerpt',
    coverImageUrl: 'coverImageUrl',
    published: 'published',
    status: 'status',
    publishedAt: 'publishedAt',
    authorId: 'authorId',
    categoryId: 'categoryId',
    views: 'views',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    metaKeywords: 'metaKeywords',
    ogImage: 'ogImage',
    canonicalUrl: 'canonicalUrl',
    readingTime: 'readingTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const BlogTagScalarFieldEnum: {
    postId: 'postId',
    tagId: 'tagId'
  };

  export type BlogTagScalarFieldEnum = (typeof BlogTagScalarFieldEnum)[keyof typeof BlogTagScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    postId: 'postId',
    userId: 'userId',
    parentId: 'parentId',
    approved: 'approved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const LikeScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


  export const CollaboratorApplicationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fullName: 'fullName',
    email: 'email',
    phone: 'phone',
    cpf: 'cpf',
    birthDate: 'birthDate',
    zipCode: 'zipCode',
    address: 'address',
    city: 'city',
    state: 'state',
    area: 'area',
    education: 'education',
    experience: 'experience',
    skills: 'skills',
    availability: 'availability',
    expectedSalary: 'expectedSalary',
    resumeUrl: 'resumeUrl',
    portfolioUrls: 'portfolioUrls',
    linkedin: 'linkedin',
    github: 'github',
    status: 'status',
    stage: 'stage',
    score: 'score',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    reviewedAt: 'reviewedAt',
    approvedAt: 'approvedAt',
    rejectedAt: 'rejectedAt',
    reviewerId: 'reviewerId'
  };

  export type CollaboratorApplicationScalarFieldEnum = (typeof CollaboratorApplicationScalarFieldEnum)[keyof typeof CollaboratorApplicationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    subject: 'subject',
    message: 'message',
    status: 'status',
    replied: 'replied',
    repliedAt: 'repliedAt',
    replyContent: 'replyContent',
    assignedTo: 'assignedTo',
    priority: 'priority',
    category: 'category',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const LegalDocumentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    content: 'content',
    version: 'version',
    active: 'active',
    publishedBy: 'publishedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LegalDocumentScalarFieldEnum = (typeof LegalDocumentScalarFieldEnum)[keyof typeof LegalDocumentScalarFieldEnum]


  export const MessageTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    content: 'content',
    variables: 'variables',
    category: 'category',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageTemplateScalarFieldEnum = (typeof MessageTemplateScalarFieldEnum)[keyof typeof MessageTemplateScalarFieldEnum]


  export const DownloadTrackingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    itemId: 'itemId',
    itemType: 'itemType',
    downloadedAt: 'downloadedAt'
  };

  export type DownloadTrackingScalarFieldEnum = (typeof DownloadTrackingScalarFieldEnum)[keyof typeof DownloadTrackingScalarFieldEnum]


  export const CustomPaperScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    paperType: 'paperType',
    academicArea: 'academicArea',
    pageCount: 'pageCount',
    deadline: 'deadline',
    urgency: 'urgency',
    requirements: 'requirements',
    keywords: 'keywords',
    references: 'references',
    requirementFiles: 'requirementFiles',
    deliveryFiles: 'deliveryFiles',
    quotedPrice: 'quotedPrice',
    finalPrice: 'finalPrice',
    paymentStatus: 'paymentStatus',
    status: 'status',
    adminNotes: 'adminNotes',
    rejectionReason: 'rejectionReason',
    requestedAt: 'requestedAt',
    quotedAt: 'quotedAt',
    approvedAt: 'approvedAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    orderId: 'orderId'
  };

  export type CustomPaperScalarFieldEnum = (typeof CustomPaperScalarFieldEnum)[keyof typeof CustomPaperScalarFieldEnum]


  export const CustomPaperMessageScalarFieldEnum: {
    id: 'id',
    customPaperId: 'customPaperId',
    senderId: 'senderId',
    content: 'content',
    attachments: 'attachments',
    isFromAdmin: 'isFromAdmin',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type CustomPaperMessageScalarFieldEnum = (typeof CustomPaperMessageScalarFieldEnum)[keyof typeof CustomPaperMessageScalarFieldEnum]


  export const CourseModuleScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    title: 'title',
    description: 'description',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseModuleScalarFieldEnum = (typeof CourseModuleScalarFieldEnum)[keyof typeof CourseModuleScalarFieldEnum]


  export const CourseLessonScalarFieldEnum: {
    id: 'id',
    moduleId: 'moduleId',
    title: 'title',
    description: 'description',
    videoUrl: 'videoUrl',
    content: 'content',
    duration: 'duration',
    order: 'order',
    isEnabled: 'isEnabled',
    attachments: 'attachments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseLessonScalarFieldEnum = (typeof CourseLessonScalarFieldEnum)[keyof typeof CourseLessonScalarFieldEnum]


  export const CourseProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    lessonId: 'lessonId',
    completed: 'completed',
    watchTime: 'watchTime',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseProgressScalarFieldEnum = (typeof CourseProgressScalarFieldEnum)[keyof typeof CourseProgressScalarFieldEnum]


  export const CourseEnrollmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    enrolledAt: 'enrolledAt',
    completedAt: 'completedAt',
    progress: 'progress'
  };

  export type CourseEnrollmentScalarFieldEnum = (typeof CourseEnrollmentScalarFieldEnum)[keyof typeof CourseEnrollmentScalarFieldEnum]


  export const PostAnalyticsScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    date: 'date',
    views: 'views',
    uniqueViews: 'uniqueViews',
    shares: 'shares',
    avgTimeOnPage: 'avgTimeOnPage',
    bounceRate: 'bounceRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostAnalyticsScalarFieldEnum = (typeof PostAnalyticsScalarFieldEnum)[keyof typeof PostAnalyticsScalarFieldEnum]


  export const NewsletterSubscriberScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NewsletterSubscriberScalarFieldEnum = (typeof NewsletterSubscriberScalarFieldEnum)[keyof typeof NewsletterSubscriberScalarFieldEnum]


  export const NewsletterSubscriptionScalarFieldEnum: {
    subscriberId: 'subscriberId',
    categoryId: 'categoryId',
    createdAt: 'createdAt'
  };

  export type NewsletterSubscriptionScalarFieldEnum = (typeof NewsletterSubscriptionScalarFieldEnum)[keyof typeof NewsletterSubscriptionScalarFieldEnum]


  export const PostNotificationScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    sentAt: 'sentAt',
    subscriberCount: 'subscriberCount',
    subject: 'subject',
    emailContent: 'emailContent',
    createdAt: 'createdAt'
  };

  export type PostNotificationScalarFieldEnum = (typeof PostNotificationScalarFieldEnum)[keyof typeof PostNotificationScalarFieldEnum]


  export const EvaluationScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    evaluatorId: 'evaluatorId',
    experienceScore: 'experienceScore',
    skillsScore: 'skillsScore',
    educationScore: 'educationScore',
    culturalFitScore: 'culturalFitScore',
    totalScore: 'totalScore',
    recommendation: 'recommendation',
    comments: 'comments',
    createdAt: 'createdAt'
  };

  export type EvaluationScalarFieldEnum = (typeof EvaluationScalarFieldEnum)[keyof typeof EvaluationScalarFieldEnum]


  export const NoteScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    authorId: 'authorId',
    content: 'content',
    isPrivate: 'isPrivate',
    createdAt: 'createdAt'
  };

  export type NoteScalarFieldEnum = (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum]


  export const InterviewScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    scheduledAt: 'scheduledAt',
    duration: 'duration',
    type: 'type',
    location: 'location',
    meetingUrl: 'meetingUrl',
    interviewerId: 'interviewerId',
    status: 'status',
    feedback: 'feedback',
    result: 'result',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InterviewScalarFieldEnum = (typeof InterviewScalarFieldEnum)[keyof typeof InterviewScalarFieldEnum]


  export const ApiIntegrationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    apiKey: 'apiKey',
    apiSecret: 'apiSecret',
    environment: 'environment',
    isActive: 'isActive',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApiIntegrationScalarFieldEnum = (typeof ApiIntegrationScalarFieldEnum)[keyof typeof ApiIntegrationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'PaperType'
   */
  export type EnumPaperTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaperType'>
    


  /**
   * Reference to a field of type 'PaperType[]'
   */
  export type ListEnumPaperTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaperType[]'>
    


  /**
   * Reference to a field of type 'AcademicArea'
   */
  export type EnumAcademicAreaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AcademicArea'>
    


  /**
   * Reference to a field of type 'AcademicArea[]'
   */
  export type ListEnumAcademicAreaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AcademicArea[]'>
    


  /**
   * Reference to a field of type 'CourseLevel'
   */
  export type EnumCourseLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseLevel'>
    


  /**
   * Reference to a field of type 'CourseLevel[]'
   */
  export type ListEnumCourseLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseLevel[]'>
    


  /**
   * Reference to a field of type 'CourseStatus'
   */
  export type EnumCourseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseStatus'>
    


  /**
   * Reference to a field of type 'CourseStatus[]'
   */
  export type ListEnumCourseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseStatus[]'>
    


  /**
   * Reference to a field of type 'LibraryItemType'
   */
  export type EnumLibraryItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LibraryItemType'>
    


  /**
   * Reference to a field of type 'LibraryItemType[]'
   */
  export type ListEnumLibraryItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LibraryItemType[]'>
    


  /**
   * Reference to a field of type 'PostStatus'
   */
  export type EnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus'>
    


  /**
   * Reference to a field of type 'PostStatus[]'
   */
  export type ListEnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ApplicationStatus'
   */
  export type EnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus'>
    


  /**
   * Reference to a field of type 'ApplicationStatus[]'
   */
  export type ListEnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'ApplicationStage'
   */
  export type EnumApplicationStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStage'>
    


  /**
   * Reference to a field of type 'ApplicationStage[]'
   */
  export type ListEnumApplicationStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStage[]'>
    


  /**
   * Reference to a field of type 'MessageStatus'
   */
  export type EnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus'>
    


  /**
   * Reference to a field of type 'MessageStatus[]'
   */
  export type ListEnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'LegalType'
   */
  export type EnumLegalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LegalType'>
    


  /**
   * Reference to a field of type 'LegalType[]'
   */
  export type ListEnumLegalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LegalType[]'>
    


  /**
   * Reference to a field of type 'CustomPaperUrgency'
   */
  export type EnumCustomPaperUrgencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomPaperUrgency'>
    


  /**
   * Reference to a field of type 'CustomPaperUrgency[]'
   */
  export type ListEnumCustomPaperUrgencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomPaperUrgency[]'>
    


  /**
   * Reference to a field of type 'CustomPaperStatus'
   */
  export type EnumCustomPaperStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomPaperStatus'>
    


  /**
   * Reference to a field of type 'CustomPaperStatus[]'
   */
  export type ListEnumCustomPaperStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomPaperStatus[]'>
    


  /**
   * Reference to a field of type 'EvaluationRecommendation'
   */
  export type EnumEvaluationRecommendationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvaluationRecommendation'>
    


  /**
   * Reference to a field of type 'EvaluationRecommendation[]'
   */
  export type ListEnumEvaluationRecommendationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvaluationRecommendation[]'>
    


  /**
   * Reference to a field of type 'InterviewType'
   */
  export type EnumInterviewTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterviewType'>
    


  /**
   * Reference to a field of type 'InterviewType[]'
   */
  export type ListEnumInterviewTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterviewType[]'>
    


  /**
   * Reference to a field of type 'InterviewStatus'
   */
  export type EnumInterviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterviewStatus'>
    


  /**
   * Reference to a field of type 'InterviewStatus[]'
   */
  export type ListEnumInterviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterviewStatus[]'>
    


  /**
   * Reference to a field of type 'InterviewResult'
   */
  export type EnumInterviewResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterviewResult'>
    


  /**
   * Reference to a field of type 'InterviewResult[]'
   */
  export type ListEnumInterviewResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterviewResult[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    verified?: BoolFilter<"User"> | boolean
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    phone?: StringNullableFilter<"User"> | string | null
    birthDate?: StringNullableFilter<"User"> | string | null
    profession?: StringNullableFilter<"User"> | string | null
    profileImageUrl?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zipCode?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    orders?: OrderListRelationFilter
    collaboratorApplications?: CollaboratorApplicationListRelationFilter
    reviewedApplications?: CollaboratorApplicationListRelationFilter
    evaluations?: EvaluationListRelationFilter
    notes?: NoteListRelationFilter
    interviews?: InterviewListRelationFilter
    certificates?: CertificateListRelationFilter
    library?: LibraryListRelationFilter
    customPapers?: CustomPaperListRelationFilter
    customPaperMessages?: CustomPaperMessageListRelationFilter
    courseProgress?: CourseProgressListRelationFilter
    courseEnrollments?: CourseEnrollmentListRelationFilter
    blogPosts?: BlogPostListRelationFilter
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    verified?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phone?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    profession?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    orders?: OrderOrderByRelationAggregateInput
    collaboratorApplications?: CollaboratorApplicationOrderByRelationAggregateInput
    reviewedApplications?: CollaboratorApplicationOrderByRelationAggregateInput
    evaluations?: EvaluationOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    interviews?: InterviewOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
    library?: LibraryOrderByRelationAggregateInput
    customPapers?: CustomPaperOrderByRelationAggregateInput
    customPaperMessages?: CustomPaperMessageOrderByRelationAggregateInput
    courseProgress?: CourseProgressOrderByRelationAggregateInput
    courseEnrollments?: CourseEnrollmentOrderByRelationAggregateInput
    blogPosts?: BlogPostOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    verified?: BoolFilter<"User"> | boolean
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    phone?: StringNullableFilter<"User"> | string | null
    birthDate?: StringNullableFilter<"User"> | string | null
    profession?: StringNullableFilter<"User"> | string | null
    profileImageUrl?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zipCode?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    orders?: OrderListRelationFilter
    collaboratorApplications?: CollaboratorApplicationListRelationFilter
    reviewedApplications?: CollaboratorApplicationListRelationFilter
    evaluations?: EvaluationListRelationFilter
    notes?: NoteListRelationFilter
    interviews?: InterviewListRelationFilter
    certificates?: CertificateListRelationFilter
    library?: LibraryListRelationFilter
    customPapers?: CustomPaperListRelationFilter
    customPaperMessages?: CustomPaperMessageListRelationFilter
    courseProgress?: CourseProgressListRelationFilter
    courseEnrollments?: CourseEnrollmentListRelationFilter
    blogPosts?: BlogPostListRelationFilter
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    verified?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phone?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    profession?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    verified?: BoolWithAggregatesFilter<"User"> | boolean
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    birthDate?: StringNullableWithAggregatesFilter<"User"> | string | null
    profession?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileImageUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    state?: StringNullableWithAggregatesFilter<"User"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringNullableFilter<"Order"> | string | null
    totalAmount?: IntFilter<"Order"> | number
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    paymentMethod?: EnumPaymentMethodNullableFilter<"Order"> | $Enums.PaymentMethod | null
    paymentStatus?: EnumPaymentStatusFilter<"Order"> | $Enums.PaymentStatus
    customerName?: StringFilter<"Order"> | string
    customerEmail?: StringFilter<"Order"> | string
    customerCpfCnpj?: StringFilter<"Order"> | string
    customerPhone?: StringNullableFilter<"Order"> | string | null
    pixCode?: StringNullableFilter<"Order"> | string | null
    boletoUrl?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    items?: OrderItemListRelationFilter
    customPaper?: XOR<CustomPaperNullableRelationFilter, CustomPaperWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerCpfCnpj?: SortOrder
    customerPhone?: SortOrderInput | SortOrder
    pixCode?: SortOrderInput | SortOrder
    boletoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    customPaper?: CustomPaperOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: StringNullableFilter<"Order"> | string | null
    totalAmount?: IntFilter<"Order"> | number
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    paymentMethod?: EnumPaymentMethodNullableFilter<"Order"> | $Enums.PaymentMethod | null
    paymentStatus?: EnumPaymentStatusFilter<"Order"> | $Enums.PaymentStatus
    customerName?: StringFilter<"Order"> | string
    customerEmail?: StringFilter<"Order"> | string
    customerCpfCnpj?: StringFilter<"Order"> | string
    customerPhone?: StringNullableFilter<"Order"> | string | null
    pixCode?: StringNullableFilter<"Order"> | string | null
    boletoUrl?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    items?: OrderItemListRelationFilter
    customPaper?: XOR<CustomPaperNullableRelationFilter, CustomPaperWhereInput> | null
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerCpfCnpj?: SortOrder
    customerPhone?: SortOrderInput | SortOrder
    pixCode?: SortOrderInput | SortOrder
    boletoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    userId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    totalAmount?: IntWithAggregatesFilter<"Order"> | number
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    paymentMethod?: EnumPaymentMethodNullableWithAggregatesFilter<"Order"> | $Enums.PaymentMethod | null
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"Order"> | $Enums.PaymentStatus
    customerName?: StringWithAggregatesFilter<"Order"> | string
    customerEmail?: StringWithAggregatesFilter<"Order"> | string
    customerCpfCnpj?: StringWithAggregatesFilter<"Order"> | string
    customerPhone?: StringNullableWithAggregatesFilter<"Order"> | string | null
    pixCode?: StringNullableWithAggregatesFilter<"Order"> | string | null
    boletoUrl?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    title?: StringFilter<"OrderItem"> | string
    description?: StringNullableFilter<"OrderItem"> | string | null
    price?: IntFilter<"OrderItem"> | number
    paperId?: StringNullableFilter<"OrderItem"> | string | null
    courseId?: StringNullableFilter<"OrderItem"> | string | null
    ebookId?: StringNullableFilter<"OrderItem"> | string | null
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    paper?: XOR<PaperNullableRelationFilter, PaperWhereInput> | null
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
    ebook?: XOR<EbookNullableRelationFilter, EbookWhereInput> | null
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    paperId?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    ebookId?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    paper?: PaperOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    ebook?: EbookOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    title?: StringFilter<"OrderItem"> | string
    description?: StringNullableFilter<"OrderItem"> | string | null
    price?: IntFilter<"OrderItem"> | number
    paperId?: StringNullableFilter<"OrderItem"> | string | null
    courseId?: StringNullableFilter<"OrderItem"> | string | null
    ebookId?: StringNullableFilter<"OrderItem"> | string | null
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    paper?: XOR<PaperNullableRelationFilter, PaperWhereInput> | null
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
    ebook?: XOR<EbookNullableRelationFilter, EbookWhereInput> | null
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    paperId?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    ebookId?: SortOrderInput | SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    title?: StringWithAggregatesFilter<"OrderItem"> | string
    description?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    price?: IntWithAggregatesFilter<"OrderItem"> | number
    paperId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    courseId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    ebookId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
  }

  export type PaperWhereInput = {
    AND?: PaperWhereInput | PaperWhereInput[]
    OR?: PaperWhereInput[]
    NOT?: PaperWhereInput | PaperWhereInput[]
    id?: StringFilter<"Paper"> | string
    title?: StringFilter<"Paper"> | string
    description?: StringFilter<"Paper"> | string
    paperType?: EnumPaperTypeFilter<"Paper"> | $Enums.PaperType
    academicArea?: EnumAcademicAreaFilter<"Paper"> | $Enums.AcademicArea
    price?: IntFilter<"Paper"> | number
    pageCount?: IntFilter<"Paper"> | number
    authorName?: StringFilter<"Paper"> | string
    language?: StringFilter<"Paper"> | string
    keywords?: StringNullableFilter<"Paper"> | string | null
    previewUrl?: StringNullableFilter<"Paper"> | string | null
    fileUrl?: StringFilter<"Paper"> | string
    thumbnailUrl?: StringNullableFilter<"Paper"> | string | null
    isFree?: BoolFilter<"Paper"> | boolean
    createdAt?: DateTimeFilter<"Paper"> | Date | string
    orderItems?: OrderItemListRelationFilter
  }

  export type PaperOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    paperType?: SortOrder
    academicArea?: SortOrder
    price?: SortOrder
    pageCount?: SortOrder
    authorName?: SortOrder
    language?: SortOrder
    keywords?: SortOrderInput | SortOrder
    previewUrl?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    isFree?: SortOrder
    createdAt?: SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
  }

  export type PaperWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaperWhereInput | PaperWhereInput[]
    OR?: PaperWhereInput[]
    NOT?: PaperWhereInput | PaperWhereInput[]
    title?: StringFilter<"Paper"> | string
    description?: StringFilter<"Paper"> | string
    paperType?: EnumPaperTypeFilter<"Paper"> | $Enums.PaperType
    academicArea?: EnumAcademicAreaFilter<"Paper"> | $Enums.AcademicArea
    price?: IntFilter<"Paper"> | number
    pageCount?: IntFilter<"Paper"> | number
    authorName?: StringFilter<"Paper"> | string
    language?: StringFilter<"Paper"> | string
    keywords?: StringNullableFilter<"Paper"> | string | null
    previewUrl?: StringNullableFilter<"Paper"> | string | null
    fileUrl?: StringFilter<"Paper"> | string
    thumbnailUrl?: StringNullableFilter<"Paper"> | string | null
    isFree?: BoolFilter<"Paper"> | boolean
    createdAt?: DateTimeFilter<"Paper"> | Date | string
    orderItems?: OrderItemListRelationFilter
  }, "id">

  export type PaperOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    paperType?: SortOrder
    academicArea?: SortOrder
    price?: SortOrder
    pageCount?: SortOrder
    authorName?: SortOrder
    language?: SortOrder
    keywords?: SortOrderInput | SortOrder
    previewUrl?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    isFree?: SortOrder
    createdAt?: SortOrder
    _count?: PaperCountOrderByAggregateInput
    _avg?: PaperAvgOrderByAggregateInput
    _max?: PaperMaxOrderByAggregateInput
    _min?: PaperMinOrderByAggregateInput
    _sum?: PaperSumOrderByAggregateInput
  }

  export type PaperScalarWhereWithAggregatesInput = {
    AND?: PaperScalarWhereWithAggregatesInput | PaperScalarWhereWithAggregatesInput[]
    OR?: PaperScalarWhereWithAggregatesInput[]
    NOT?: PaperScalarWhereWithAggregatesInput | PaperScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Paper"> | string
    title?: StringWithAggregatesFilter<"Paper"> | string
    description?: StringWithAggregatesFilter<"Paper"> | string
    paperType?: EnumPaperTypeWithAggregatesFilter<"Paper"> | $Enums.PaperType
    academicArea?: EnumAcademicAreaWithAggregatesFilter<"Paper"> | $Enums.AcademicArea
    price?: IntWithAggregatesFilter<"Paper"> | number
    pageCount?: IntWithAggregatesFilter<"Paper"> | number
    authorName?: StringWithAggregatesFilter<"Paper"> | string
    language?: StringWithAggregatesFilter<"Paper"> | string
    keywords?: StringNullableWithAggregatesFilter<"Paper"> | string | null
    previewUrl?: StringNullableWithAggregatesFilter<"Paper"> | string | null
    fileUrl?: StringWithAggregatesFilter<"Paper"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Paper"> | string | null
    isFree?: BoolWithAggregatesFilter<"Paper"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Paper"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    academicArea?: EnumAcademicAreaFilter<"Course"> | $Enums.AcademicArea
    instructorName?: StringFilter<"Course"> | string
    instructorBio?: StringNullableFilter<"Course"> | string | null
    price?: IntFilter<"Course"> | number
    duration?: IntFilter<"Course"> | number
    level?: EnumCourseLevelFilter<"Course"> | $Enums.CourseLevel
    thumbnailUrl?: StringNullableFilter<"Course"> | string | null
    videoUrl?: StringNullableFilter<"Course"> | string | null
    status?: EnumCourseStatusFilter<"Course"> | $Enums.CourseStatus
    isFeatured?: BoolFilter<"Course"> | boolean
    createdAt?: DateTimeFilter<"Course"> | Date | string
    orderItems?: OrderItemListRelationFilter
    certificates?: CertificateListRelationFilter
    modules?: CourseModuleListRelationFilter
    enrollments?: CourseEnrollmentListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academicArea?: SortOrder
    instructorName?: SortOrder
    instructorBio?: SortOrderInput | SortOrder
    price?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
    modules?: CourseModuleOrderByRelationAggregateInput
    enrollments?: CourseEnrollmentOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    academicArea?: EnumAcademicAreaFilter<"Course"> | $Enums.AcademicArea
    instructorName?: StringFilter<"Course"> | string
    instructorBio?: StringNullableFilter<"Course"> | string | null
    price?: IntFilter<"Course"> | number
    duration?: IntFilter<"Course"> | number
    level?: EnumCourseLevelFilter<"Course"> | $Enums.CourseLevel
    thumbnailUrl?: StringNullableFilter<"Course"> | string | null
    videoUrl?: StringNullableFilter<"Course"> | string | null
    status?: EnumCourseStatusFilter<"Course"> | $Enums.CourseStatus
    isFeatured?: BoolFilter<"Course"> | boolean
    createdAt?: DateTimeFilter<"Course"> | Date | string
    orderItems?: OrderItemListRelationFilter
    certificates?: CertificateListRelationFilter
    modules?: CourseModuleListRelationFilter
    enrollments?: CourseEnrollmentListRelationFilter
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academicArea?: SortOrder
    instructorName?: SortOrder
    instructorBio?: SortOrderInput | SortOrder
    price?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    title?: StringWithAggregatesFilter<"Course"> | string
    description?: StringWithAggregatesFilter<"Course"> | string
    academicArea?: EnumAcademicAreaWithAggregatesFilter<"Course"> | $Enums.AcademicArea
    instructorName?: StringWithAggregatesFilter<"Course"> | string
    instructorBio?: StringNullableWithAggregatesFilter<"Course"> | string | null
    price?: IntWithAggregatesFilter<"Course"> | number
    duration?: IntWithAggregatesFilter<"Course"> | number
    level?: EnumCourseLevelWithAggregatesFilter<"Course"> | $Enums.CourseLevel
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Course"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"Course"> | string | null
    status?: EnumCourseStatusWithAggregatesFilter<"Course"> | $Enums.CourseStatus
    isFeatured?: BoolWithAggregatesFilter<"Course"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type EbookWhereInput = {
    AND?: EbookWhereInput | EbookWhereInput[]
    OR?: EbookWhereInput[]
    NOT?: EbookWhereInput | EbookWhereInput[]
    id?: StringFilter<"Ebook"> | string
    title?: StringFilter<"Ebook"> | string
    description?: StringFilter<"Ebook"> | string
    academicArea?: EnumAcademicAreaFilter<"Ebook"> | $Enums.AcademicArea
    authorName?: StringFilter<"Ebook"> | string
    price?: IntFilter<"Ebook"> | number
    pageCount?: IntFilter<"Ebook"> | number
    fileUrl?: StringFilter<"Ebook"> | string
    coverUrl?: StringNullableFilter<"Ebook"> | string | null
    createdAt?: DateTimeFilter<"Ebook"> | Date | string
    files?: EbookFileListRelationFilter
    orderItems?: OrderItemListRelationFilter
  }

  export type EbookOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academicArea?: SortOrder
    authorName?: SortOrder
    price?: SortOrder
    pageCount?: SortOrder
    fileUrl?: SortOrder
    coverUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    files?: EbookFileOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
  }

  export type EbookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EbookWhereInput | EbookWhereInput[]
    OR?: EbookWhereInput[]
    NOT?: EbookWhereInput | EbookWhereInput[]
    title?: StringFilter<"Ebook"> | string
    description?: StringFilter<"Ebook"> | string
    academicArea?: EnumAcademicAreaFilter<"Ebook"> | $Enums.AcademicArea
    authorName?: StringFilter<"Ebook"> | string
    price?: IntFilter<"Ebook"> | number
    pageCount?: IntFilter<"Ebook"> | number
    fileUrl?: StringFilter<"Ebook"> | string
    coverUrl?: StringNullableFilter<"Ebook"> | string | null
    createdAt?: DateTimeFilter<"Ebook"> | Date | string
    files?: EbookFileListRelationFilter
    orderItems?: OrderItemListRelationFilter
  }, "id">

  export type EbookOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academicArea?: SortOrder
    authorName?: SortOrder
    price?: SortOrder
    pageCount?: SortOrder
    fileUrl?: SortOrder
    coverUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EbookCountOrderByAggregateInput
    _avg?: EbookAvgOrderByAggregateInput
    _max?: EbookMaxOrderByAggregateInput
    _min?: EbookMinOrderByAggregateInput
    _sum?: EbookSumOrderByAggregateInput
  }

  export type EbookScalarWhereWithAggregatesInput = {
    AND?: EbookScalarWhereWithAggregatesInput | EbookScalarWhereWithAggregatesInput[]
    OR?: EbookScalarWhereWithAggregatesInput[]
    NOT?: EbookScalarWhereWithAggregatesInput | EbookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ebook"> | string
    title?: StringWithAggregatesFilter<"Ebook"> | string
    description?: StringWithAggregatesFilter<"Ebook"> | string
    academicArea?: EnumAcademicAreaWithAggregatesFilter<"Ebook"> | $Enums.AcademicArea
    authorName?: StringWithAggregatesFilter<"Ebook"> | string
    price?: IntWithAggregatesFilter<"Ebook"> | number
    pageCount?: IntWithAggregatesFilter<"Ebook"> | number
    fileUrl?: StringWithAggregatesFilter<"Ebook"> | string
    coverUrl?: StringNullableWithAggregatesFilter<"Ebook"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Ebook"> | Date | string
  }

  export type EbookFileWhereInput = {
    AND?: EbookFileWhereInput | EbookFileWhereInput[]
    OR?: EbookFileWhereInput[]
    NOT?: EbookFileWhereInput | EbookFileWhereInput[]
    id?: StringFilter<"EbookFile"> | string
    ebookId?: StringFilter<"EbookFile"> | string
    fileUrl?: StringFilter<"EbookFile"> | string
    fileName?: StringFilter<"EbookFile"> | string
    fileSize?: IntNullableFilter<"EbookFile"> | number | null
    createdAt?: DateTimeFilter<"EbookFile"> | Date | string
    ebook?: XOR<EbookRelationFilter, EbookWhereInput>
  }

  export type EbookFileOrderByWithRelationInput = {
    id?: SortOrder
    ebookId?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    ebook?: EbookOrderByWithRelationInput
  }

  export type EbookFileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EbookFileWhereInput | EbookFileWhereInput[]
    OR?: EbookFileWhereInput[]
    NOT?: EbookFileWhereInput | EbookFileWhereInput[]
    ebookId?: StringFilter<"EbookFile"> | string
    fileUrl?: StringFilter<"EbookFile"> | string
    fileName?: StringFilter<"EbookFile"> | string
    fileSize?: IntNullableFilter<"EbookFile"> | number | null
    createdAt?: DateTimeFilter<"EbookFile"> | Date | string
    ebook?: XOR<EbookRelationFilter, EbookWhereInput>
  }, "id">

  export type EbookFileOrderByWithAggregationInput = {
    id?: SortOrder
    ebookId?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EbookFileCountOrderByAggregateInput
    _avg?: EbookFileAvgOrderByAggregateInput
    _max?: EbookFileMaxOrderByAggregateInput
    _min?: EbookFileMinOrderByAggregateInput
    _sum?: EbookFileSumOrderByAggregateInput
  }

  export type EbookFileScalarWhereWithAggregatesInput = {
    AND?: EbookFileScalarWhereWithAggregatesInput | EbookFileScalarWhereWithAggregatesInput[]
    OR?: EbookFileScalarWhereWithAggregatesInput[]
    NOT?: EbookFileScalarWhereWithAggregatesInput | EbookFileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EbookFile"> | string
    ebookId?: StringWithAggregatesFilter<"EbookFile"> | string
    fileUrl?: StringWithAggregatesFilter<"EbookFile"> | string
    fileName?: StringWithAggregatesFilter<"EbookFile"> | string
    fileSize?: IntNullableWithAggregatesFilter<"EbookFile"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"EbookFile"> | Date | string
  }

  export type CertificateWhereInput = {
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    id?: StringFilter<"Certificate"> | string
    userId?: StringFilter<"Certificate"> | string
    courseId?: StringFilter<"Certificate"> | string
    certificateNumber?: StringFilter<"Certificate"> | string
    grade?: IntFilter<"Certificate"> | number
    completionDate?: DateTimeFilter<"Certificate"> | Date | string
    qrCodeUrl?: StringFilter<"Certificate"> | string
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type CertificateOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    certificateNumber?: SortOrder
    grade?: SortOrder
    completionDate?: SortOrder
    qrCodeUrl?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type CertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    certificateNumber?: string
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    userId?: StringFilter<"Certificate"> | string
    courseId?: StringFilter<"Certificate"> | string
    grade?: IntFilter<"Certificate"> | number
    completionDate?: DateTimeFilter<"Certificate"> | Date | string
    qrCodeUrl?: StringFilter<"Certificate"> | string
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }, "id" | "certificateNumber">

  export type CertificateOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    certificateNumber?: SortOrder
    grade?: SortOrder
    completionDate?: SortOrder
    qrCodeUrl?: SortOrder
    createdAt?: SortOrder
    _count?: CertificateCountOrderByAggregateInput
    _avg?: CertificateAvgOrderByAggregateInput
    _max?: CertificateMaxOrderByAggregateInput
    _min?: CertificateMinOrderByAggregateInput
    _sum?: CertificateSumOrderByAggregateInput
  }

  export type CertificateScalarWhereWithAggregatesInput = {
    AND?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    OR?: CertificateScalarWhereWithAggregatesInput[]
    NOT?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certificate"> | string
    userId?: StringWithAggregatesFilter<"Certificate"> | string
    courseId?: StringWithAggregatesFilter<"Certificate"> | string
    certificateNumber?: StringWithAggregatesFilter<"Certificate"> | string
    grade?: IntWithAggregatesFilter<"Certificate"> | number
    completionDate?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
    qrCodeUrl?: StringWithAggregatesFilter<"Certificate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
  }

  export type LibraryWhereInput = {
    AND?: LibraryWhereInput | LibraryWhereInput[]
    OR?: LibraryWhereInput[]
    NOT?: LibraryWhereInput | LibraryWhereInput[]
    id?: StringFilter<"Library"> | string
    userId?: StringFilter<"Library"> | string
    itemType?: EnumLibraryItemTypeFilter<"Library"> | $Enums.LibraryItemType
    itemId?: StringFilter<"Library"> | string
    downloadUrl?: StringFilter<"Library"> | string
    expiresAt?: DateTimeNullableFilter<"Library"> | Date | string | null
    createdAt?: DateTimeFilter<"Library"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LibraryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    downloadUrl?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LibraryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LibraryWhereInput | LibraryWhereInput[]
    OR?: LibraryWhereInput[]
    NOT?: LibraryWhereInput | LibraryWhereInput[]
    userId?: StringFilter<"Library"> | string
    itemType?: EnumLibraryItemTypeFilter<"Library"> | $Enums.LibraryItemType
    itemId?: StringFilter<"Library"> | string
    downloadUrl?: StringFilter<"Library"> | string
    expiresAt?: DateTimeNullableFilter<"Library"> | Date | string | null
    createdAt?: DateTimeFilter<"Library"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type LibraryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    downloadUrl?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LibraryCountOrderByAggregateInput
    _max?: LibraryMaxOrderByAggregateInput
    _min?: LibraryMinOrderByAggregateInput
  }

  export type LibraryScalarWhereWithAggregatesInput = {
    AND?: LibraryScalarWhereWithAggregatesInput | LibraryScalarWhereWithAggregatesInput[]
    OR?: LibraryScalarWhereWithAggregatesInput[]
    NOT?: LibraryScalarWhereWithAggregatesInput | LibraryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Library"> | string
    userId?: StringWithAggregatesFilter<"Library"> | string
    itemType?: EnumLibraryItemTypeWithAggregatesFilter<"Library"> | $Enums.LibraryItemType
    itemId?: StringWithAggregatesFilter<"Library"> | string
    downloadUrl?: StringWithAggregatesFilter<"Library"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Library"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Library"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    posts?: BlogPostListRelationFilter
    subscribers?: NewsletterSubscriptionListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: BlogPostOrderByRelationAggregateInput
    subscribers?: NewsletterSubscriptionOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    posts?: BlogPostListRelationFilter
    subscribers?: NewsletterSubscriptionListRelationFilter
  }, "id" | "name" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    posts?: BlogTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: BlogTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    posts?: BlogTagListRelationFilter
  }, "id" | "name" | "slug">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    slug?: StringWithAggregatesFilter<"Tag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    coverImageUrl?: StringNullableFilter<"BlogPost"> | string | null
    published?: BoolFilter<"BlogPost"> | boolean
    status?: EnumPostStatusFilter<"BlogPost"> | $Enums.PostStatus
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    authorId?: StringFilter<"BlogPost"> | string
    categoryId?: StringNullableFilter<"BlogPost"> | string | null
    views?: IntFilter<"BlogPost"> | number
    metaTitle?: StringNullableFilter<"BlogPost"> | string | null
    metaDescription?: StringNullableFilter<"BlogPost"> | string | null
    metaKeywords?: StringNullableListFilter<"BlogPost">
    ogImage?: StringNullableFilter<"BlogPost"> | string | null
    canonicalUrl?: StringNullableFilter<"BlogPost"> | string | null
    readingTime?: IntNullableFilter<"BlogPost"> | number | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    tags?: BlogTagListRelationFilter
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    analytics?: PostAnalyticsListRelationFilter
    notifications?: PostNotificationListRelationFilter
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    coverImageUrl?: SortOrderInput | SortOrder
    published?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    authorId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    views?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrder
    ogImage?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    readingTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    tags?: BlogTagOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
    analytics?: PostAnalyticsOrderByRelationAggregateInput
    notifications?: PostNotificationOrderByRelationAggregateInput
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    title?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    coverImageUrl?: StringNullableFilter<"BlogPost"> | string | null
    published?: BoolFilter<"BlogPost"> | boolean
    status?: EnumPostStatusFilter<"BlogPost"> | $Enums.PostStatus
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    authorId?: StringFilter<"BlogPost"> | string
    categoryId?: StringNullableFilter<"BlogPost"> | string | null
    views?: IntFilter<"BlogPost"> | number
    metaTitle?: StringNullableFilter<"BlogPost"> | string | null
    metaDescription?: StringNullableFilter<"BlogPost"> | string | null
    metaKeywords?: StringNullableListFilter<"BlogPost">
    ogImage?: StringNullableFilter<"BlogPost"> | string | null
    canonicalUrl?: StringNullableFilter<"BlogPost"> | string | null
    readingTime?: IntNullableFilter<"BlogPost"> | number | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    tags?: BlogTagListRelationFilter
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    analytics?: PostAnalyticsListRelationFilter
    notifications?: PostNotificationListRelationFilter
  }, "id" | "slug">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    coverImageUrl?: SortOrderInput | SortOrder
    published?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    authorId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    views?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrder
    ogImage?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    readingTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _avg?: BlogPostAvgOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
    _sum?: BlogPostSumOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPost"> | string
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    content?: StringWithAggregatesFilter<"BlogPost"> | string
    slug?: StringWithAggregatesFilter<"BlogPost"> | string
    excerpt?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    coverImageUrl?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    published?: BoolWithAggregatesFilter<"BlogPost"> | boolean
    status?: EnumPostStatusWithAggregatesFilter<"BlogPost"> | $Enums.PostStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"BlogPost"> | Date | string | null
    authorId?: StringWithAggregatesFilter<"BlogPost"> | string
    categoryId?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    views?: IntWithAggregatesFilter<"BlogPost"> | number
    metaTitle?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    metaKeywords?: StringNullableListFilter<"BlogPost">
    ogImage?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    canonicalUrl?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    readingTime?: IntNullableWithAggregatesFilter<"BlogPost"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
  }

  export type BlogTagWhereInput = {
    AND?: BlogTagWhereInput | BlogTagWhereInput[]
    OR?: BlogTagWhereInput[]
    NOT?: BlogTagWhereInput | BlogTagWhereInput[]
    postId?: StringFilter<"BlogTag"> | string
    tagId?: StringFilter<"BlogTag"> | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }

  export type BlogTagOrderByWithRelationInput = {
    postId?: SortOrder
    tagId?: SortOrder
    post?: BlogPostOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type BlogTagWhereUniqueInput = Prisma.AtLeast<{
    postId_tagId?: BlogTagPostIdTagIdCompoundUniqueInput
    AND?: BlogTagWhereInput | BlogTagWhereInput[]
    OR?: BlogTagWhereInput[]
    NOT?: BlogTagWhereInput | BlogTagWhereInput[]
    postId?: StringFilter<"BlogTag"> | string
    tagId?: StringFilter<"BlogTag"> | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }, "postId_tagId">

  export type BlogTagOrderByWithAggregationInput = {
    postId?: SortOrder
    tagId?: SortOrder
    _count?: BlogTagCountOrderByAggregateInput
    _max?: BlogTagMaxOrderByAggregateInput
    _min?: BlogTagMinOrderByAggregateInput
  }

  export type BlogTagScalarWhereWithAggregatesInput = {
    AND?: BlogTagScalarWhereWithAggregatesInput | BlogTagScalarWhereWithAggregatesInput[]
    OR?: BlogTagScalarWhereWithAggregatesInput[]
    NOT?: BlogTagScalarWhereWithAggregatesInput | BlogTagScalarWhereWithAggregatesInput[]
    postId?: StringWithAggregatesFilter<"BlogTag"> | string
    tagId?: StringWithAggregatesFilter<"BlogTag"> | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    approved?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    approved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: BlogPostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    parent?: CommentOrderByWithRelationInput
    replies?: CommentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    approved?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    approved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    postId?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    parentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    approved?: BoolWithAggregatesFilter<"Comment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type LikeWhereInput = {
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    id?: StringFilter<"Like"> | string
    postId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LikeOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    post?: BlogPostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_userId?: LikePostIdUserIdCompoundUniqueInput
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    postId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "postId_userId">

  export type LikeOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: LikeCountOrderByAggregateInput
    _max?: LikeMaxOrderByAggregateInput
    _min?: LikeMinOrderByAggregateInput
  }

  export type LikeScalarWhereWithAggregatesInput = {
    AND?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    OR?: LikeScalarWhereWithAggregatesInput[]
    NOT?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Like"> | string
    postId?: StringWithAggregatesFilter<"Like"> | string
    userId?: StringWithAggregatesFilter<"Like"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Like"> | Date | string
  }

  export type CollaboratorApplicationWhereInput = {
    AND?: CollaboratorApplicationWhereInput | CollaboratorApplicationWhereInput[]
    OR?: CollaboratorApplicationWhereInput[]
    NOT?: CollaboratorApplicationWhereInput | CollaboratorApplicationWhereInput[]
    id?: StringFilter<"CollaboratorApplication"> | string
    userId?: StringFilter<"CollaboratorApplication"> | string
    fullName?: StringFilter<"CollaboratorApplication"> | string
    email?: StringFilter<"CollaboratorApplication"> | string
    phone?: StringFilter<"CollaboratorApplication"> | string
    cpf?: StringNullableFilter<"CollaboratorApplication"> | string | null
    birthDate?: DateTimeNullableFilter<"CollaboratorApplication"> | Date | string | null
    zipCode?: StringNullableFilter<"CollaboratorApplication"> | string | null
    address?: StringNullableFilter<"CollaboratorApplication"> | string | null
    city?: StringNullableFilter<"CollaboratorApplication"> | string | null
    state?: StringNullableFilter<"CollaboratorApplication"> | string | null
    area?: StringFilter<"CollaboratorApplication"> | string
    education?: StringNullableFilter<"CollaboratorApplication"> | string | null
    experience?: StringFilter<"CollaboratorApplication"> | string
    skills?: JsonNullableFilter<"CollaboratorApplication">
    availability?: StringFilter<"CollaboratorApplication"> | string
    expectedSalary?: FloatNullableFilter<"CollaboratorApplication"> | number | null
    resumeUrl?: StringNullableFilter<"CollaboratorApplication"> | string | null
    portfolioUrls?: JsonNullableFilter<"CollaboratorApplication">
    linkedin?: StringNullableFilter<"CollaboratorApplication"> | string | null
    github?: StringNullableFilter<"CollaboratorApplication"> | string | null
    status?: EnumApplicationStatusFilter<"CollaboratorApplication"> | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFilter<"CollaboratorApplication"> | $Enums.ApplicationStage
    score?: IntNullableFilter<"CollaboratorApplication"> | number | null
    createdAt?: DateTimeFilter<"CollaboratorApplication"> | Date | string
    updatedAt?: DateTimeFilter<"CollaboratorApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"CollaboratorApplication"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"CollaboratorApplication"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"CollaboratorApplication"> | Date | string | null
    reviewerId?: StringNullableFilter<"CollaboratorApplication"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    evaluations?: EvaluationListRelationFilter
    notes?: NoteListRelationFilter
    interviews?: InterviewListRelationFilter
    reviewer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type CollaboratorApplicationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    cpf?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    area?: SortOrder
    education?: SortOrderInput | SortOrder
    experience?: SortOrder
    skills?: SortOrderInput | SortOrder
    availability?: SortOrder
    expectedSalary?: SortOrderInput | SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    portfolioUrls?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    status?: SortOrder
    stage?: SortOrder
    score?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    reviewerId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    evaluations?: EvaluationOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    interviews?: InterviewOrderByRelationAggregateInput
    reviewer?: UserOrderByWithRelationInput
  }

  export type CollaboratorApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cpf?: string
    AND?: CollaboratorApplicationWhereInput | CollaboratorApplicationWhereInput[]
    OR?: CollaboratorApplicationWhereInput[]
    NOT?: CollaboratorApplicationWhereInput | CollaboratorApplicationWhereInput[]
    userId?: StringFilter<"CollaboratorApplication"> | string
    fullName?: StringFilter<"CollaboratorApplication"> | string
    email?: StringFilter<"CollaboratorApplication"> | string
    phone?: StringFilter<"CollaboratorApplication"> | string
    birthDate?: DateTimeNullableFilter<"CollaboratorApplication"> | Date | string | null
    zipCode?: StringNullableFilter<"CollaboratorApplication"> | string | null
    address?: StringNullableFilter<"CollaboratorApplication"> | string | null
    city?: StringNullableFilter<"CollaboratorApplication"> | string | null
    state?: StringNullableFilter<"CollaboratorApplication"> | string | null
    area?: StringFilter<"CollaboratorApplication"> | string
    education?: StringNullableFilter<"CollaboratorApplication"> | string | null
    experience?: StringFilter<"CollaboratorApplication"> | string
    skills?: JsonNullableFilter<"CollaboratorApplication">
    availability?: StringFilter<"CollaboratorApplication"> | string
    expectedSalary?: FloatNullableFilter<"CollaboratorApplication"> | number | null
    resumeUrl?: StringNullableFilter<"CollaboratorApplication"> | string | null
    portfolioUrls?: JsonNullableFilter<"CollaboratorApplication">
    linkedin?: StringNullableFilter<"CollaboratorApplication"> | string | null
    github?: StringNullableFilter<"CollaboratorApplication"> | string | null
    status?: EnumApplicationStatusFilter<"CollaboratorApplication"> | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFilter<"CollaboratorApplication"> | $Enums.ApplicationStage
    score?: IntNullableFilter<"CollaboratorApplication"> | number | null
    createdAt?: DateTimeFilter<"CollaboratorApplication"> | Date | string
    updatedAt?: DateTimeFilter<"CollaboratorApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"CollaboratorApplication"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"CollaboratorApplication"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"CollaboratorApplication"> | Date | string | null
    reviewerId?: StringNullableFilter<"CollaboratorApplication"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    evaluations?: EvaluationListRelationFilter
    notes?: NoteListRelationFilter
    interviews?: InterviewListRelationFilter
    reviewer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "cpf">

  export type CollaboratorApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    cpf?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    area?: SortOrder
    education?: SortOrderInput | SortOrder
    experience?: SortOrder
    skills?: SortOrderInput | SortOrder
    availability?: SortOrder
    expectedSalary?: SortOrderInput | SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    portfolioUrls?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    status?: SortOrder
    stage?: SortOrder
    score?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    reviewerId?: SortOrderInput | SortOrder
    _count?: CollaboratorApplicationCountOrderByAggregateInput
    _avg?: CollaboratorApplicationAvgOrderByAggregateInput
    _max?: CollaboratorApplicationMaxOrderByAggregateInput
    _min?: CollaboratorApplicationMinOrderByAggregateInput
    _sum?: CollaboratorApplicationSumOrderByAggregateInput
  }

  export type CollaboratorApplicationScalarWhereWithAggregatesInput = {
    AND?: CollaboratorApplicationScalarWhereWithAggregatesInput | CollaboratorApplicationScalarWhereWithAggregatesInput[]
    OR?: CollaboratorApplicationScalarWhereWithAggregatesInput[]
    NOT?: CollaboratorApplicationScalarWhereWithAggregatesInput | CollaboratorApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CollaboratorApplication"> | string
    userId?: StringWithAggregatesFilter<"CollaboratorApplication"> | string
    fullName?: StringWithAggregatesFilter<"CollaboratorApplication"> | string
    email?: StringWithAggregatesFilter<"CollaboratorApplication"> | string
    phone?: StringWithAggregatesFilter<"CollaboratorApplication"> | string
    cpf?: StringNullableWithAggregatesFilter<"CollaboratorApplication"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"CollaboratorApplication"> | Date | string | null
    zipCode?: StringNullableWithAggregatesFilter<"CollaboratorApplication"> | string | null
    address?: StringNullableWithAggregatesFilter<"CollaboratorApplication"> | string | null
    city?: StringNullableWithAggregatesFilter<"CollaboratorApplication"> | string | null
    state?: StringNullableWithAggregatesFilter<"CollaboratorApplication"> | string | null
    area?: StringWithAggregatesFilter<"CollaboratorApplication"> | string
    education?: StringNullableWithAggregatesFilter<"CollaboratorApplication"> | string | null
    experience?: StringWithAggregatesFilter<"CollaboratorApplication"> | string
    skills?: JsonNullableWithAggregatesFilter<"CollaboratorApplication">
    availability?: StringWithAggregatesFilter<"CollaboratorApplication"> | string
    expectedSalary?: FloatNullableWithAggregatesFilter<"CollaboratorApplication"> | number | null
    resumeUrl?: StringNullableWithAggregatesFilter<"CollaboratorApplication"> | string | null
    portfolioUrls?: JsonNullableWithAggregatesFilter<"CollaboratorApplication">
    linkedin?: StringNullableWithAggregatesFilter<"CollaboratorApplication"> | string | null
    github?: StringNullableWithAggregatesFilter<"CollaboratorApplication"> | string | null
    status?: EnumApplicationStatusWithAggregatesFilter<"CollaboratorApplication"> | $Enums.ApplicationStatus
    stage?: EnumApplicationStageWithAggregatesFilter<"CollaboratorApplication"> | $Enums.ApplicationStage
    score?: IntNullableWithAggregatesFilter<"CollaboratorApplication"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CollaboratorApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CollaboratorApplication"> | Date | string
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"CollaboratorApplication"> | Date | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"CollaboratorApplication"> | Date | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"CollaboratorApplication"> | Date | string | null
    reviewerId?: StringNullableWithAggregatesFilter<"CollaboratorApplication"> | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    name?: StringFilter<"Message"> | string
    email?: StringFilter<"Message"> | string
    phone?: StringNullableFilter<"Message"> | string | null
    subject?: StringFilter<"Message"> | string
    message?: StringFilter<"Message"> | string
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    replied?: BoolFilter<"Message"> | boolean
    repliedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    replyContent?: StringNullableFilter<"Message"> | string | null
    assignedTo?: StringNullableFilter<"Message"> | string | null
    priority?: EnumPriorityFilter<"Message"> | $Enums.Priority
    category?: StringNullableFilter<"Message"> | string | null
    metadata?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    replied?: SortOrder
    repliedAt?: SortOrderInput | SortOrder
    replyContent?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    priority?: SortOrder
    category?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    name?: StringFilter<"Message"> | string
    email?: StringFilter<"Message"> | string
    phone?: StringNullableFilter<"Message"> | string | null
    subject?: StringFilter<"Message"> | string
    message?: StringFilter<"Message"> | string
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    replied?: BoolFilter<"Message"> | boolean
    repliedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    replyContent?: StringNullableFilter<"Message"> | string | null
    assignedTo?: StringNullableFilter<"Message"> | string | null
    priority?: EnumPriorityFilter<"Message"> | $Enums.Priority
    category?: StringNullableFilter<"Message"> | string | null
    metadata?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    replied?: SortOrder
    repliedAt?: SortOrderInput | SortOrder
    replyContent?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    priority?: SortOrder
    category?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    name?: StringWithAggregatesFilter<"Message"> | string
    email?: StringWithAggregatesFilter<"Message"> | string
    phone?: StringNullableWithAggregatesFilter<"Message"> | string | null
    subject?: StringWithAggregatesFilter<"Message"> | string
    message?: StringWithAggregatesFilter<"Message"> | string
    status?: EnumMessageStatusWithAggregatesFilter<"Message"> | $Enums.MessageStatus
    replied?: BoolWithAggregatesFilter<"Message"> | boolean
    repliedAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    replyContent?: StringNullableWithAggregatesFilter<"Message"> | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"Message"> | string | null
    priority?: EnumPriorityWithAggregatesFilter<"Message"> | $Enums.Priority
    category?: StringNullableWithAggregatesFilter<"Message"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Message">
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type LegalDocumentWhereInput = {
    AND?: LegalDocumentWhereInput | LegalDocumentWhereInput[]
    OR?: LegalDocumentWhereInput[]
    NOT?: LegalDocumentWhereInput | LegalDocumentWhereInput[]
    id?: StringFilter<"LegalDocument"> | string
    type?: EnumLegalTypeFilter<"LegalDocument"> | $Enums.LegalType
    title?: StringFilter<"LegalDocument"> | string
    content?: StringFilter<"LegalDocument"> | string
    version?: StringFilter<"LegalDocument"> | string
    active?: BoolFilter<"LegalDocument"> | boolean
    publishedBy?: StringFilter<"LegalDocument"> | string
    createdAt?: DateTimeFilter<"LegalDocument"> | Date | string
    updatedAt?: DateTimeFilter<"LegalDocument"> | Date | string
  }

  export type LegalDocumentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    version?: SortOrder
    active?: SortOrder
    publishedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LegalDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    type_active?: LegalDocumentTypeActiveCompoundUniqueInput
    AND?: LegalDocumentWhereInput | LegalDocumentWhereInput[]
    OR?: LegalDocumentWhereInput[]
    NOT?: LegalDocumentWhereInput | LegalDocumentWhereInput[]
    type?: EnumLegalTypeFilter<"LegalDocument"> | $Enums.LegalType
    title?: StringFilter<"LegalDocument"> | string
    content?: StringFilter<"LegalDocument"> | string
    version?: StringFilter<"LegalDocument"> | string
    active?: BoolFilter<"LegalDocument"> | boolean
    publishedBy?: StringFilter<"LegalDocument"> | string
    createdAt?: DateTimeFilter<"LegalDocument"> | Date | string
    updatedAt?: DateTimeFilter<"LegalDocument"> | Date | string
  }, "id" | "type_active">

  export type LegalDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    version?: SortOrder
    active?: SortOrder
    publishedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LegalDocumentCountOrderByAggregateInput
    _max?: LegalDocumentMaxOrderByAggregateInput
    _min?: LegalDocumentMinOrderByAggregateInput
  }

  export type LegalDocumentScalarWhereWithAggregatesInput = {
    AND?: LegalDocumentScalarWhereWithAggregatesInput | LegalDocumentScalarWhereWithAggregatesInput[]
    OR?: LegalDocumentScalarWhereWithAggregatesInput[]
    NOT?: LegalDocumentScalarWhereWithAggregatesInput | LegalDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LegalDocument"> | string
    type?: EnumLegalTypeWithAggregatesFilter<"LegalDocument"> | $Enums.LegalType
    title?: StringWithAggregatesFilter<"LegalDocument"> | string
    content?: StringWithAggregatesFilter<"LegalDocument"> | string
    version?: StringWithAggregatesFilter<"LegalDocument"> | string
    active?: BoolWithAggregatesFilter<"LegalDocument"> | boolean
    publishedBy?: StringWithAggregatesFilter<"LegalDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LegalDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LegalDocument"> | Date | string
  }

  export type MessageTemplateWhereInput = {
    AND?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    OR?: MessageTemplateWhereInput[]
    NOT?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    id?: StringFilter<"MessageTemplate"> | string
    name?: StringFilter<"MessageTemplate"> | string
    subject?: StringFilter<"MessageTemplate"> | string
    content?: StringFilter<"MessageTemplate"> | string
    variables?: StringNullableListFilter<"MessageTemplate">
    category?: StringNullableFilter<"MessageTemplate"> | string | null
    createdBy?: StringFilter<"MessageTemplate"> | string
    createdAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MessageTemplate"> | Date | string
  }

  export type MessageTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    category?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    OR?: MessageTemplateWhereInput[]
    NOT?: MessageTemplateWhereInput | MessageTemplateWhereInput[]
    name?: StringFilter<"MessageTemplate"> | string
    subject?: StringFilter<"MessageTemplate"> | string
    content?: StringFilter<"MessageTemplate"> | string
    variables?: StringNullableListFilter<"MessageTemplate">
    category?: StringNullableFilter<"MessageTemplate"> | string | null
    createdBy?: StringFilter<"MessageTemplate"> | string
    createdAt?: DateTimeFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MessageTemplate"> | Date | string
  }, "id">

  export type MessageTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    category?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageTemplateCountOrderByAggregateInput
    _max?: MessageTemplateMaxOrderByAggregateInput
    _min?: MessageTemplateMinOrderByAggregateInput
  }

  export type MessageTemplateScalarWhereWithAggregatesInput = {
    AND?: MessageTemplateScalarWhereWithAggregatesInput | MessageTemplateScalarWhereWithAggregatesInput[]
    OR?: MessageTemplateScalarWhereWithAggregatesInput[]
    NOT?: MessageTemplateScalarWhereWithAggregatesInput | MessageTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageTemplate"> | string
    name?: StringWithAggregatesFilter<"MessageTemplate"> | string
    subject?: StringWithAggregatesFilter<"MessageTemplate"> | string
    content?: StringWithAggregatesFilter<"MessageTemplate"> | string
    variables?: StringNullableListFilter<"MessageTemplate">
    category?: StringNullableWithAggregatesFilter<"MessageTemplate"> | string | null
    createdBy?: StringWithAggregatesFilter<"MessageTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MessageTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MessageTemplate"> | Date | string
  }

  export type DownloadTrackingWhereInput = {
    AND?: DownloadTrackingWhereInput | DownloadTrackingWhereInput[]
    OR?: DownloadTrackingWhereInput[]
    NOT?: DownloadTrackingWhereInput | DownloadTrackingWhereInput[]
    id?: StringFilter<"DownloadTracking"> | string
    userId?: StringFilter<"DownloadTracking"> | string
    itemId?: StringFilter<"DownloadTracking"> | string
    itemType?: StringFilter<"DownloadTracking"> | string
    downloadedAt?: DateTimeFilter<"DownloadTracking"> | Date | string
  }

  export type DownloadTrackingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
    downloadedAt?: SortOrder
  }

  export type DownloadTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DownloadTrackingWhereInput | DownloadTrackingWhereInput[]
    OR?: DownloadTrackingWhereInput[]
    NOT?: DownloadTrackingWhereInput | DownloadTrackingWhereInput[]
    userId?: StringFilter<"DownloadTracking"> | string
    itemId?: StringFilter<"DownloadTracking"> | string
    itemType?: StringFilter<"DownloadTracking"> | string
    downloadedAt?: DateTimeFilter<"DownloadTracking"> | Date | string
  }, "id">

  export type DownloadTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
    downloadedAt?: SortOrder
    _count?: DownloadTrackingCountOrderByAggregateInput
    _max?: DownloadTrackingMaxOrderByAggregateInput
    _min?: DownloadTrackingMinOrderByAggregateInput
  }

  export type DownloadTrackingScalarWhereWithAggregatesInput = {
    AND?: DownloadTrackingScalarWhereWithAggregatesInput | DownloadTrackingScalarWhereWithAggregatesInput[]
    OR?: DownloadTrackingScalarWhereWithAggregatesInput[]
    NOT?: DownloadTrackingScalarWhereWithAggregatesInput | DownloadTrackingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DownloadTracking"> | string
    userId?: StringWithAggregatesFilter<"DownloadTracking"> | string
    itemId?: StringWithAggregatesFilter<"DownloadTracking"> | string
    itemType?: StringWithAggregatesFilter<"DownloadTracking"> | string
    downloadedAt?: DateTimeWithAggregatesFilter<"DownloadTracking"> | Date | string
  }

  export type CustomPaperWhereInput = {
    AND?: CustomPaperWhereInput | CustomPaperWhereInput[]
    OR?: CustomPaperWhereInput[]
    NOT?: CustomPaperWhereInput | CustomPaperWhereInput[]
    id?: StringFilter<"CustomPaper"> | string
    userId?: StringNullableFilter<"CustomPaper"> | string | null
    title?: StringFilter<"CustomPaper"> | string
    description?: StringFilter<"CustomPaper"> | string
    paperType?: EnumPaperTypeFilter<"CustomPaper"> | $Enums.PaperType
    academicArea?: EnumAcademicAreaFilter<"CustomPaper"> | $Enums.AcademicArea
    pageCount?: IntFilter<"CustomPaper"> | number
    deadline?: DateTimeFilter<"CustomPaper"> | Date | string
    urgency?: EnumCustomPaperUrgencyFilter<"CustomPaper"> | $Enums.CustomPaperUrgency
    requirements?: StringFilter<"CustomPaper"> | string
    keywords?: StringNullableFilter<"CustomPaper"> | string | null
    references?: StringNullableFilter<"CustomPaper"> | string | null
    requirementFiles?: StringNullableListFilter<"CustomPaper">
    deliveryFiles?: StringNullableListFilter<"CustomPaper">
    quotedPrice?: IntNullableFilter<"CustomPaper"> | number | null
    finalPrice?: IntNullableFilter<"CustomPaper"> | number | null
    paymentStatus?: EnumPaymentStatusFilter<"CustomPaper"> | $Enums.PaymentStatus
    status?: EnumCustomPaperStatusFilter<"CustomPaper"> | $Enums.CustomPaperStatus
    adminNotes?: StringNullableFilter<"CustomPaper"> | string | null
    rejectionReason?: StringNullableFilter<"CustomPaper"> | string | null
    requestedAt?: DateTimeFilter<"CustomPaper"> | Date | string
    quotedAt?: DateTimeNullableFilter<"CustomPaper"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"CustomPaper"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"CustomPaper"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CustomPaper"> | Date | string | null
    orderId?: StringNullableFilter<"CustomPaper"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    messages?: CustomPaperMessageListRelationFilter
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
  }

  export type CustomPaperOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    paperType?: SortOrder
    academicArea?: SortOrder
    pageCount?: SortOrder
    deadline?: SortOrder
    urgency?: SortOrder
    requirements?: SortOrder
    keywords?: SortOrderInput | SortOrder
    references?: SortOrderInput | SortOrder
    requirementFiles?: SortOrder
    deliveryFiles?: SortOrder
    quotedPrice?: SortOrderInput | SortOrder
    finalPrice?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    status?: SortOrder
    adminNotes?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    quotedAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    messages?: CustomPaperMessageOrderByRelationAggregateInput
    order?: OrderOrderByWithRelationInput
  }

  export type CustomPaperWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: CustomPaperWhereInput | CustomPaperWhereInput[]
    OR?: CustomPaperWhereInput[]
    NOT?: CustomPaperWhereInput | CustomPaperWhereInput[]
    userId?: StringNullableFilter<"CustomPaper"> | string | null
    title?: StringFilter<"CustomPaper"> | string
    description?: StringFilter<"CustomPaper"> | string
    paperType?: EnumPaperTypeFilter<"CustomPaper"> | $Enums.PaperType
    academicArea?: EnumAcademicAreaFilter<"CustomPaper"> | $Enums.AcademicArea
    pageCount?: IntFilter<"CustomPaper"> | number
    deadline?: DateTimeFilter<"CustomPaper"> | Date | string
    urgency?: EnumCustomPaperUrgencyFilter<"CustomPaper"> | $Enums.CustomPaperUrgency
    requirements?: StringFilter<"CustomPaper"> | string
    keywords?: StringNullableFilter<"CustomPaper"> | string | null
    references?: StringNullableFilter<"CustomPaper"> | string | null
    requirementFiles?: StringNullableListFilter<"CustomPaper">
    deliveryFiles?: StringNullableListFilter<"CustomPaper">
    quotedPrice?: IntNullableFilter<"CustomPaper"> | number | null
    finalPrice?: IntNullableFilter<"CustomPaper"> | number | null
    paymentStatus?: EnumPaymentStatusFilter<"CustomPaper"> | $Enums.PaymentStatus
    status?: EnumCustomPaperStatusFilter<"CustomPaper"> | $Enums.CustomPaperStatus
    adminNotes?: StringNullableFilter<"CustomPaper"> | string | null
    rejectionReason?: StringNullableFilter<"CustomPaper"> | string | null
    requestedAt?: DateTimeFilter<"CustomPaper"> | Date | string
    quotedAt?: DateTimeNullableFilter<"CustomPaper"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"CustomPaper"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"CustomPaper"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CustomPaper"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    messages?: CustomPaperMessageListRelationFilter
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
  }, "id" | "orderId">

  export type CustomPaperOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    paperType?: SortOrder
    academicArea?: SortOrder
    pageCount?: SortOrder
    deadline?: SortOrder
    urgency?: SortOrder
    requirements?: SortOrder
    keywords?: SortOrderInput | SortOrder
    references?: SortOrderInput | SortOrder
    requirementFiles?: SortOrder
    deliveryFiles?: SortOrder
    quotedPrice?: SortOrderInput | SortOrder
    finalPrice?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    status?: SortOrder
    adminNotes?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    quotedAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    _count?: CustomPaperCountOrderByAggregateInput
    _avg?: CustomPaperAvgOrderByAggregateInput
    _max?: CustomPaperMaxOrderByAggregateInput
    _min?: CustomPaperMinOrderByAggregateInput
    _sum?: CustomPaperSumOrderByAggregateInput
  }

  export type CustomPaperScalarWhereWithAggregatesInput = {
    AND?: CustomPaperScalarWhereWithAggregatesInput | CustomPaperScalarWhereWithAggregatesInput[]
    OR?: CustomPaperScalarWhereWithAggregatesInput[]
    NOT?: CustomPaperScalarWhereWithAggregatesInput | CustomPaperScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomPaper"> | string
    userId?: StringNullableWithAggregatesFilter<"CustomPaper"> | string | null
    title?: StringWithAggregatesFilter<"CustomPaper"> | string
    description?: StringWithAggregatesFilter<"CustomPaper"> | string
    paperType?: EnumPaperTypeWithAggregatesFilter<"CustomPaper"> | $Enums.PaperType
    academicArea?: EnumAcademicAreaWithAggregatesFilter<"CustomPaper"> | $Enums.AcademicArea
    pageCount?: IntWithAggregatesFilter<"CustomPaper"> | number
    deadline?: DateTimeWithAggregatesFilter<"CustomPaper"> | Date | string
    urgency?: EnumCustomPaperUrgencyWithAggregatesFilter<"CustomPaper"> | $Enums.CustomPaperUrgency
    requirements?: StringWithAggregatesFilter<"CustomPaper"> | string
    keywords?: StringNullableWithAggregatesFilter<"CustomPaper"> | string | null
    references?: StringNullableWithAggregatesFilter<"CustomPaper"> | string | null
    requirementFiles?: StringNullableListFilter<"CustomPaper">
    deliveryFiles?: StringNullableListFilter<"CustomPaper">
    quotedPrice?: IntNullableWithAggregatesFilter<"CustomPaper"> | number | null
    finalPrice?: IntNullableWithAggregatesFilter<"CustomPaper"> | number | null
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"CustomPaper"> | $Enums.PaymentStatus
    status?: EnumCustomPaperStatusWithAggregatesFilter<"CustomPaper"> | $Enums.CustomPaperStatus
    adminNotes?: StringNullableWithAggregatesFilter<"CustomPaper"> | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"CustomPaper"> | string | null
    requestedAt?: DateTimeWithAggregatesFilter<"CustomPaper"> | Date | string
    quotedAt?: DateTimeNullableWithAggregatesFilter<"CustomPaper"> | Date | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"CustomPaper"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"CustomPaper"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"CustomPaper"> | Date | string | null
    orderId?: StringNullableWithAggregatesFilter<"CustomPaper"> | string | null
  }

  export type CustomPaperMessageWhereInput = {
    AND?: CustomPaperMessageWhereInput | CustomPaperMessageWhereInput[]
    OR?: CustomPaperMessageWhereInput[]
    NOT?: CustomPaperMessageWhereInput | CustomPaperMessageWhereInput[]
    id?: StringFilter<"CustomPaperMessage"> | string
    customPaperId?: StringFilter<"CustomPaperMessage"> | string
    senderId?: StringFilter<"CustomPaperMessage"> | string
    content?: StringFilter<"CustomPaperMessage"> | string
    attachments?: StringNullableListFilter<"CustomPaperMessage">
    isFromAdmin?: BoolFilter<"CustomPaperMessage"> | boolean
    isRead?: BoolFilter<"CustomPaperMessage"> | boolean
    createdAt?: DateTimeFilter<"CustomPaperMessage"> | Date | string
    customPaper?: XOR<CustomPaperRelationFilter, CustomPaperWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CustomPaperMessageOrderByWithRelationInput = {
    id?: SortOrder
    customPaperId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    isFromAdmin?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    customPaper?: CustomPaperOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type CustomPaperMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomPaperMessageWhereInput | CustomPaperMessageWhereInput[]
    OR?: CustomPaperMessageWhereInput[]
    NOT?: CustomPaperMessageWhereInput | CustomPaperMessageWhereInput[]
    customPaperId?: StringFilter<"CustomPaperMessage"> | string
    senderId?: StringFilter<"CustomPaperMessage"> | string
    content?: StringFilter<"CustomPaperMessage"> | string
    attachments?: StringNullableListFilter<"CustomPaperMessage">
    isFromAdmin?: BoolFilter<"CustomPaperMessage"> | boolean
    isRead?: BoolFilter<"CustomPaperMessage"> | boolean
    createdAt?: DateTimeFilter<"CustomPaperMessage"> | Date | string
    customPaper?: XOR<CustomPaperRelationFilter, CustomPaperWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CustomPaperMessageOrderByWithAggregationInput = {
    id?: SortOrder
    customPaperId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    isFromAdmin?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: CustomPaperMessageCountOrderByAggregateInput
    _max?: CustomPaperMessageMaxOrderByAggregateInput
    _min?: CustomPaperMessageMinOrderByAggregateInput
  }

  export type CustomPaperMessageScalarWhereWithAggregatesInput = {
    AND?: CustomPaperMessageScalarWhereWithAggregatesInput | CustomPaperMessageScalarWhereWithAggregatesInput[]
    OR?: CustomPaperMessageScalarWhereWithAggregatesInput[]
    NOT?: CustomPaperMessageScalarWhereWithAggregatesInput | CustomPaperMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomPaperMessage"> | string
    customPaperId?: StringWithAggregatesFilter<"CustomPaperMessage"> | string
    senderId?: StringWithAggregatesFilter<"CustomPaperMessage"> | string
    content?: StringWithAggregatesFilter<"CustomPaperMessage"> | string
    attachments?: StringNullableListFilter<"CustomPaperMessage">
    isFromAdmin?: BoolWithAggregatesFilter<"CustomPaperMessage"> | boolean
    isRead?: BoolWithAggregatesFilter<"CustomPaperMessage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomPaperMessage"> | Date | string
  }

  export type CourseModuleWhereInput = {
    AND?: CourseModuleWhereInput | CourseModuleWhereInput[]
    OR?: CourseModuleWhereInput[]
    NOT?: CourseModuleWhereInput | CourseModuleWhereInput[]
    id?: StringFilter<"CourseModule"> | string
    courseId?: StringFilter<"CourseModule"> | string
    title?: StringFilter<"CourseModule"> | string
    description?: StringNullableFilter<"CourseModule"> | string | null
    order?: IntFilter<"CourseModule"> | number
    createdAt?: DateTimeFilter<"CourseModule"> | Date | string
    updatedAt?: DateTimeFilter<"CourseModule"> | Date | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    lessons?: CourseLessonListRelationFilter
  }

  export type CourseModuleOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    lessons?: CourseLessonOrderByRelationAggregateInput
  }

  export type CourseModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseModuleWhereInput | CourseModuleWhereInput[]
    OR?: CourseModuleWhereInput[]
    NOT?: CourseModuleWhereInput | CourseModuleWhereInput[]
    courseId?: StringFilter<"CourseModule"> | string
    title?: StringFilter<"CourseModule"> | string
    description?: StringNullableFilter<"CourseModule"> | string | null
    order?: IntFilter<"CourseModule"> | number
    createdAt?: DateTimeFilter<"CourseModule"> | Date | string
    updatedAt?: DateTimeFilter<"CourseModule"> | Date | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    lessons?: CourseLessonListRelationFilter
  }, "id">

  export type CourseModuleOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseModuleCountOrderByAggregateInput
    _avg?: CourseModuleAvgOrderByAggregateInput
    _max?: CourseModuleMaxOrderByAggregateInput
    _min?: CourseModuleMinOrderByAggregateInput
    _sum?: CourseModuleSumOrderByAggregateInput
  }

  export type CourseModuleScalarWhereWithAggregatesInput = {
    AND?: CourseModuleScalarWhereWithAggregatesInput | CourseModuleScalarWhereWithAggregatesInput[]
    OR?: CourseModuleScalarWhereWithAggregatesInput[]
    NOT?: CourseModuleScalarWhereWithAggregatesInput | CourseModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseModule"> | string
    courseId?: StringWithAggregatesFilter<"CourseModule"> | string
    title?: StringWithAggregatesFilter<"CourseModule"> | string
    description?: StringNullableWithAggregatesFilter<"CourseModule"> | string | null
    order?: IntWithAggregatesFilter<"CourseModule"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CourseModule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CourseModule"> | Date | string
  }

  export type CourseLessonWhereInput = {
    AND?: CourseLessonWhereInput | CourseLessonWhereInput[]
    OR?: CourseLessonWhereInput[]
    NOT?: CourseLessonWhereInput | CourseLessonWhereInput[]
    id?: StringFilter<"CourseLesson"> | string
    moduleId?: StringFilter<"CourseLesson"> | string
    title?: StringFilter<"CourseLesson"> | string
    description?: StringNullableFilter<"CourseLesson"> | string | null
    videoUrl?: StringNullableFilter<"CourseLesson"> | string | null
    content?: StringNullableFilter<"CourseLesson"> | string | null
    duration?: IntNullableFilter<"CourseLesson"> | number | null
    order?: IntFilter<"CourseLesson"> | number
    isEnabled?: BoolFilter<"CourseLesson"> | boolean
    attachments?: StringNullableListFilter<"CourseLesson">
    createdAt?: DateTimeFilter<"CourseLesson"> | Date | string
    updatedAt?: DateTimeFilter<"CourseLesson"> | Date | string
    module?: XOR<CourseModuleRelationFilter, CourseModuleWhereInput>
    progress?: CourseProgressListRelationFilter
  }

  export type CourseLessonOrderByWithRelationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    order?: SortOrder
    isEnabled?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    module?: CourseModuleOrderByWithRelationInput
    progress?: CourseProgressOrderByRelationAggregateInput
  }

  export type CourseLessonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseLessonWhereInput | CourseLessonWhereInput[]
    OR?: CourseLessonWhereInput[]
    NOT?: CourseLessonWhereInput | CourseLessonWhereInput[]
    moduleId?: StringFilter<"CourseLesson"> | string
    title?: StringFilter<"CourseLesson"> | string
    description?: StringNullableFilter<"CourseLesson"> | string | null
    videoUrl?: StringNullableFilter<"CourseLesson"> | string | null
    content?: StringNullableFilter<"CourseLesson"> | string | null
    duration?: IntNullableFilter<"CourseLesson"> | number | null
    order?: IntFilter<"CourseLesson"> | number
    isEnabled?: BoolFilter<"CourseLesson"> | boolean
    attachments?: StringNullableListFilter<"CourseLesson">
    createdAt?: DateTimeFilter<"CourseLesson"> | Date | string
    updatedAt?: DateTimeFilter<"CourseLesson"> | Date | string
    module?: XOR<CourseModuleRelationFilter, CourseModuleWhereInput>
    progress?: CourseProgressListRelationFilter
  }, "id">

  export type CourseLessonOrderByWithAggregationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    order?: SortOrder
    isEnabled?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseLessonCountOrderByAggregateInput
    _avg?: CourseLessonAvgOrderByAggregateInput
    _max?: CourseLessonMaxOrderByAggregateInput
    _min?: CourseLessonMinOrderByAggregateInput
    _sum?: CourseLessonSumOrderByAggregateInput
  }

  export type CourseLessonScalarWhereWithAggregatesInput = {
    AND?: CourseLessonScalarWhereWithAggregatesInput | CourseLessonScalarWhereWithAggregatesInput[]
    OR?: CourseLessonScalarWhereWithAggregatesInput[]
    NOT?: CourseLessonScalarWhereWithAggregatesInput | CourseLessonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseLesson"> | string
    moduleId?: StringWithAggregatesFilter<"CourseLesson"> | string
    title?: StringWithAggregatesFilter<"CourseLesson"> | string
    description?: StringNullableWithAggregatesFilter<"CourseLesson"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"CourseLesson"> | string | null
    content?: StringNullableWithAggregatesFilter<"CourseLesson"> | string | null
    duration?: IntNullableWithAggregatesFilter<"CourseLesson"> | number | null
    order?: IntWithAggregatesFilter<"CourseLesson"> | number
    isEnabled?: BoolWithAggregatesFilter<"CourseLesson"> | boolean
    attachments?: StringNullableListFilter<"CourseLesson">
    createdAt?: DateTimeWithAggregatesFilter<"CourseLesson"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CourseLesson"> | Date | string
  }

  export type CourseProgressWhereInput = {
    AND?: CourseProgressWhereInput | CourseProgressWhereInput[]
    OR?: CourseProgressWhereInput[]
    NOT?: CourseProgressWhereInput | CourseProgressWhereInput[]
    id?: StringFilter<"CourseProgress"> | string
    userId?: StringFilter<"CourseProgress"> | string
    lessonId?: StringFilter<"CourseProgress"> | string
    completed?: BoolFilter<"CourseProgress"> | boolean
    watchTime?: IntFilter<"CourseProgress"> | number
    completedAt?: DateTimeNullableFilter<"CourseProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"CourseProgress"> | Date | string
    updatedAt?: DateTimeFilter<"CourseProgress"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    lesson?: XOR<CourseLessonRelationFilter, CourseLessonWhereInput>
  }

  export type CourseProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    completed?: SortOrder
    watchTime?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    lesson?: CourseLessonOrderByWithRelationInput
  }

  export type CourseProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_lessonId?: CourseProgressUserIdLessonIdCompoundUniqueInput
    AND?: CourseProgressWhereInput | CourseProgressWhereInput[]
    OR?: CourseProgressWhereInput[]
    NOT?: CourseProgressWhereInput | CourseProgressWhereInput[]
    userId?: StringFilter<"CourseProgress"> | string
    lessonId?: StringFilter<"CourseProgress"> | string
    completed?: BoolFilter<"CourseProgress"> | boolean
    watchTime?: IntFilter<"CourseProgress"> | number
    completedAt?: DateTimeNullableFilter<"CourseProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"CourseProgress"> | Date | string
    updatedAt?: DateTimeFilter<"CourseProgress"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    lesson?: XOR<CourseLessonRelationFilter, CourseLessonWhereInput>
  }, "id" | "userId_lessonId">

  export type CourseProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    completed?: SortOrder
    watchTime?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseProgressCountOrderByAggregateInput
    _avg?: CourseProgressAvgOrderByAggregateInput
    _max?: CourseProgressMaxOrderByAggregateInput
    _min?: CourseProgressMinOrderByAggregateInput
    _sum?: CourseProgressSumOrderByAggregateInput
  }

  export type CourseProgressScalarWhereWithAggregatesInput = {
    AND?: CourseProgressScalarWhereWithAggregatesInput | CourseProgressScalarWhereWithAggregatesInput[]
    OR?: CourseProgressScalarWhereWithAggregatesInput[]
    NOT?: CourseProgressScalarWhereWithAggregatesInput | CourseProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseProgress"> | string
    userId?: StringWithAggregatesFilter<"CourseProgress"> | string
    lessonId?: StringWithAggregatesFilter<"CourseProgress"> | string
    completed?: BoolWithAggregatesFilter<"CourseProgress"> | boolean
    watchTime?: IntWithAggregatesFilter<"CourseProgress"> | number
    completedAt?: DateTimeNullableWithAggregatesFilter<"CourseProgress"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CourseProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CourseProgress"> | Date | string
  }

  export type CourseEnrollmentWhereInput = {
    AND?: CourseEnrollmentWhereInput | CourseEnrollmentWhereInput[]
    OR?: CourseEnrollmentWhereInput[]
    NOT?: CourseEnrollmentWhereInput | CourseEnrollmentWhereInput[]
    id?: StringFilter<"CourseEnrollment"> | string
    userId?: StringFilter<"CourseEnrollment"> | string
    courseId?: StringFilter<"CourseEnrollment"> | string
    enrolledAt?: DateTimeFilter<"CourseEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"CourseEnrollment"> | Date | string | null
    progress?: IntFilter<"CourseEnrollment"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type CourseEnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    progress?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type CourseEnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_courseId?: CourseEnrollmentUserIdCourseIdCompoundUniqueInput
    AND?: CourseEnrollmentWhereInput | CourseEnrollmentWhereInput[]
    OR?: CourseEnrollmentWhereInput[]
    NOT?: CourseEnrollmentWhereInput | CourseEnrollmentWhereInput[]
    userId?: StringFilter<"CourseEnrollment"> | string
    courseId?: StringFilter<"CourseEnrollment"> | string
    enrolledAt?: DateTimeFilter<"CourseEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"CourseEnrollment"> | Date | string | null
    progress?: IntFilter<"CourseEnrollment"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }, "id" | "userId_courseId">

  export type CourseEnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    progress?: SortOrder
    _count?: CourseEnrollmentCountOrderByAggregateInput
    _avg?: CourseEnrollmentAvgOrderByAggregateInput
    _max?: CourseEnrollmentMaxOrderByAggregateInput
    _min?: CourseEnrollmentMinOrderByAggregateInput
    _sum?: CourseEnrollmentSumOrderByAggregateInput
  }

  export type CourseEnrollmentScalarWhereWithAggregatesInput = {
    AND?: CourseEnrollmentScalarWhereWithAggregatesInput | CourseEnrollmentScalarWhereWithAggregatesInput[]
    OR?: CourseEnrollmentScalarWhereWithAggregatesInput[]
    NOT?: CourseEnrollmentScalarWhereWithAggregatesInput | CourseEnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseEnrollment"> | string
    userId?: StringWithAggregatesFilter<"CourseEnrollment"> | string
    courseId?: StringWithAggregatesFilter<"CourseEnrollment"> | string
    enrolledAt?: DateTimeWithAggregatesFilter<"CourseEnrollment"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"CourseEnrollment"> | Date | string | null
    progress?: IntWithAggregatesFilter<"CourseEnrollment"> | number
  }

  export type PostAnalyticsWhereInput = {
    AND?: PostAnalyticsWhereInput | PostAnalyticsWhereInput[]
    OR?: PostAnalyticsWhereInput[]
    NOT?: PostAnalyticsWhereInput | PostAnalyticsWhereInput[]
    id?: StringFilter<"PostAnalytics"> | string
    postId?: StringFilter<"PostAnalytics"> | string
    date?: DateTimeFilter<"PostAnalytics"> | Date | string
    views?: IntFilter<"PostAnalytics"> | number
    uniqueViews?: IntFilter<"PostAnalytics"> | number
    shares?: IntFilter<"PostAnalytics"> | number
    avgTimeOnPage?: IntFilter<"PostAnalytics"> | number
    bounceRate?: FloatFilter<"PostAnalytics"> | number
    createdAt?: DateTimeFilter<"PostAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"PostAnalytics"> | Date | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
  }

  export type PostAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    date?: SortOrder
    views?: SortOrder
    uniqueViews?: SortOrder
    shares?: SortOrder
    avgTimeOnPage?: SortOrder
    bounceRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: BlogPostOrderByWithRelationInput
  }

  export type PostAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_date?: PostAnalyticsPostIdDateCompoundUniqueInput
    AND?: PostAnalyticsWhereInput | PostAnalyticsWhereInput[]
    OR?: PostAnalyticsWhereInput[]
    NOT?: PostAnalyticsWhereInput | PostAnalyticsWhereInput[]
    postId?: StringFilter<"PostAnalytics"> | string
    date?: DateTimeFilter<"PostAnalytics"> | Date | string
    views?: IntFilter<"PostAnalytics"> | number
    uniqueViews?: IntFilter<"PostAnalytics"> | number
    shares?: IntFilter<"PostAnalytics"> | number
    avgTimeOnPage?: IntFilter<"PostAnalytics"> | number
    bounceRate?: FloatFilter<"PostAnalytics"> | number
    createdAt?: DateTimeFilter<"PostAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"PostAnalytics"> | Date | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
  }, "id" | "postId_date">

  export type PostAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    date?: SortOrder
    views?: SortOrder
    uniqueViews?: SortOrder
    shares?: SortOrder
    avgTimeOnPage?: SortOrder
    bounceRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostAnalyticsCountOrderByAggregateInput
    _avg?: PostAnalyticsAvgOrderByAggregateInput
    _max?: PostAnalyticsMaxOrderByAggregateInput
    _min?: PostAnalyticsMinOrderByAggregateInput
    _sum?: PostAnalyticsSumOrderByAggregateInput
  }

  export type PostAnalyticsScalarWhereWithAggregatesInput = {
    AND?: PostAnalyticsScalarWhereWithAggregatesInput | PostAnalyticsScalarWhereWithAggregatesInput[]
    OR?: PostAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: PostAnalyticsScalarWhereWithAggregatesInput | PostAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostAnalytics"> | string
    postId?: StringWithAggregatesFilter<"PostAnalytics"> | string
    date?: DateTimeWithAggregatesFilter<"PostAnalytics"> | Date | string
    views?: IntWithAggregatesFilter<"PostAnalytics"> | number
    uniqueViews?: IntWithAggregatesFilter<"PostAnalytics"> | number
    shares?: IntWithAggregatesFilter<"PostAnalytics"> | number
    avgTimeOnPage?: IntWithAggregatesFilter<"PostAnalytics"> | number
    bounceRate?: FloatWithAggregatesFilter<"PostAnalytics"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PostAnalytics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PostAnalytics"> | Date | string
  }

  export type NewsletterSubscriberWhereInput = {
    AND?: NewsletterSubscriberWhereInput | NewsletterSubscriberWhereInput[]
    OR?: NewsletterSubscriberWhereInput[]
    NOT?: NewsletterSubscriberWhereInput | NewsletterSubscriberWhereInput[]
    id?: StringFilter<"NewsletterSubscriber"> | string
    email?: StringFilter<"NewsletterSubscriber"> | string
    name?: StringNullableFilter<"NewsletterSubscriber"> | string | null
    active?: BoolFilter<"NewsletterSubscriber"> | boolean
    createdAt?: DateTimeFilter<"NewsletterSubscriber"> | Date | string
    updatedAt?: DateTimeFilter<"NewsletterSubscriber"> | Date | string
    subscriptions?: NewsletterSubscriptionListRelationFilter
  }

  export type NewsletterSubscriberOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptions?: NewsletterSubscriptionOrderByRelationAggregateInput
  }

  export type NewsletterSubscriberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: NewsletterSubscriberWhereInput | NewsletterSubscriberWhereInput[]
    OR?: NewsletterSubscriberWhereInput[]
    NOT?: NewsletterSubscriberWhereInput | NewsletterSubscriberWhereInput[]
    name?: StringNullableFilter<"NewsletterSubscriber"> | string | null
    active?: BoolFilter<"NewsletterSubscriber"> | boolean
    createdAt?: DateTimeFilter<"NewsletterSubscriber"> | Date | string
    updatedAt?: DateTimeFilter<"NewsletterSubscriber"> | Date | string
    subscriptions?: NewsletterSubscriptionListRelationFilter
  }, "id" | "email">

  export type NewsletterSubscriberOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NewsletterSubscriberCountOrderByAggregateInput
    _max?: NewsletterSubscriberMaxOrderByAggregateInput
    _min?: NewsletterSubscriberMinOrderByAggregateInput
  }

  export type NewsletterSubscriberScalarWhereWithAggregatesInput = {
    AND?: NewsletterSubscriberScalarWhereWithAggregatesInput | NewsletterSubscriberScalarWhereWithAggregatesInput[]
    OR?: NewsletterSubscriberScalarWhereWithAggregatesInput[]
    NOT?: NewsletterSubscriberScalarWhereWithAggregatesInput | NewsletterSubscriberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsletterSubscriber"> | string
    email?: StringWithAggregatesFilter<"NewsletterSubscriber"> | string
    name?: StringNullableWithAggregatesFilter<"NewsletterSubscriber"> | string | null
    active?: BoolWithAggregatesFilter<"NewsletterSubscriber"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NewsletterSubscriber"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NewsletterSubscriber"> | Date | string
  }

  export type NewsletterSubscriptionWhereInput = {
    AND?: NewsletterSubscriptionWhereInput | NewsletterSubscriptionWhereInput[]
    OR?: NewsletterSubscriptionWhereInput[]
    NOT?: NewsletterSubscriptionWhereInput | NewsletterSubscriptionWhereInput[]
    subscriberId?: StringFilter<"NewsletterSubscription"> | string
    categoryId?: StringFilter<"NewsletterSubscription"> | string
    createdAt?: DateTimeFilter<"NewsletterSubscription"> | Date | string
    subscriber?: XOR<NewsletterSubscriberRelationFilter, NewsletterSubscriberWhereInput>
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
  }

  export type NewsletterSubscriptionOrderByWithRelationInput = {
    subscriberId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    subscriber?: NewsletterSubscriberOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type NewsletterSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    subscriberId_categoryId?: NewsletterSubscriptionSubscriberIdCategoryIdCompoundUniqueInput
    AND?: NewsletterSubscriptionWhereInput | NewsletterSubscriptionWhereInput[]
    OR?: NewsletterSubscriptionWhereInput[]
    NOT?: NewsletterSubscriptionWhereInput | NewsletterSubscriptionWhereInput[]
    subscriberId?: StringFilter<"NewsletterSubscription"> | string
    categoryId?: StringFilter<"NewsletterSubscription"> | string
    createdAt?: DateTimeFilter<"NewsletterSubscription"> | Date | string
    subscriber?: XOR<NewsletterSubscriberRelationFilter, NewsletterSubscriberWhereInput>
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
  }, "subscriberId_categoryId">

  export type NewsletterSubscriptionOrderByWithAggregationInput = {
    subscriberId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    _count?: NewsletterSubscriptionCountOrderByAggregateInput
    _max?: NewsletterSubscriptionMaxOrderByAggregateInput
    _min?: NewsletterSubscriptionMinOrderByAggregateInput
  }

  export type NewsletterSubscriptionScalarWhereWithAggregatesInput = {
    AND?: NewsletterSubscriptionScalarWhereWithAggregatesInput | NewsletterSubscriptionScalarWhereWithAggregatesInput[]
    OR?: NewsletterSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: NewsletterSubscriptionScalarWhereWithAggregatesInput | NewsletterSubscriptionScalarWhereWithAggregatesInput[]
    subscriberId?: StringWithAggregatesFilter<"NewsletterSubscription"> | string
    categoryId?: StringWithAggregatesFilter<"NewsletterSubscription"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NewsletterSubscription"> | Date | string
  }

  export type PostNotificationWhereInput = {
    AND?: PostNotificationWhereInput | PostNotificationWhereInput[]
    OR?: PostNotificationWhereInput[]
    NOT?: PostNotificationWhereInput | PostNotificationWhereInput[]
    id?: StringFilter<"PostNotification"> | string
    postId?: StringFilter<"PostNotification"> | string
    sentAt?: DateTimeNullableFilter<"PostNotification"> | Date | string | null
    subscriberCount?: IntFilter<"PostNotification"> | number
    subject?: StringNullableFilter<"PostNotification"> | string | null
    emailContent?: StringNullableFilter<"PostNotification"> | string | null
    createdAt?: DateTimeFilter<"PostNotification"> | Date | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
  }

  export type PostNotificationOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    subscriberCount?: SortOrder
    subject?: SortOrderInput | SortOrder
    emailContent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    post?: BlogPostOrderByWithRelationInput
  }

  export type PostNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostNotificationWhereInput | PostNotificationWhereInput[]
    OR?: PostNotificationWhereInput[]
    NOT?: PostNotificationWhereInput | PostNotificationWhereInput[]
    postId?: StringFilter<"PostNotification"> | string
    sentAt?: DateTimeNullableFilter<"PostNotification"> | Date | string | null
    subscriberCount?: IntFilter<"PostNotification"> | number
    subject?: StringNullableFilter<"PostNotification"> | string | null
    emailContent?: StringNullableFilter<"PostNotification"> | string | null
    createdAt?: DateTimeFilter<"PostNotification"> | Date | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
  }, "id">

  export type PostNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    subscriberCount?: SortOrder
    subject?: SortOrderInput | SortOrder
    emailContent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PostNotificationCountOrderByAggregateInput
    _avg?: PostNotificationAvgOrderByAggregateInput
    _max?: PostNotificationMaxOrderByAggregateInput
    _min?: PostNotificationMinOrderByAggregateInput
    _sum?: PostNotificationSumOrderByAggregateInput
  }

  export type PostNotificationScalarWhereWithAggregatesInput = {
    AND?: PostNotificationScalarWhereWithAggregatesInput | PostNotificationScalarWhereWithAggregatesInput[]
    OR?: PostNotificationScalarWhereWithAggregatesInput[]
    NOT?: PostNotificationScalarWhereWithAggregatesInput | PostNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostNotification"> | string
    postId?: StringWithAggregatesFilter<"PostNotification"> | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"PostNotification"> | Date | string | null
    subscriberCount?: IntWithAggregatesFilter<"PostNotification"> | number
    subject?: StringNullableWithAggregatesFilter<"PostNotification"> | string | null
    emailContent?: StringNullableWithAggregatesFilter<"PostNotification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PostNotification"> | Date | string
  }

  export type EvaluationWhereInput = {
    AND?: EvaluationWhereInput | EvaluationWhereInput[]
    OR?: EvaluationWhereInput[]
    NOT?: EvaluationWhereInput | EvaluationWhereInput[]
    id?: StringFilter<"Evaluation"> | string
    applicationId?: StringFilter<"Evaluation"> | string
    evaluatorId?: StringFilter<"Evaluation"> | string
    experienceScore?: IntFilter<"Evaluation"> | number
    skillsScore?: IntFilter<"Evaluation"> | number
    educationScore?: IntFilter<"Evaluation"> | number
    culturalFitScore?: IntFilter<"Evaluation"> | number
    totalScore?: IntFilter<"Evaluation"> | number
    recommendation?: EnumEvaluationRecommendationFilter<"Evaluation"> | $Enums.EvaluationRecommendation
    comments?: StringFilter<"Evaluation"> | string
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
    application?: XOR<CollaboratorApplicationRelationFilter, CollaboratorApplicationWhereInput>
    evaluator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EvaluationOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    evaluatorId?: SortOrder
    experienceScore?: SortOrder
    skillsScore?: SortOrder
    educationScore?: SortOrder
    culturalFitScore?: SortOrder
    totalScore?: SortOrder
    recommendation?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    application?: CollaboratorApplicationOrderByWithRelationInput
    evaluator?: UserOrderByWithRelationInput
  }

  export type EvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EvaluationWhereInput | EvaluationWhereInput[]
    OR?: EvaluationWhereInput[]
    NOT?: EvaluationWhereInput | EvaluationWhereInput[]
    applicationId?: StringFilter<"Evaluation"> | string
    evaluatorId?: StringFilter<"Evaluation"> | string
    experienceScore?: IntFilter<"Evaluation"> | number
    skillsScore?: IntFilter<"Evaluation"> | number
    educationScore?: IntFilter<"Evaluation"> | number
    culturalFitScore?: IntFilter<"Evaluation"> | number
    totalScore?: IntFilter<"Evaluation"> | number
    recommendation?: EnumEvaluationRecommendationFilter<"Evaluation"> | $Enums.EvaluationRecommendation
    comments?: StringFilter<"Evaluation"> | string
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
    application?: XOR<CollaboratorApplicationRelationFilter, CollaboratorApplicationWhereInput>
    evaluator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type EvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    evaluatorId?: SortOrder
    experienceScore?: SortOrder
    skillsScore?: SortOrder
    educationScore?: SortOrder
    culturalFitScore?: SortOrder
    totalScore?: SortOrder
    recommendation?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    _count?: EvaluationCountOrderByAggregateInput
    _avg?: EvaluationAvgOrderByAggregateInput
    _max?: EvaluationMaxOrderByAggregateInput
    _min?: EvaluationMinOrderByAggregateInput
    _sum?: EvaluationSumOrderByAggregateInput
  }

  export type EvaluationScalarWhereWithAggregatesInput = {
    AND?: EvaluationScalarWhereWithAggregatesInput | EvaluationScalarWhereWithAggregatesInput[]
    OR?: EvaluationScalarWhereWithAggregatesInput[]
    NOT?: EvaluationScalarWhereWithAggregatesInput | EvaluationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Evaluation"> | string
    applicationId?: StringWithAggregatesFilter<"Evaluation"> | string
    evaluatorId?: StringWithAggregatesFilter<"Evaluation"> | string
    experienceScore?: IntWithAggregatesFilter<"Evaluation"> | number
    skillsScore?: IntWithAggregatesFilter<"Evaluation"> | number
    educationScore?: IntWithAggregatesFilter<"Evaluation"> | number
    culturalFitScore?: IntWithAggregatesFilter<"Evaluation"> | number
    totalScore?: IntWithAggregatesFilter<"Evaluation"> | number
    recommendation?: EnumEvaluationRecommendationWithAggregatesFilter<"Evaluation"> | $Enums.EvaluationRecommendation
    comments?: StringWithAggregatesFilter<"Evaluation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Evaluation"> | Date | string
  }

  export type NoteWhereInput = {
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    id?: StringFilter<"Note"> | string
    applicationId?: StringFilter<"Note"> | string
    authorId?: StringFilter<"Note"> | string
    content?: StringFilter<"Note"> | string
    isPrivate?: BoolFilter<"Note"> | boolean
    createdAt?: DateTimeFilter<"Note"> | Date | string
    application?: XOR<CollaboratorApplicationRelationFilter, CollaboratorApplicationWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NoteOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isPrivate?: SortOrder
    createdAt?: SortOrder
    application?: CollaboratorApplicationOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type NoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    applicationId?: StringFilter<"Note"> | string
    authorId?: StringFilter<"Note"> | string
    content?: StringFilter<"Note"> | string
    isPrivate?: BoolFilter<"Note"> | boolean
    createdAt?: DateTimeFilter<"Note"> | Date | string
    application?: XOR<CollaboratorApplicationRelationFilter, CollaboratorApplicationWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NoteOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isPrivate?: SortOrder
    createdAt?: SortOrder
    _count?: NoteCountOrderByAggregateInput
    _max?: NoteMaxOrderByAggregateInput
    _min?: NoteMinOrderByAggregateInput
  }

  export type NoteScalarWhereWithAggregatesInput = {
    AND?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    OR?: NoteScalarWhereWithAggregatesInput[]
    NOT?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Note"> | string
    applicationId?: StringWithAggregatesFilter<"Note"> | string
    authorId?: StringWithAggregatesFilter<"Note"> | string
    content?: StringWithAggregatesFilter<"Note"> | string
    isPrivate?: BoolWithAggregatesFilter<"Note"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
  }

  export type InterviewWhereInput = {
    AND?: InterviewWhereInput | InterviewWhereInput[]
    OR?: InterviewWhereInput[]
    NOT?: InterviewWhereInput | InterviewWhereInput[]
    id?: StringFilter<"Interview"> | string
    applicationId?: StringFilter<"Interview"> | string
    scheduledAt?: DateTimeFilter<"Interview"> | Date | string
    duration?: IntFilter<"Interview"> | number
    type?: EnumInterviewTypeFilter<"Interview"> | $Enums.InterviewType
    location?: StringNullableFilter<"Interview"> | string | null
    meetingUrl?: StringNullableFilter<"Interview"> | string | null
    interviewerId?: StringFilter<"Interview"> | string
    status?: EnumInterviewStatusFilter<"Interview"> | $Enums.InterviewStatus
    feedback?: StringNullableFilter<"Interview"> | string | null
    result?: EnumInterviewResultNullableFilter<"Interview"> | $Enums.InterviewResult | null
    createdAt?: DateTimeFilter<"Interview"> | Date | string
    updatedAt?: DateTimeFilter<"Interview"> | Date | string
    application?: XOR<CollaboratorApplicationRelationFilter, CollaboratorApplicationWhereInput>
    interviewer?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type InterviewOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    type?: SortOrder
    location?: SortOrderInput | SortOrder
    meetingUrl?: SortOrderInput | SortOrder
    interviewerId?: SortOrder
    status?: SortOrder
    feedback?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    application?: CollaboratorApplicationOrderByWithRelationInput
    interviewer?: UserOrderByWithRelationInput
  }

  export type InterviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InterviewWhereInput | InterviewWhereInput[]
    OR?: InterviewWhereInput[]
    NOT?: InterviewWhereInput | InterviewWhereInput[]
    applicationId?: StringFilter<"Interview"> | string
    scheduledAt?: DateTimeFilter<"Interview"> | Date | string
    duration?: IntFilter<"Interview"> | number
    type?: EnumInterviewTypeFilter<"Interview"> | $Enums.InterviewType
    location?: StringNullableFilter<"Interview"> | string | null
    meetingUrl?: StringNullableFilter<"Interview"> | string | null
    interviewerId?: StringFilter<"Interview"> | string
    status?: EnumInterviewStatusFilter<"Interview"> | $Enums.InterviewStatus
    feedback?: StringNullableFilter<"Interview"> | string | null
    result?: EnumInterviewResultNullableFilter<"Interview"> | $Enums.InterviewResult | null
    createdAt?: DateTimeFilter<"Interview"> | Date | string
    updatedAt?: DateTimeFilter<"Interview"> | Date | string
    application?: XOR<CollaboratorApplicationRelationFilter, CollaboratorApplicationWhereInput>
    interviewer?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type InterviewOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    type?: SortOrder
    location?: SortOrderInput | SortOrder
    meetingUrl?: SortOrderInput | SortOrder
    interviewerId?: SortOrder
    status?: SortOrder
    feedback?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InterviewCountOrderByAggregateInput
    _avg?: InterviewAvgOrderByAggregateInput
    _max?: InterviewMaxOrderByAggregateInput
    _min?: InterviewMinOrderByAggregateInput
    _sum?: InterviewSumOrderByAggregateInput
  }

  export type InterviewScalarWhereWithAggregatesInput = {
    AND?: InterviewScalarWhereWithAggregatesInput | InterviewScalarWhereWithAggregatesInput[]
    OR?: InterviewScalarWhereWithAggregatesInput[]
    NOT?: InterviewScalarWhereWithAggregatesInput | InterviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Interview"> | string
    applicationId?: StringWithAggregatesFilter<"Interview"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"Interview"> | Date | string
    duration?: IntWithAggregatesFilter<"Interview"> | number
    type?: EnumInterviewTypeWithAggregatesFilter<"Interview"> | $Enums.InterviewType
    location?: StringNullableWithAggregatesFilter<"Interview"> | string | null
    meetingUrl?: StringNullableWithAggregatesFilter<"Interview"> | string | null
    interviewerId?: StringWithAggregatesFilter<"Interview"> | string
    status?: EnumInterviewStatusWithAggregatesFilter<"Interview"> | $Enums.InterviewStatus
    feedback?: StringNullableWithAggregatesFilter<"Interview"> | string | null
    result?: EnumInterviewResultNullableWithAggregatesFilter<"Interview"> | $Enums.InterviewResult | null
    createdAt?: DateTimeWithAggregatesFilter<"Interview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Interview"> | Date | string
  }

  export type ApiIntegrationWhereInput = {
    AND?: ApiIntegrationWhereInput | ApiIntegrationWhereInput[]
    OR?: ApiIntegrationWhereInput[]
    NOT?: ApiIntegrationWhereInput | ApiIntegrationWhereInput[]
    id?: StringFilter<"ApiIntegration"> | string
    name?: StringFilter<"ApiIntegration"> | string
    displayName?: StringFilter<"ApiIntegration"> | string
    apiKey?: StringFilter<"ApiIntegration"> | string
    apiSecret?: StringNullableFilter<"ApiIntegration"> | string | null
    environment?: StringFilter<"ApiIntegration"> | string
    isActive?: BoolFilter<"ApiIntegration"> | boolean
    metadata?: JsonNullableFilter<"ApiIntegration">
    createdAt?: DateTimeFilter<"ApiIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"ApiIntegration"> | Date | string
  }

  export type ApiIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    apiKey?: SortOrder
    apiSecret?: SortOrderInput | SortOrder
    environment?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ApiIntegrationWhereInput | ApiIntegrationWhereInput[]
    OR?: ApiIntegrationWhereInput[]
    NOT?: ApiIntegrationWhereInput | ApiIntegrationWhereInput[]
    displayName?: StringFilter<"ApiIntegration"> | string
    apiKey?: StringFilter<"ApiIntegration"> | string
    apiSecret?: StringNullableFilter<"ApiIntegration"> | string | null
    environment?: StringFilter<"ApiIntegration"> | string
    isActive?: BoolFilter<"ApiIntegration"> | boolean
    metadata?: JsonNullableFilter<"ApiIntegration">
    createdAt?: DateTimeFilter<"ApiIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"ApiIntegration"> | Date | string
  }, "id" | "name">

  export type ApiIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    apiKey?: SortOrder
    apiSecret?: SortOrderInput | SortOrder
    environment?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApiIntegrationCountOrderByAggregateInput
    _max?: ApiIntegrationMaxOrderByAggregateInput
    _min?: ApiIntegrationMinOrderByAggregateInput
  }

  export type ApiIntegrationScalarWhereWithAggregatesInput = {
    AND?: ApiIntegrationScalarWhereWithAggregatesInput | ApiIntegrationScalarWhereWithAggregatesInput[]
    OR?: ApiIntegrationScalarWhereWithAggregatesInput[]
    NOT?: ApiIntegrationScalarWhereWithAggregatesInput | ApiIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiIntegration"> | string
    name?: StringWithAggregatesFilter<"ApiIntegration"> | string
    displayName?: StringWithAggregatesFilter<"ApiIntegration"> | string
    apiKey?: StringWithAggregatesFilter<"ApiIntegration"> | string
    apiSecret?: StringNullableWithAggregatesFilter<"ApiIntegration"> | string | null
    environment?: StringWithAggregatesFilter<"ApiIntegration"> | string
    isActive?: BoolWithAggregatesFilter<"ApiIntegration"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"ApiIntegration">
    createdAt?: DateTimeWithAggregatesFilter<"ApiIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiIntegration"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    interviews?: InterviewCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    library?: LibraryCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    library?: LibraryUncheckedCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperUncheckedCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageUncheckedCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    library?: LibraryUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    library?: LibraryUncheckedUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUncheckedUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUncheckedUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateInput = {
    id?: string
    totalAmount: number
    status?: $Enums.OrderStatus
    paymentMethod?: $Enums.PaymentMethod | null
    paymentStatus?: $Enums.PaymentStatus
    customerName: string
    customerEmail: string
    customerCpfCnpj: string
    customerPhone?: string | null
    pixCode?: string | null
    boletoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    customPaper?: CustomPaperCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    userId?: string | null
    totalAmount: number
    status?: $Enums.OrderStatus
    paymentMethod?: $Enums.PaymentMethod | null
    paymentStatus?: $Enums.PaymentStatus
    customerName: string
    customerEmail: string
    customerCpfCnpj: string
    customerPhone?: string | null
    pixCode?: string | null
    boletoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    customPaper?: CustomPaperUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerCpfCnpj?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    customPaper?: CustomPaperUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerCpfCnpj?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    customPaper?: CustomPaperUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    userId?: string | null
    totalAmount: number
    status?: $Enums.OrderStatus
    paymentMethod?: $Enums.PaymentMethod | null
    paymentStatus?: $Enums.PaymentStatus
    customerName: string
    customerEmail: string
    customerCpfCnpj: string
    customerPhone?: string | null
    pixCode?: string | null
    boletoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerCpfCnpj?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerCpfCnpj?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    order: OrderCreateNestedOneWithoutItemsInput
    paper?: PaperCreateNestedOneWithoutOrderItemsInput
    course?: CourseCreateNestedOneWithoutOrderItemsInput
    ebook?: EbookCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    title: string
    description?: string | null
    price: number
    paperId?: string | null
    courseId?: string | null
    ebookId?: string | null
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    paper?: PaperUpdateOneWithoutOrderItemsNestedInput
    course?: CourseUpdateOneWithoutOrderItemsNestedInput
    ebook?: EbookUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paperId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    ebookId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    title: string
    description?: string | null
    price: number
    paperId?: string | null
    courseId?: string | null
    ebookId?: string | null
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paperId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    ebookId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaperCreateInput = {
    id?: string
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    price: number
    pageCount: number
    authorName: string
    language?: string
    keywords?: string | null
    previewUrl?: string | null
    fileUrl: string
    thumbnailUrl?: string | null
    isFree?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutPaperInput
  }

  export type PaperUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    price: number
    pageCount: number
    authorName: string
    language?: string
    keywords?: string | null
    previewUrl?: string | null
    fileUrl: string
    thumbnailUrl?: string | null
    isFree?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutPaperInput
  }

  export type PaperUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    price?: IntFieldUpdateOperationsInput | number
    pageCount?: IntFieldUpdateOperationsInput | number
    authorName?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutPaperNestedInput
  }

  export type PaperUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    price?: IntFieldUpdateOperationsInput | number
    pageCount?: IntFieldUpdateOperationsInput | number
    authorName?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutPaperNestedInput
  }

  export type PaperCreateManyInput = {
    id?: string
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    price: number
    pageCount: number
    authorName: string
    language?: string
    keywords?: string | null
    previewUrl?: string | null
    fileUrl: string
    thumbnailUrl?: string | null
    isFree?: boolean
    createdAt?: Date | string
  }

  export type PaperUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    price?: IntFieldUpdateOperationsInput | number
    pageCount?: IntFieldUpdateOperationsInput | number
    authorName?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaperUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    price?: IntFieldUpdateOperationsInput | number
    pageCount?: IntFieldUpdateOperationsInput | number
    authorName?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    instructorName: string
    instructorBio?: string | null
    price: number
    duration: number
    level?: $Enums.CourseLevel
    thumbnailUrl?: string | null
    videoUrl?: string | null
    status?: $Enums.CourseStatus
    isFeatured?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    instructorName: string
    instructorBio?: string | null
    price: number
    duration: number
    level?: $Enums.CourseLevel
    thumbnailUrl?: string | null
    videoUrl?: string | null
    status?: $Enums.CourseStatus
    isFeatured?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    instructorName?: StringFieldUpdateOperationsInput | string
    instructorBio?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    instructorName?: StringFieldUpdateOperationsInput | string
    instructorBio?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    instructorName: string
    instructorBio?: string | null
    price: number
    duration: number
    level?: $Enums.CourseLevel
    thumbnailUrl?: string | null
    videoUrl?: string | null
    status?: $Enums.CourseStatus
    isFeatured?: boolean
    createdAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    instructorName?: StringFieldUpdateOperationsInput | string
    instructorBio?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    instructorName?: StringFieldUpdateOperationsInput | string
    instructorBio?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EbookCreateInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    authorName: string
    price: number
    pageCount: number
    fileUrl: string
    coverUrl?: string | null
    createdAt?: Date | string
    files?: EbookFileCreateNestedManyWithoutEbookInput
    orderItems?: OrderItemCreateNestedManyWithoutEbookInput
  }

  export type EbookUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    authorName: string
    price: number
    pageCount: number
    fileUrl: string
    coverUrl?: string | null
    createdAt?: Date | string
    files?: EbookFileUncheckedCreateNestedManyWithoutEbookInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutEbookInput
  }

  export type EbookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    authorName?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    pageCount?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: EbookFileUpdateManyWithoutEbookNestedInput
    orderItems?: OrderItemUpdateManyWithoutEbookNestedInput
  }

  export type EbookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    authorName?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    pageCount?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: EbookFileUncheckedUpdateManyWithoutEbookNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutEbookNestedInput
  }

  export type EbookCreateManyInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    authorName: string
    price: number
    pageCount: number
    fileUrl: string
    coverUrl?: string | null
    createdAt?: Date | string
  }

  export type EbookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    authorName?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    pageCount?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EbookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    authorName?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    pageCount?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EbookFileCreateInput = {
    id?: string
    fileUrl: string
    fileName: string
    fileSize?: number | null
    createdAt?: Date | string
    ebook: EbookCreateNestedOneWithoutFilesInput
  }

  export type EbookFileUncheckedCreateInput = {
    id?: string
    ebookId: string
    fileUrl: string
    fileName: string
    fileSize?: number | null
    createdAt?: Date | string
  }

  export type EbookFileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ebook?: EbookUpdateOneRequiredWithoutFilesNestedInput
  }

  export type EbookFileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ebookId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EbookFileCreateManyInput = {
    id?: string
    ebookId: string
    fileUrl: string
    fileName: string
    fileSize?: number | null
    createdAt?: Date | string
  }

  export type EbookFileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EbookFileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ebookId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateInput = {
    id?: string
    certificateNumber: string
    grade: number
    completionDate: Date | string
    qrCodeUrl: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCertificatesInput
    course: CourseCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateInput = {
    id?: string
    userId: string
    courseId: string
    certificateNumber: string
    grade: number
    completionDate: Date | string
    qrCodeUrl: string
    createdAt?: Date | string
  }

  export type CertificateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCertificatesNestedInput
    course?: CourseUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateManyInput = {
    id?: string
    userId: string
    courseId: string
    certificateNumber: string
    grade: number
    completionDate: Date | string
    qrCodeUrl: string
    createdAt?: Date | string
  }

  export type CertificateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCreateInput = {
    id?: string
    itemType: $Enums.LibraryItemType
    itemId: string
    downloadUrl: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLibraryInput
  }

  export type LibraryUncheckedCreateInput = {
    id?: string
    userId: string
    itemType: $Enums.LibraryItemType
    itemId: string
    downloadUrl: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LibraryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumLibraryItemTypeFieldUpdateOperationsInput | $Enums.LibraryItemType
    itemId?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLibraryNestedInput
  }

  export type LibraryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemType?: EnumLibraryItemTypeFieldUpdateOperationsInput | $Enums.LibraryItemType
    itemId?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCreateManyInput = {
    id?: string
    userId: string
    itemType: $Enums.LibraryItemType
    itemId: string
    downloadUrl: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LibraryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumLibraryItemTypeFieldUpdateOperationsInput | $Enums.LibraryItemType
    itemId?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemType?: EnumLibraryItemTypeFieldUpdateOperationsInput | $Enums.LibraryItemType
    itemId?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: BlogPostCreateNestedManyWithoutCategoryInput
    subscribers?: NewsletterSubscriptionCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: BlogPostUncheckedCreateNestedManyWithoutCategoryInput
    subscribers?: NewsletterSubscriptionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: BlogPostUpdateManyWithoutCategoryNestedInput
    subscribers?: NewsletterSubscriptionUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: BlogPostUncheckedUpdateManyWithoutCategoryNestedInput
    subscribers?: NewsletterSubscriptionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: BlogTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: BlogTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: BlogTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: BlogTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutBlogPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: BlogTagCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: LikeCreateNestedManyWithoutPostInput
    analytics?: PostAnalyticsCreateNestedManyWithoutPostInput
    notifications?: PostNotificationCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    authorId: string
    categoryId?: string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: BlogTagUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    analytics?: PostAnalyticsUncheckedCreateNestedManyWithoutPostInput
    notifications?: PostNotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: BlogTagUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    analytics?: PostAnalyticsUpdateManyWithoutPostNestedInput
    notifications?: PostNotificationUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: BlogTagUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    analytics?: PostAnalyticsUncheckedUpdateManyWithoutPostNestedInput
    notifications?: PostNotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostCreateManyInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    authorId: string
    categoryId?: string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTagCreateInput = {
    post: BlogPostCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutPostsInput
  }

  export type BlogTagUncheckedCreateInput = {
    postId: string
    tagId: string
  }

  export type BlogTagUpdateInput = {
    post?: BlogPostUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutPostsNestedInput
  }

  export type BlogTagUncheckedUpdateInput = {
    postId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogTagCreateManyInput = {
    postId: string
    tagId: string
  }

  export type BlogTagUpdateManyMutationInput = {

  }

  export type BlogTagUncheckedUpdateManyInput = {
    postId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post: BlogPostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    content: string
    postId: string
    userId: string
    parentId?: string | null
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    content: string
    postId: string
    userId: string
    parentId?: string | null
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateInput = {
    id?: string
    createdAt?: Date | string
    post: BlogPostCreateNestedOneWithoutLikesInput
    user: UserCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateInput = {
    id?: string
    postId: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutLikesNestedInput
    user?: UserUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateManyInput = {
    id?: string
    postId: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaboratorApplicationCreateInput = {
    id?: string
    fullName: string
    email: string
    phone: string
    cpf?: string | null
    birthDate?: Date | string | null
    zipCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    area: string
    education?: string | null
    experience: string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability: string
    expectedSalary?: number | null
    resumeUrl?: string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: string | null
    github?: string | null
    status?: $Enums.ApplicationStatus
    stage?: $Enums.ApplicationStage
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    user: UserCreateNestedOneWithoutCollaboratorApplicationsInput
    evaluations?: EvaluationCreateNestedManyWithoutApplicationInput
    notes?: NoteCreateNestedManyWithoutApplicationInput
    interviews?: InterviewCreateNestedManyWithoutApplicationInput
    reviewer?: UserCreateNestedOneWithoutReviewedApplicationsInput
  }

  export type CollaboratorApplicationUncheckedCreateInput = {
    id?: string
    userId: string
    fullName: string
    email: string
    phone: string
    cpf?: string | null
    birthDate?: Date | string | null
    zipCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    area: string
    education?: string | null
    experience: string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability: string
    expectedSalary?: number | null
    resumeUrl?: string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: string | null
    github?: string | null
    status?: $Enums.ApplicationStatus
    stage?: $Enums.ApplicationStage
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    reviewerId?: string | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutApplicationInput
    notes?: NoteUncheckedCreateNestedManyWithoutApplicationInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type CollaboratorApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: StringFieldUpdateOperationsInput | string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability?: StringFieldUpdateOperationsInput | string
    expectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFieldUpdateOperationsInput | $Enums.ApplicationStage
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCollaboratorApplicationsNestedInput
    evaluations?: EvaluationUpdateManyWithoutApplicationNestedInput
    notes?: NoteUpdateManyWithoutApplicationNestedInput
    interviews?: InterviewUpdateManyWithoutApplicationNestedInput
    reviewer?: UserUpdateOneWithoutReviewedApplicationsNestedInput
  }

  export type CollaboratorApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: StringFieldUpdateOperationsInput | string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability?: StringFieldUpdateOperationsInput | string
    expectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFieldUpdateOperationsInput | $Enums.ApplicationStage
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutApplicationNestedInput
    notes?: NoteUncheckedUpdateManyWithoutApplicationNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type CollaboratorApplicationCreateManyInput = {
    id?: string
    userId: string
    fullName: string
    email: string
    phone: string
    cpf?: string | null
    birthDate?: Date | string | null
    zipCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    area: string
    education?: string | null
    experience: string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability: string
    expectedSalary?: number | null
    resumeUrl?: string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: string | null
    github?: string | null
    status?: $Enums.ApplicationStatus
    stage?: $Enums.ApplicationStage
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    reviewerId?: string | null
  }

  export type CollaboratorApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: StringFieldUpdateOperationsInput | string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability?: StringFieldUpdateOperationsInput | string
    expectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFieldUpdateOperationsInput | $Enums.ApplicationStage
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CollaboratorApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: StringFieldUpdateOperationsInput | string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability?: StringFieldUpdateOperationsInput | string
    expectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFieldUpdateOperationsInput | $Enums.ApplicationStage
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    status?: $Enums.MessageStatus
    replied?: boolean
    repliedAt?: Date | string | null
    replyContent?: string | null
    assignedTo?: string | null
    priority?: $Enums.Priority
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    status?: $Enums.MessageStatus
    replied?: boolean
    repliedAt?: Date | string | null
    replyContent?: string | null
    assignedTo?: string | null
    priority?: $Enums.Priority
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    replied?: BoolFieldUpdateOperationsInput | boolean
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyContent?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    replied?: BoolFieldUpdateOperationsInput | boolean
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyContent?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    status?: $Enums.MessageStatus
    replied?: boolean
    repliedAt?: Date | string | null
    replyContent?: string | null
    assignedTo?: string | null
    priority?: $Enums.Priority
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    replied?: BoolFieldUpdateOperationsInput | boolean
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyContent?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    replied?: BoolFieldUpdateOperationsInput | boolean
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyContent?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LegalDocumentCreateInput = {
    id?: string
    type: $Enums.LegalType
    title: string
    content: string
    version: string
    active?: boolean
    publishedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LegalDocumentUncheckedCreateInput = {
    id?: string
    type: $Enums.LegalType
    title: string
    content: string
    version: string
    active?: boolean
    publishedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LegalDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    publishedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LegalDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    publishedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LegalDocumentCreateManyInput = {
    id?: string
    type: $Enums.LegalType
    title: string
    content: string
    version: string
    active?: boolean
    publishedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LegalDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    publishedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LegalDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    publishedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateCreateInput = {
    id?: string
    name: string
    subject: string
    content: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    category?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageTemplateUncheckedCreateInput = {
    id?: string
    name: string
    subject: string
    content: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    category?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateCreateManyInput = {
    id?: string
    name: string
    subject: string
    content: string
    variables?: MessageTemplateCreatevariablesInput | string[]
    category?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    variables?: MessageTemplateUpdatevariablesInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DownloadTrackingCreateInput = {
    id?: string
    userId: string
    itemId: string
    itemType: string
    downloadedAt?: Date | string
  }

  export type DownloadTrackingUncheckedCreateInput = {
    id?: string
    userId: string
    itemId: string
    itemType: string
    downloadedAt?: Date | string
  }

  export type DownloadTrackingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    downloadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DownloadTrackingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    downloadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DownloadTrackingCreateManyInput = {
    id?: string
    userId: string
    itemId: string
    itemType: string
    downloadedAt?: Date | string
  }

  export type DownloadTrackingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    downloadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DownloadTrackingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    downloadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPaperCreateInput = {
    id?: string
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    pageCount: number
    deadline: Date | string
    urgency: $Enums.CustomPaperUrgency
    requirements: string
    keywords?: string | null
    references?: string | null
    requirementFiles?: CustomPaperCreaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperCreatedeliveryFilesInput | string[]
    quotedPrice?: number | null
    finalPrice?: number | null
    paymentStatus?: $Enums.PaymentStatus
    status?: $Enums.CustomPaperStatus
    adminNotes?: string | null
    rejectionReason?: string | null
    requestedAt?: Date | string
    quotedAt?: Date | string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCustomPapersInput
    messages?: CustomPaperMessageCreateNestedManyWithoutCustomPaperInput
    order?: OrderCreateNestedOneWithoutCustomPaperInput
  }

  export type CustomPaperUncheckedCreateInput = {
    id?: string
    userId?: string | null
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    pageCount: number
    deadline: Date | string
    urgency: $Enums.CustomPaperUrgency
    requirements: string
    keywords?: string | null
    references?: string | null
    requirementFiles?: CustomPaperCreaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperCreatedeliveryFilesInput | string[]
    quotedPrice?: number | null
    finalPrice?: number | null
    paymentStatus?: $Enums.PaymentStatus
    status?: $Enums.CustomPaperStatus
    adminNotes?: string | null
    rejectionReason?: string | null
    requestedAt?: Date | string
    quotedAt?: Date | string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    orderId?: string | null
    messages?: CustomPaperMessageUncheckedCreateNestedManyWithoutCustomPaperInput
  }

  export type CustomPaperUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    pageCount?: IntFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    urgency?: EnumCustomPaperUrgencyFieldUpdateOperationsInput | $Enums.CustomPaperUrgency
    requirements?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    requirementFiles?: CustomPaperUpdaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperUpdatedeliveryFilesInput | string[]
    quotedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    status?: EnumCustomPaperStatusFieldUpdateOperationsInput | $Enums.CustomPaperStatus
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCustomPapersNestedInput
    messages?: CustomPaperMessageUpdateManyWithoutCustomPaperNestedInput
    order?: OrderUpdateOneWithoutCustomPaperNestedInput
  }

  export type CustomPaperUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    pageCount?: IntFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    urgency?: EnumCustomPaperUrgencyFieldUpdateOperationsInput | $Enums.CustomPaperUrgency
    requirements?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    requirementFiles?: CustomPaperUpdaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperUpdatedeliveryFilesInput | string[]
    quotedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    status?: EnumCustomPaperStatusFieldUpdateOperationsInput | $Enums.CustomPaperStatus
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: CustomPaperMessageUncheckedUpdateManyWithoutCustomPaperNestedInput
  }

  export type CustomPaperCreateManyInput = {
    id?: string
    userId?: string | null
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    pageCount: number
    deadline: Date | string
    urgency: $Enums.CustomPaperUrgency
    requirements: string
    keywords?: string | null
    references?: string | null
    requirementFiles?: CustomPaperCreaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperCreatedeliveryFilesInput | string[]
    quotedPrice?: number | null
    finalPrice?: number | null
    paymentStatus?: $Enums.PaymentStatus
    status?: $Enums.CustomPaperStatus
    adminNotes?: string | null
    rejectionReason?: string | null
    requestedAt?: Date | string
    quotedAt?: Date | string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    orderId?: string | null
  }

  export type CustomPaperUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    pageCount?: IntFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    urgency?: EnumCustomPaperUrgencyFieldUpdateOperationsInput | $Enums.CustomPaperUrgency
    requirements?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    requirementFiles?: CustomPaperUpdaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperUpdatedeliveryFilesInput | string[]
    quotedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    status?: EnumCustomPaperStatusFieldUpdateOperationsInput | $Enums.CustomPaperStatus
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomPaperUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    pageCount?: IntFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    urgency?: EnumCustomPaperUrgencyFieldUpdateOperationsInput | $Enums.CustomPaperUrgency
    requirements?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    requirementFiles?: CustomPaperUpdaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperUpdatedeliveryFilesInput | string[]
    quotedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    status?: EnumCustomPaperStatusFieldUpdateOperationsInput | $Enums.CustomPaperStatus
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomPaperMessageCreateInput = {
    id?: string
    content: string
    attachments?: CustomPaperMessageCreateattachmentsInput | string[]
    isFromAdmin: boolean
    isRead?: boolean
    createdAt?: Date | string
    customPaper: CustomPaperCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutCustomPaperMessagesInput
  }

  export type CustomPaperMessageUncheckedCreateInput = {
    id?: string
    customPaperId: string
    senderId: string
    content: string
    attachments?: CustomPaperMessageCreateattachmentsInput | string[]
    isFromAdmin: boolean
    isRead?: boolean
    createdAt?: Date | string
  }

  export type CustomPaperMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: CustomPaperMessageUpdateattachmentsInput | string[]
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customPaper?: CustomPaperUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutCustomPaperMessagesNestedInput
  }

  export type CustomPaperMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customPaperId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: CustomPaperMessageUpdateattachmentsInput | string[]
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPaperMessageCreateManyInput = {
    id?: string
    customPaperId: string
    senderId: string
    content: string
    attachments?: CustomPaperMessageCreateattachmentsInput | string[]
    isFromAdmin: boolean
    isRead?: boolean
    createdAt?: Date | string
  }

  export type CustomPaperMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: CustomPaperMessageUpdateattachmentsInput | string[]
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPaperMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customPaperId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: CustomPaperMessageUpdateattachmentsInput | string[]
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseModuleCreateInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutModulesInput
    lessons?: CourseLessonCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUncheckedCreateInput = {
    id?: string
    courseId: string
    title: string
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lessons?: CourseLessonUncheckedCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    lessons?: CourseLessonUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: CourseLessonUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleCreateManyInput = {
    id?: string
    courseId: string
    title: string
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLessonCreateInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    order: number
    isEnabled?: boolean
    attachments?: CourseLessonCreateattachmentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    module: CourseModuleCreateNestedOneWithoutLessonsInput
    progress?: CourseProgressCreateNestedManyWithoutLessonInput
  }

  export type CourseLessonUncheckedCreateInput = {
    id?: string
    moduleId: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    order: number
    isEnabled?: boolean
    attachments?: CourseLessonCreateattachmentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: CourseProgressUncheckedCreateNestedManyWithoutLessonInput
  }

  export type CourseLessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    attachments?: CourseLessonUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: CourseModuleUpdateOneRequiredWithoutLessonsNestedInput
    progress?: CourseProgressUpdateManyWithoutLessonNestedInput
  }

  export type CourseLessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    attachments?: CourseLessonUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: CourseProgressUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type CourseLessonCreateManyInput = {
    id?: string
    moduleId: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    order: number
    isEnabled?: boolean
    attachments?: CourseLessonCreateattachmentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseLessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    attachments?: CourseLessonUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    attachments?: CourseLessonUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseProgressCreateInput = {
    id?: string
    completed?: boolean
    watchTime?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCourseProgressInput
    lesson: CourseLessonCreateNestedOneWithoutProgressInput
  }

  export type CourseProgressUncheckedCreateInput = {
    id?: string
    userId: string
    lessonId: string
    completed?: boolean
    watchTime?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    watchTime?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCourseProgressNestedInput
    lesson?: CourseLessonUpdateOneRequiredWithoutProgressNestedInput
  }

  export type CourseProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    watchTime?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseProgressCreateManyInput = {
    id?: string
    userId: string
    lessonId: string
    completed?: boolean
    watchTime?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    watchTime?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    watchTime?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseEnrollmentCreateInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    user: UserCreateNestedOneWithoutCourseEnrollmentsInput
    course: CourseCreateNestedOneWithoutEnrollmentsInput
  }

  export type CourseEnrollmentUncheckedCreateInput = {
    id?: string
    userId: string
    courseId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
  }

  export type CourseEnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutCourseEnrollmentsNestedInput
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type CourseEnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type CourseEnrollmentCreateManyInput = {
    id?: string
    userId: string
    courseId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
  }

  export type CourseEnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type CourseEnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type PostAnalyticsCreateInput = {
    id?: string
    date: Date | string
    views?: number
    uniqueViews?: number
    shares?: number
    avgTimeOnPage?: number
    bounceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: BlogPostCreateNestedOneWithoutAnalyticsInput
  }

  export type PostAnalyticsUncheckedCreateInput = {
    id?: string
    postId: string
    date: Date | string
    views?: number
    uniqueViews?: number
    shares?: number
    avgTimeOnPage?: number
    bounceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    views?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    avgTimeOnPage?: IntFieldUpdateOperationsInput | number
    bounceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type PostAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    views?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    avgTimeOnPage?: IntFieldUpdateOperationsInput | number
    bounceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAnalyticsCreateManyInput = {
    id?: string
    postId: string
    date: Date | string
    views?: number
    uniqueViews?: number
    shares?: number
    avgTimeOnPage?: number
    bounceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    views?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    avgTimeOnPage?: IntFieldUpdateOperationsInput | number
    bounceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    views?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    avgTimeOnPage?: IntFieldUpdateOperationsInput | number
    bounceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsletterSubscriberCreateInput = {
    id?: string
    email: string
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: NewsletterSubscriptionCreateNestedManyWithoutSubscriberInput
  }

  export type NewsletterSubscriberUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: NewsletterSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput
  }

  export type NewsletterSubscriberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: NewsletterSubscriptionUpdateManyWithoutSubscriberNestedInput
  }

  export type NewsletterSubscriberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: NewsletterSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput
  }

  export type NewsletterSubscriberCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsletterSubscriberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsletterSubscriberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsletterSubscriptionCreateInput = {
    createdAt?: Date | string
    subscriber: NewsletterSubscriberCreateNestedOneWithoutSubscriptionsInput
    category: CategoryCreateNestedOneWithoutSubscribersInput
  }

  export type NewsletterSubscriptionUncheckedCreateInput = {
    subscriberId: string
    categoryId: string
    createdAt?: Date | string
  }

  export type NewsletterSubscriptionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriber?: NewsletterSubscriberUpdateOneRequiredWithoutSubscriptionsNestedInput
    category?: CategoryUpdateOneRequiredWithoutSubscribersNestedInput
  }

  export type NewsletterSubscriptionUncheckedUpdateInput = {
    subscriberId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsletterSubscriptionCreateManyInput = {
    subscriberId: string
    categoryId: string
    createdAt?: Date | string
  }

  export type NewsletterSubscriptionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsletterSubscriptionUncheckedUpdateManyInput = {
    subscriberId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostNotificationCreateInput = {
    id?: string
    sentAt?: Date | string | null
    subscriberCount?: number
    subject?: string | null
    emailContent?: string | null
    createdAt?: Date | string
    post: BlogPostCreateNestedOneWithoutNotificationsInput
  }

  export type PostNotificationUncheckedCreateInput = {
    id?: string
    postId: string
    sentAt?: Date | string | null
    subscriberCount?: number
    subject?: string | null
    emailContent?: string | null
    createdAt?: Date | string
  }

  export type PostNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriberCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    emailContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type PostNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriberCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    emailContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostNotificationCreateManyInput = {
    id?: string
    postId: string
    sentAt?: Date | string | null
    subscriberCount?: number
    subject?: string | null
    emailContent?: string | null
    createdAt?: Date | string
  }

  export type PostNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriberCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    emailContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriberCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    emailContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationCreateInput = {
    id?: string
    experienceScore: number
    skillsScore: number
    educationScore: number
    culturalFitScore: number
    totalScore: number
    recommendation: $Enums.EvaluationRecommendation
    comments: string
    createdAt?: Date | string
    application: CollaboratorApplicationCreateNestedOneWithoutEvaluationsInput
    evaluator: UserCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateInput = {
    id?: string
    applicationId: string
    evaluatorId: string
    experienceScore: number
    skillsScore: number
    educationScore: number
    culturalFitScore: number
    totalScore: number
    recommendation: $Enums.EvaluationRecommendation
    comments: string
    createdAt?: Date | string
  }

  export type EvaluationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceScore?: IntFieldUpdateOperationsInput | number
    skillsScore?: IntFieldUpdateOperationsInput | number
    educationScore?: IntFieldUpdateOperationsInput | number
    culturalFitScore?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    recommendation?: EnumEvaluationRecommendationFieldUpdateOperationsInput | $Enums.EvaluationRecommendation
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: CollaboratorApplicationUpdateOneRequiredWithoutEvaluationsNestedInput
    evaluator?: UserUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    experienceScore?: IntFieldUpdateOperationsInput | number
    skillsScore?: IntFieldUpdateOperationsInput | number
    educationScore?: IntFieldUpdateOperationsInput | number
    culturalFitScore?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    recommendation?: EnumEvaluationRecommendationFieldUpdateOperationsInput | $Enums.EvaluationRecommendation
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationCreateManyInput = {
    id?: string
    applicationId: string
    evaluatorId: string
    experienceScore: number
    skillsScore: number
    educationScore: number
    culturalFitScore: number
    totalScore: number
    recommendation: $Enums.EvaluationRecommendation
    comments: string
    createdAt?: Date | string
  }

  export type EvaluationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceScore?: IntFieldUpdateOperationsInput | number
    skillsScore?: IntFieldUpdateOperationsInput | number
    educationScore?: IntFieldUpdateOperationsInput | number
    culturalFitScore?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    recommendation?: EnumEvaluationRecommendationFieldUpdateOperationsInput | $Enums.EvaluationRecommendation
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    experienceScore?: IntFieldUpdateOperationsInput | number
    skillsScore?: IntFieldUpdateOperationsInput | number
    educationScore?: IntFieldUpdateOperationsInput | number
    culturalFitScore?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    recommendation?: EnumEvaluationRecommendationFieldUpdateOperationsInput | $Enums.EvaluationRecommendation
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteCreateInput = {
    id?: string
    content: string
    isPrivate?: boolean
    createdAt?: Date | string
    application: CollaboratorApplicationCreateNestedOneWithoutNotesInput
    author: UserCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateInput = {
    id?: string
    applicationId: string
    authorId: string
    content: string
    isPrivate?: boolean
    createdAt?: Date | string
  }

  export type NoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: CollaboratorApplicationUpdateOneRequiredWithoutNotesNestedInput
    author?: UserUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteCreateManyInput = {
    id?: string
    applicationId: string
    authorId: string
    content: string
    isPrivate?: boolean
    createdAt?: Date | string
  }

  export type NoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewCreateInput = {
    id?: string
    scheduledAt: Date | string
    duration: number
    type: $Enums.InterviewType
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.InterviewStatus
    feedback?: string | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
    application: CollaboratorApplicationCreateNestedOneWithoutInterviewsInput
    interviewer: UserCreateNestedOneWithoutInterviewsInput
  }

  export type InterviewUncheckedCreateInput = {
    id?: string
    applicationId: string
    scheduledAt: Date | string
    duration: number
    type: $Enums.InterviewType
    location?: string | null
    meetingUrl?: string | null
    interviewerId: string
    status?: $Enums.InterviewStatus
    feedback?: string | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: EnumInterviewTypeFieldUpdateOperationsInput | $Enums.InterviewType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: CollaboratorApplicationUpdateOneRequiredWithoutInterviewsNestedInput
    interviewer?: UserUpdateOneRequiredWithoutInterviewsNestedInput
  }

  export type InterviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: EnumInterviewTypeFieldUpdateOperationsInput | $Enums.InterviewType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    interviewerId?: StringFieldUpdateOperationsInput | string
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewCreateManyInput = {
    id?: string
    applicationId: string
    scheduledAt: Date | string
    duration: number
    type: $Enums.InterviewType
    location?: string | null
    meetingUrl?: string | null
    interviewerId: string
    status?: $Enums.InterviewStatus
    feedback?: string | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: EnumInterviewTypeFieldUpdateOperationsInput | $Enums.InterviewType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: EnumInterviewTypeFieldUpdateOperationsInput | $Enums.InterviewType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    interviewerId?: StringFieldUpdateOperationsInput | string
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiIntegrationCreateInput = {
    id?: string
    name: string
    displayName: string
    apiKey: string
    apiSecret?: string | null
    environment?: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiIntegrationUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    apiKey: string
    apiSecret?: string | null
    environment?: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    apiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    apiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiIntegrationCreateManyInput = {
    id?: string
    name: string
    displayName: string
    apiKey: string
    apiSecret?: string | null
    environment?: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    apiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    apiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type CollaboratorApplicationListRelationFilter = {
    every?: CollaboratorApplicationWhereInput
    some?: CollaboratorApplicationWhereInput
    none?: CollaboratorApplicationWhereInput
  }

  export type EvaluationListRelationFilter = {
    every?: EvaluationWhereInput
    some?: EvaluationWhereInput
    none?: EvaluationWhereInput
  }

  export type NoteListRelationFilter = {
    every?: NoteWhereInput
    some?: NoteWhereInput
    none?: NoteWhereInput
  }

  export type InterviewListRelationFilter = {
    every?: InterviewWhereInput
    some?: InterviewWhereInput
    none?: InterviewWhereInput
  }

  export type CertificateListRelationFilter = {
    every?: CertificateWhereInput
    some?: CertificateWhereInput
    none?: CertificateWhereInput
  }

  export type LibraryListRelationFilter = {
    every?: LibraryWhereInput
    some?: LibraryWhereInput
    none?: LibraryWhereInput
  }

  export type CustomPaperListRelationFilter = {
    every?: CustomPaperWhereInput
    some?: CustomPaperWhereInput
    none?: CustomPaperWhereInput
  }

  export type CustomPaperMessageListRelationFilter = {
    every?: CustomPaperMessageWhereInput
    some?: CustomPaperMessageWhereInput
    none?: CustomPaperMessageWhereInput
  }

  export type CourseProgressListRelationFilter = {
    every?: CourseProgressWhereInput
    some?: CourseProgressWhereInput
    none?: CourseProgressWhereInput
  }

  export type CourseEnrollmentListRelationFilter = {
    every?: CourseEnrollmentWhereInput
    some?: CourseEnrollmentWhereInput
    none?: CourseEnrollmentWhereInput
  }

  export type BlogPostListRelationFilter = {
    every?: BlogPostWhereInput
    some?: BlogPostWhereInput
    none?: BlogPostWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type LikeListRelationFilter = {
    every?: LikeWhereInput
    some?: LikeWhereInput
    none?: LikeWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollaboratorApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomPaperOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomPaperMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseEnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    verified?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    profession?: SortOrder
    profileImageUrl?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    verified?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    profession?: SortOrder
    profileImageUrl?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    verified?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    profession?: SortOrder
    profileImageUrl?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type CustomPaperNullableRelationFilter = {
    is?: CustomPaperWhereInput | null
    isNot?: CustomPaperWhereInput | null
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerCpfCnpj?: SortOrder
    customerPhone?: SortOrder
    pixCode?: SortOrder
    boletoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerCpfCnpj?: SortOrder
    customerPhone?: SortOrder
    pixCode?: SortOrder
    boletoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerCpfCnpj?: SortOrder
    customerPhone?: SortOrder
    pixCode?: SortOrder
    boletoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type PaperNullableRelationFilter = {
    is?: PaperWhereInput | null
    isNot?: PaperWhereInput | null
  }

  export type CourseNullableRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type EbookNullableRelationFilter = {
    is?: EbookWhereInput | null
    isNot?: EbookWhereInput | null
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    paperId?: SortOrder
    courseId?: SortOrder
    ebookId?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    paperId?: SortOrder
    courseId?: SortOrder
    ebookId?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    paperId?: SortOrder
    courseId?: SortOrder
    ebookId?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumPaperTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaperType | EnumPaperTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaperType[] | ListEnumPaperTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaperType[] | ListEnumPaperTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaperTypeFilter<$PrismaModel> | $Enums.PaperType
  }

  export type EnumAcademicAreaFilter<$PrismaModel = never> = {
    equals?: $Enums.AcademicArea | EnumAcademicAreaFieldRefInput<$PrismaModel>
    in?: $Enums.AcademicArea[] | ListEnumAcademicAreaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AcademicArea[] | ListEnumAcademicAreaFieldRefInput<$PrismaModel>
    not?: NestedEnumAcademicAreaFilter<$PrismaModel> | $Enums.AcademicArea
  }

  export type PaperCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    paperType?: SortOrder
    academicArea?: SortOrder
    price?: SortOrder
    pageCount?: SortOrder
    authorName?: SortOrder
    language?: SortOrder
    keywords?: SortOrder
    previewUrl?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    isFree?: SortOrder
    createdAt?: SortOrder
  }

  export type PaperAvgOrderByAggregateInput = {
    price?: SortOrder
    pageCount?: SortOrder
  }

  export type PaperMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    paperType?: SortOrder
    academicArea?: SortOrder
    price?: SortOrder
    pageCount?: SortOrder
    authorName?: SortOrder
    language?: SortOrder
    keywords?: SortOrder
    previewUrl?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    isFree?: SortOrder
    createdAt?: SortOrder
  }

  export type PaperMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    paperType?: SortOrder
    academicArea?: SortOrder
    price?: SortOrder
    pageCount?: SortOrder
    authorName?: SortOrder
    language?: SortOrder
    keywords?: SortOrder
    previewUrl?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    isFree?: SortOrder
    createdAt?: SortOrder
  }

  export type PaperSumOrderByAggregateInput = {
    price?: SortOrder
    pageCount?: SortOrder
  }

  export type EnumPaperTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaperType | EnumPaperTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaperType[] | ListEnumPaperTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaperType[] | ListEnumPaperTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaperTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaperType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaperTypeFilter<$PrismaModel>
    _max?: NestedEnumPaperTypeFilter<$PrismaModel>
  }

  export type EnumAcademicAreaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AcademicArea | EnumAcademicAreaFieldRefInput<$PrismaModel>
    in?: $Enums.AcademicArea[] | ListEnumAcademicAreaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AcademicArea[] | ListEnumAcademicAreaFieldRefInput<$PrismaModel>
    not?: NestedEnumAcademicAreaWithAggregatesFilter<$PrismaModel> | $Enums.AcademicArea
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAcademicAreaFilter<$PrismaModel>
    _max?: NestedEnumAcademicAreaFilter<$PrismaModel>
  }

  export type EnumCourseLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevel | EnumCourseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelFilter<$PrismaModel> | $Enums.CourseLevel
  }

  export type EnumCourseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusFilter<$PrismaModel> | $Enums.CourseStatus
  }

  export type CourseModuleListRelationFilter = {
    every?: CourseModuleWhereInput
    some?: CourseModuleWhereInput
    none?: CourseModuleWhereInput
  }

  export type CourseModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academicArea?: SortOrder
    instructorName?: SortOrder
    instructorBio?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    thumbnailUrl?: SortOrder
    videoUrl?: SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academicArea?: SortOrder
    instructorName?: SortOrder
    instructorBio?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    thumbnailUrl?: SortOrder
    videoUrl?: SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academicArea?: SortOrder
    instructorName?: SortOrder
    instructorBio?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    thumbnailUrl?: SortOrder
    videoUrl?: SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type EnumCourseLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevel | EnumCourseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelWithAggregatesFilter<$PrismaModel> | $Enums.CourseLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseLevelFilter<$PrismaModel>
    _max?: NestedEnumCourseLevelFilter<$PrismaModel>
  }

  export type EnumCourseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CourseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseStatusFilter<$PrismaModel>
    _max?: NestedEnumCourseStatusFilter<$PrismaModel>
  }

  export type EbookFileListRelationFilter = {
    every?: EbookFileWhereInput
    some?: EbookFileWhereInput
    none?: EbookFileWhereInput
  }

  export type EbookFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EbookCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academicArea?: SortOrder
    authorName?: SortOrder
    price?: SortOrder
    pageCount?: SortOrder
    fileUrl?: SortOrder
    coverUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type EbookAvgOrderByAggregateInput = {
    price?: SortOrder
    pageCount?: SortOrder
  }

  export type EbookMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academicArea?: SortOrder
    authorName?: SortOrder
    price?: SortOrder
    pageCount?: SortOrder
    fileUrl?: SortOrder
    coverUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type EbookMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academicArea?: SortOrder
    authorName?: SortOrder
    price?: SortOrder
    pageCount?: SortOrder
    fileUrl?: SortOrder
    coverUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type EbookSumOrderByAggregateInput = {
    price?: SortOrder
    pageCount?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EbookRelationFilter = {
    is?: EbookWhereInput
    isNot?: EbookWhereInput
  }

  export type EbookFileCountOrderByAggregateInput = {
    id?: SortOrder
    ebookId?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
  }

  export type EbookFileAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EbookFileMaxOrderByAggregateInput = {
    id?: SortOrder
    ebookId?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
  }

  export type EbookFileMinOrderByAggregateInput = {
    id?: SortOrder
    ebookId?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
  }

  export type EbookFileSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CourseRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type CertificateCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    certificateNumber?: SortOrder
    grade?: SortOrder
    completionDate?: SortOrder
    qrCodeUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CertificateAvgOrderByAggregateInput = {
    grade?: SortOrder
  }

  export type CertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    certificateNumber?: SortOrder
    grade?: SortOrder
    completionDate?: SortOrder
    qrCodeUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CertificateMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    certificateNumber?: SortOrder
    grade?: SortOrder
    completionDate?: SortOrder
    qrCodeUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CertificateSumOrderByAggregateInput = {
    grade?: SortOrder
  }

  export type EnumLibraryItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LibraryItemType | EnumLibraryItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LibraryItemType[] | ListEnumLibraryItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LibraryItemType[] | ListEnumLibraryItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLibraryItemTypeFilter<$PrismaModel> | $Enums.LibraryItemType
  }

  export type LibraryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    downloadUrl?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LibraryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    downloadUrl?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LibraryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    downloadUrl?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLibraryItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LibraryItemType | EnumLibraryItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LibraryItemType[] | ListEnumLibraryItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LibraryItemType[] | ListEnumLibraryItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLibraryItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.LibraryItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLibraryItemTypeFilter<$PrismaModel>
    _max?: NestedEnumLibraryItemTypeFilter<$PrismaModel>
  }

  export type NewsletterSubscriptionListRelationFilter = {
    every?: NewsletterSubscriptionWhereInput
    some?: NewsletterSubscriptionWhereInput
    none?: NewsletterSubscriptionWhereInput
  }

  export type NewsletterSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogTagListRelationFilter = {
    every?: BlogTagWhereInput
    some?: BlogTagWhereInput
    none?: BlogTagWhereInput
  }

  export type BlogTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CategoryNullableRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type PostAnalyticsListRelationFilter = {
    every?: PostAnalyticsWhereInput
    some?: PostAnalyticsWhereInput
    none?: PostAnalyticsWhereInput
  }

  export type PostNotificationListRelationFilter = {
    every?: PostNotificationWhereInput
    some?: PostNotificationWhereInput
    none?: PostNotificationWhereInput
  }

  export type PostAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    coverImageUrl?: SortOrder
    published?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrder
    views?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    ogImage?: SortOrder
    canonicalUrl?: SortOrder
    readingTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostAvgOrderByAggregateInput = {
    views?: SortOrder
    readingTime?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    coverImageUrl?: SortOrder
    published?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrder
    views?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    ogImage?: SortOrder
    canonicalUrl?: SortOrder
    readingTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    coverImageUrl?: SortOrder
    published?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrder
    views?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    ogImage?: SortOrder
    canonicalUrl?: SortOrder
    readingTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostSumOrderByAggregateInput = {
    views?: SortOrder
    readingTime?: SortOrder
  }

  export type EnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type BlogPostRelationFilter = {
    is?: BlogPostWhereInput
    isNot?: BlogPostWhereInput
  }

  export type TagRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type BlogTagPostIdTagIdCompoundUniqueInput = {
    postId: string
    tagId: string
  }

  export type BlogTagCountOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type BlogTagMaxOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type BlogTagMinOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type CommentNullableRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    approved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    approved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    approved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LikePostIdUserIdCompoundUniqueInput = {
    postId: string
    userId: string
  }

  export type LikeCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type EnumApplicationStageFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStage | EnumApplicationStageFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStage[] | ListEnumApplicationStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStage[] | ListEnumApplicationStageFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStageFilter<$PrismaModel> | $Enums.ApplicationStage
  }

  export type CollaboratorApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    cpf?: SortOrder
    birthDate?: SortOrder
    zipCode?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    area?: SortOrder
    education?: SortOrder
    experience?: SortOrder
    skills?: SortOrder
    availability?: SortOrder
    expectedSalary?: SortOrder
    resumeUrl?: SortOrder
    portfolioUrls?: SortOrder
    linkedin?: SortOrder
    github?: SortOrder
    status?: SortOrder
    stage?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    reviewerId?: SortOrder
  }

  export type CollaboratorApplicationAvgOrderByAggregateInput = {
    expectedSalary?: SortOrder
    score?: SortOrder
  }

  export type CollaboratorApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    cpf?: SortOrder
    birthDate?: SortOrder
    zipCode?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    area?: SortOrder
    education?: SortOrder
    experience?: SortOrder
    availability?: SortOrder
    expectedSalary?: SortOrder
    resumeUrl?: SortOrder
    linkedin?: SortOrder
    github?: SortOrder
    status?: SortOrder
    stage?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    reviewerId?: SortOrder
  }

  export type CollaboratorApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    cpf?: SortOrder
    birthDate?: SortOrder
    zipCode?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    area?: SortOrder
    education?: SortOrder
    experience?: SortOrder
    availability?: SortOrder
    expectedSalary?: SortOrder
    resumeUrl?: SortOrder
    linkedin?: SortOrder
    github?: SortOrder
    status?: SortOrder
    stage?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    reviewerId?: SortOrder
  }

  export type CollaboratorApplicationSumOrderByAggregateInput = {
    expectedSalary?: SortOrder
    score?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type EnumApplicationStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStage | EnumApplicationStageFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStage[] | ListEnumApplicationStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStage[] | ListEnumApplicationStageFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStageWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStageFilter<$PrismaModel>
    _max?: NestedEnumApplicationStageFilter<$PrismaModel>
  }

  export type EnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    replied?: SortOrder
    repliedAt?: SortOrder
    replyContent?: SortOrder
    assignedTo?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    replied?: SortOrder
    repliedAt?: SortOrder
    replyContent?: SortOrder
    assignedTo?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    replied?: SortOrder
    repliedAt?: SortOrder
    replyContent?: SortOrder
    assignedTo?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumLegalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LegalType | EnumLegalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LegalType[] | ListEnumLegalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LegalType[] | ListEnumLegalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLegalTypeFilter<$PrismaModel> | $Enums.LegalType
  }

  export type LegalDocumentTypeActiveCompoundUniqueInput = {
    type: $Enums.LegalType
    active: boolean
  }

  export type LegalDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    version?: SortOrder
    active?: SortOrder
    publishedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LegalDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    version?: SortOrder
    active?: SortOrder
    publishedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LegalDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    version?: SortOrder
    active?: SortOrder
    publishedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLegalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LegalType | EnumLegalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LegalType[] | ListEnumLegalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LegalType[] | ListEnumLegalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLegalTypeWithAggregatesFilter<$PrismaModel> | $Enums.LegalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLegalTypeFilter<$PrismaModel>
    _max?: NestedEnumLegalTypeFilter<$PrismaModel>
  }

  export type MessageTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    category?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    category?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    category?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DownloadTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
    downloadedAt?: SortOrder
  }

  export type DownloadTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
    downloadedAt?: SortOrder
  }

  export type DownloadTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
    downloadedAt?: SortOrder
  }

  export type EnumCustomPaperUrgencyFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomPaperUrgency | EnumCustomPaperUrgencyFieldRefInput<$PrismaModel>
    in?: $Enums.CustomPaperUrgency[] | ListEnumCustomPaperUrgencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomPaperUrgency[] | ListEnumCustomPaperUrgencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomPaperUrgencyFilter<$PrismaModel> | $Enums.CustomPaperUrgency
  }

  export type EnumCustomPaperStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomPaperStatus | EnumCustomPaperStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CustomPaperStatus[] | ListEnumCustomPaperStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomPaperStatus[] | ListEnumCustomPaperStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomPaperStatusFilter<$PrismaModel> | $Enums.CustomPaperStatus
  }

  export type OrderNullableRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type CustomPaperCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    paperType?: SortOrder
    academicArea?: SortOrder
    pageCount?: SortOrder
    deadline?: SortOrder
    urgency?: SortOrder
    requirements?: SortOrder
    keywords?: SortOrder
    references?: SortOrder
    requirementFiles?: SortOrder
    deliveryFiles?: SortOrder
    quotedPrice?: SortOrder
    finalPrice?: SortOrder
    paymentStatus?: SortOrder
    status?: SortOrder
    adminNotes?: SortOrder
    rejectionReason?: SortOrder
    requestedAt?: SortOrder
    quotedAt?: SortOrder
    approvedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    orderId?: SortOrder
  }

  export type CustomPaperAvgOrderByAggregateInput = {
    pageCount?: SortOrder
    quotedPrice?: SortOrder
    finalPrice?: SortOrder
  }

  export type CustomPaperMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    paperType?: SortOrder
    academicArea?: SortOrder
    pageCount?: SortOrder
    deadline?: SortOrder
    urgency?: SortOrder
    requirements?: SortOrder
    keywords?: SortOrder
    references?: SortOrder
    quotedPrice?: SortOrder
    finalPrice?: SortOrder
    paymentStatus?: SortOrder
    status?: SortOrder
    adminNotes?: SortOrder
    rejectionReason?: SortOrder
    requestedAt?: SortOrder
    quotedAt?: SortOrder
    approvedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    orderId?: SortOrder
  }

  export type CustomPaperMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    paperType?: SortOrder
    academicArea?: SortOrder
    pageCount?: SortOrder
    deadline?: SortOrder
    urgency?: SortOrder
    requirements?: SortOrder
    keywords?: SortOrder
    references?: SortOrder
    quotedPrice?: SortOrder
    finalPrice?: SortOrder
    paymentStatus?: SortOrder
    status?: SortOrder
    adminNotes?: SortOrder
    rejectionReason?: SortOrder
    requestedAt?: SortOrder
    quotedAt?: SortOrder
    approvedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    orderId?: SortOrder
  }

  export type CustomPaperSumOrderByAggregateInput = {
    pageCount?: SortOrder
    quotedPrice?: SortOrder
    finalPrice?: SortOrder
  }

  export type EnumCustomPaperUrgencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomPaperUrgency | EnumCustomPaperUrgencyFieldRefInput<$PrismaModel>
    in?: $Enums.CustomPaperUrgency[] | ListEnumCustomPaperUrgencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomPaperUrgency[] | ListEnumCustomPaperUrgencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomPaperUrgencyWithAggregatesFilter<$PrismaModel> | $Enums.CustomPaperUrgency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomPaperUrgencyFilter<$PrismaModel>
    _max?: NestedEnumCustomPaperUrgencyFilter<$PrismaModel>
  }

  export type EnumCustomPaperStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomPaperStatus | EnumCustomPaperStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CustomPaperStatus[] | ListEnumCustomPaperStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomPaperStatus[] | ListEnumCustomPaperStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomPaperStatusWithAggregatesFilter<$PrismaModel> | $Enums.CustomPaperStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomPaperStatusFilter<$PrismaModel>
    _max?: NestedEnumCustomPaperStatusFilter<$PrismaModel>
  }

  export type CustomPaperRelationFilter = {
    is?: CustomPaperWhereInput
    isNot?: CustomPaperWhereInput
  }

  export type CustomPaperMessageCountOrderByAggregateInput = {
    id?: SortOrder
    customPaperId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    isFromAdmin?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomPaperMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    customPaperId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    isFromAdmin?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomPaperMessageMinOrderByAggregateInput = {
    id?: SortOrder
    customPaperId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    isFromAdmin?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseLessonListRelationFilter = {
    every?: CourseLessonWhereInput
    some?: CourseLessonWhereInput
    none?: CourseLessonWhereInput
  }

  export type CourseLessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseModuleCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseModuleAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CourseModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseModuleMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseModuleSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CourseModuleRelationFilter = {
    is?: CourseModuleWhereInput
    isNot?: CourseModuleWhereInput
  }

  export type CourseLessonCountOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    content?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    isEnabled?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseLessonAvgOrderByAggregateInput = {
    duration?: SortOrder
    order?: SortOrder
  }

  export type CourseLessonMaxOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    content?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseLessonMinOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    content?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseLessonSumOrderByAggregateInput = {
    duration?: SortOrder
    order?: SortOrder
  }

  export type CourseLessonRelationFilter = {
    is?: CourseLessonWhereInput
    isNot?: CourseLessonWhereInput
  }

  export type CourseProgressUserIdLessonIdCompoundUniqueInput = {
    userId: string
    lessonId: string
  }

  export type CourseProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    completed?: SortOrder
    watchTime?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseProgressAvgOrderByAggregateInput = {
    watchTime?: SortOrder
  }

  export type CourseProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    completed?: SortOrder
    watchTime?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    completed?: SortOrder
    watchTime?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseProgressSumOrderByAggregateInput = {
    watchTime?: SortOrder
  }

  export type CourseEnrollmentUserIdCourseIdCompoundUniqueInput = {
    userId: string
    courseId: string
  }

  export type CourseEnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    progress?: SortOrder
  }

  export type CourseEnrollmentAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type CourseEnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    progress?: SortOrder
  }

  export type CourseEnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    progress?: SortOrder
  }

  export type CourseEnrollmentSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PostAnalyticsPostIdDateCompoundUniqueInput = {
    postId: string
    date: Date | string
  }

  export type PostAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    date?: SortOrder
    views?: SortOrder
    uniqueViews?: SortOrder
    shares?: SortOrder
    avgTimeOnPage?: SortOrder
    bounceRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostAnalyticsAvgOrderByAggregateInput = {
    views?: SortOrder
    uniqueViews?: SortOrder
    shares?: SortOrder
    avgTimeOnPage?: SortOrder
    bounceRate?: SortOrder
  }

  export type PostAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    date?: SortOrder
    views?: SortOrder
    uniqueViews?: SortOrder
    shares?: SortOrder
    avgTimeOnPage?: SortOrder
    bounceRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    date?: SortOrder
    views?: SortOrder
    uniqueViews?: SortOrder
    shares?: SortOrder
    avgTimeOnPage?: SortOrder
    bounceRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostAnalyticsSumOrderByAggregateInput = {
    views?: SortOrder
    uniqueViews?: SortOrder
    shares?: SortOrder
    avgTimeOnPage?: SortOrder
    bounceRate?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NewsletterSubscriberCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsletterSubscriberMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsletterSubscriberMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsletterSubscriberRelationFilter = {
    is?: NewsletterSubscriberWhereInput
    isNot?: NewsletterSubscriberWhereInput
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type NewsletterSubscriptionSubscriberIdCategoryIdCompoundUniqueInput = {
    subscriberId: string
    categoryId: string
  }

  export type NewsletterSubscriptionCountOrderByAggregateInput = {
    subscriberId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsletterSubscriptionMaxOrderByAggregateInput = {
    subscriberId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsletterSubscriptionMinOrderByAggregateInput = {
    subscriberId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
  }

  export type PostNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    sentAt?: SortOrder
    subscriberCount?: SortOrder
    subject?: SortOrder
    emailContent?: SortOrder
    createdAt?: SortOrder
  }

  export type PostNotificationAvgOrderByAggregateInput = {
    subscriberCount?: SortOrder
  }

  export type PostNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    sentAt?: SortOrder
    subscriberCount?: SortOrder
    subject?: SortOrder
    emailContent?: SortOrder
    createdAt?: SortOrder
  }

  export type PostNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    sentAt?: SortOrder
    subscriberCount?: SortOrder
    subject?: SortOrder
    emailContent?: SortOrder
    createdAt?: SortOrder
  }

  export type PostNotificationSumOrderByAggregateInput = {
    subscriberCount?: SortOrder
  }

  export type EnumEvaluationRecommendationFilter<$PrismaModel = never> = {
    equals?: $Enums.EvaluationRecommendation | EnumEvaluationRecommendationFieldRefInput<$PrismaModel>
    in?: $Enums.EvaluationRecommendation[] | ListEnumEvaluationRecommendationFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvaluationRecommendation[] | ListEnumEvaluationRecommendationFieldRefInput<$PrismaModel>
    not?: NestedEnumEvaluationRecommendationFilter<$PrismaModel> | $Enums.EvaluationRecommendation
  }

  export type CollaboratorApplicationRelationFilter = {
    is?: CollaboratorApplicationWhereInput
    isNot?: CollaboratorApplicationWhereInput
  }

  export type EvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    evaluatorId?: SortOrder
    experienceScore?: SortOrder
    skillsScore?: SortOrder
    educationScore?: SortOrder
    culturalFitScore?: SortOrder
    totalScore?: SortOrder
    recommendation?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
  }

  export type EvaluationAvgOrderByAggregateInput = {
    experienceScore?: SortOrder
    skillsScore?: SortOrder
    educationScore?: SortOrder
    culturalFitScore?: SortOrder
    totalScore?: SortOrder
  }

  export type EvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    evaluatorId?: SortOrder
    experienceScore?: SortOrder
    skillsScore?: SortOrder
    educationScore?: SortOrder
    culturalFitScore?: SortOrder
    totalScore?: SortOrder
    recommendation?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
  }

  export type EvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    evaluatorId?: SortOrder
    experienceScore?: SortOrder
    skillsScore?: SortOrder
    educationScore?: SortOrder
    culturalFitScore?: SortOrder
    totalScore?: SortOrder
    recommendation?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
  }

  export type EvaluationSumOrderByAggregateInput = {
    experienceScore?: SortOrder
    skillsScore?: SortOrder
    educationScore?: SortOrder
    culturalFitScore?: SortOrder
    totalScore?: SortOrder
  }

  export type EnumEvaluationRecommendationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvaluationRecommendation | EnumEvaluationRecommendationFieldRefInput<$PrismaModel>
    in?: $Enums.EvaluationRecommendation[] | ListEnumEvaluationRecommendationFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvaluationRecommendation[] | ListEnumEvaluationRecommendationFieldRefInput<$PrismaModel>
    not?: NestedEnumEvaluationRecommendationWithAggregatesFilter<$PrismaModel> | $Enums.EvaluationRecommendation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvaluationRecommendationFilter<$PrismaModel>
    _max?: NestedEnumEvaluationRecommendationFilter<$PrismaModel>
  }

  export type NoteCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isPrivate?: SortOrder
    createdAt?: SortOrder
  }

  export type NoteMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isPrivate?: SortOrder
    createdAt?: SortOrder
  }

  export type NoteMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isPrivate?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumInterviewTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewType | EnumInterviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewType[] | ListEnumInterviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterviewType[] | ListEnumInterviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInterviewTypeFilter<$PrismaModel> | $Enums.InterviewType
  }

  export type EnumInterviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewStatus | EnumInterviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewStatus[] | ListEnumInterviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterviewStatus[] | ListEnumInterviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterviewStatusFilter<$PrismaModel> | $Enums.InterviewStatus
  }

  export type EnumInterviewResultNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewResult | EnumInterviewResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.InterviewResult[] | ListEnumInterviewResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InterviewResult[] | ListEnumInterviewResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInterviewResultNullableFilter<$PrismaModel> | $Enums.InterviewResult | null
  }

  export type InterviewCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    type?: SortOrder
    location?: SortOrder
    meetingUrl?: SortOrder
    interviewerId?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterviewAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type InterviewMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    type?: SortOrder
    location?: SortOrder
    meetingUrl?: SortOrder
    interviewerId?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterviewMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    type?: SortOrder
    location?: SortOrder
    meetingUrl?: SortOrder
    interviewerId?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterviewSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumInterviewTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewType | EnumInterviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewType[] | ListEnumInterviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterviewType[] | ListEnumInterviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInterviewTypeWithAggregatesFilter<$PrismaModel> | $Enums.InterviewType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterviewTypeFilter<$PrismaModel>
    _max?: NestedEnumInterviewTypeFilter<$PrismaModel>
  }

  export type EnumInterviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewStatus | EnumInterviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewStatus[] | ListEnumInterviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterviewStatus[] | ListEnumInterviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.InterviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterviewStatusFilter<$PrismaModel>
    _max?: NestedEnumInterviewStatusFilter<$PrismaModel>
  }

  export type EnumInterviewResultNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewResult | EnumInterviewResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.InterviewResult[] | ListEnumInterviewResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InterviewResult[] | ListEnumInterviewResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInterviewResultNullableWithAggregatesFilter<$PrismaModel> | $Enums.InterviewResult | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInterviewResultNullableFilter<$PrismaModel>
    _max?: NestedEnumInterviewResultNullableFilter<$PrismaModel>
  }

  export type ApiIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    apiKey?: SortOrder
    apiSecret?: SortOrder
    environment?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    apiKey?: SortOrder
    apiSecret?: SortOrder
    environment?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    apiKey?: SortOrder
    apiSecret?: SortOrder
    environment?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CollaboratorApplicationCreateNestedManyWithoutUserInput = {
    create?: XOR<CollaboratorApplicationCreateWithoutUserInput, CollaboratorApplicationUncheckedCreateWithoutUserInput> | CollaboratorApplicationCreateWithoutUserInput[] | CollaboratorApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CollaboratorApplicationCreateOrConnectWithoutUserInput | CollaboratorApplicationCreateOrConnectWithoutUserInput[]
    createMany?: CollaboratorApplicationCreateManyUserInputEnvelope
    connect?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
  }

  export type CollaboratorApplicationCreateNestedManyWithoutReviewerInput = {
    create?: XOR<CollaboratorApplicationCreateWithoutReviewerInput, CollaboratorApplicationUncheckedCreateWithoutReviewerInput> | CollaboratorApplicationCreateWithoutReviewerInput[] | CollaboratorApplicationUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: CollaboratorApplicationCreateOrConnectWithoutReviewerInput | CollaboratorApplicationCreateOrConnectWithoutReviewerInput[]
    createMany?: CollaboratorApplicationCreateManyReviewerInputEnvelope
    connect?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
  }

  export type EvaluationCreateNestedManyWithoutEvaluatorInput = {
    create?: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput> | EvaluationCreateWithoutEvaluatorInput[] | EvaluationUncheckedCreateWithoutEvaluatorInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutEvaluatorInput | EvaluationCreateOrConnectWithoutEvaluatorInput[]
    createMany?: EvaluationCreateManyEvaluatorInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutAuthorInput = {
    create?: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput> | NoteCreateWithoutAuthorInput[] | NoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutAuthorInput | NoteCreateOrConnectWithoutAuthorInput[]
    createMany?: NoteCreateManyAuthorInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type InterviewCreateNestedManyWithoutInterviewerInput = {
    create?: XOR<InterviewCreateWithoutInterviewerInput, InterviewUncheckedCreateWithoutInterviewerInput> | InterviewCreateWithoutInterviewerInput[] | InterviewUncheckedCreateWithoutInterviewerInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutInterviewerInput | InterviewCreateOrConnectWithoutInterviewerInput[]
    createMany?: InterviewCreateManyInterviewerInputEnvelope
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutUserInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type LibraryCreateNestedManyWithoutUserInput = {
    create?: XOR<LibraryCreateWithoutUserInput, LibraryUncheckedCreateWithoutUserInput> | LibraryCreateWithoutUserInput[] | LibraryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LibraryCreateOrConnectWithoutUserInput | LibraryCreateOrConnectWithoutUserInput[]
    createMany?: LibraryCreateManyUserInputEnvelope
    connect?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
  }

  export type CustomPaperCreateNestedManyWithoutUserInput = {
    create?: XOR<CustomPaperCreateWithoutUserInput, CustomPaperUncheckedCreateWithoutUserInput> | CustomPaperCreateWithoutUserInput[] | CustomPaperUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomPaperCreateOrConnectWithoutUserInput | CustomPaperCreateOrConnectWithoutUserInput[]
    createMany?: CustomPaperCreateManyUserInputEnvelope
    connect?: CustomPaperWhereUniqueInput | CustomPaperWhereUniqueInput[]
  }

  export type CustomPaperMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<CustomPaperMessageCreateWithoutSenderInput, CustomPaperMessageUncheckedCreateWithoutSenderInput> | CustomPaperMessageCreateWithoutSenderInput[] | CustomPaperMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: CustomPaperMessageCreateOrConnectWithoutSenderInput | CustomPaperMessageCreateOrConnectWithoutSenderInput[]
    createMany?: CustomPaperMessageCreateManySenderInputEnvelope
    connect?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
  }

  export type CourseProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseProgressCreateWithoutUserInput, CourseProgressUncheckedCreateWithoutUserInput> | CourseProgressCreateWithoutUserInput[] | CourseProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseProgressCreateOrConnectWithoutUserInput | CourseProgressCreateOrConnectWithoutUserInput[]
    createMany?: CourseProgressCreateManyUserInputEnvelope
    connect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
  }

  export type CourseEnrollmentCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseEnrollmentCreateWithoutUserInput, CourseEnrollmentUncheckedCreateWithoutUserInput> | CourseEnrollmentCreateWithoutUserInput[] | CourseEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutUserInput | CourseEnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: CourseEnrollmentCreateManyUserInputEnvelope
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
  }

  export type BlogPostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CollaboratorApplicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CollaboratorApplicationCreateWithoutUserInput, CollaboratorApplicationUncheckedCreateWithoutUserInput> | CollaboratorApplicationCreateWithoutUserInput[] | CollaboratorApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CollaboratorApplicationCreateOrConnectWithoutUserInput | CollaboratorApplicationCreateOrConnectWithoutUserInput[]
    createMany?: CollaboratorApplicationCreateManyUserInputEnvelope
    connect?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
  }

  export type CollaboratorApplicationUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<CollaboratorApplicationCreateWithoutReviewerInput, CollaboratorApplicationUncheckedCreateWithoutReviewerInput> | CollaboratorApplicationCreateWithoutReviewerInput[] | CollaboratorApplicationUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: CollaboratorApplicationCreateOrConnectWithoutReviewerInput | CollaboratorApplicationCreateOrConnectWithoutReviewerInput[]
    createMany?: CollaboratorApplicationCreateManyReviewerInputEnvelope
    connect?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput = {
    create?: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput> | EvaluationCreateWithoutEvaluatorInput[] | EvaluationUncheckedCreateWithoutEvaluatorInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutEvaluatorInput | EvaluationCreateOrConnectWithoutEvaluatorInput[]
    createMany?: EvaluationCreateManyEvaluatorInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput> | NoteCreateWithoutAuthorInput[] | NoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutAuthorInput | NoteCreateOrConnectWithoutAuthorInput[]
    createMany?: NoteCreateManyAuthorInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type InterviewUncheckedCreateNestedManyWithoutInterviewerInput = {
    create?: XOR<InterviewCreateWithoutInterviewerInput, InterviewUncheckedCreateWithoutInterviewerInput> | InterviewCreateWithoutInterviewerInput[] | InterviewUncheckedCreateWithoutInterviewerInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutInterviewerInput | InterviewCreateOrConnectWithoutInterviewerInput[]
    createMany?: InterviewCreateManyInterviewerInputEnvelope
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type LibraryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LibraryCreateWithoutUserInput, LibraryUncheckedCreateWithoutUserInput> | LibraryCreateWithoutUserInput[] | LibraryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LibraryCreateOrConnectWithoutUserInput | LibraryCreateOrConnectWithoutUserInput[]
    createMany?: LibraryCreateManyUserInputEnvelope
    connect?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
  }

  export type CustomPaperUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CustomPaperCreateWithoutUserInput, CustomPaperUncheckedCreateWithoutUserInput> | CustomPaperCreateWithoutUserInput[] | CustomPaperUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomPaperCreateOrConnectWithoutUserInput | CustomPaperCreateOrConnectWithoutUserInput[]
    createMany?: CustomPaperCreateManyUserInputEnvelope
    connect?: CustomPaperWhereUniqueInput | CustomPaperWhereUniqueInput[]
  }

  export type CustomPaperMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<CustomPaperMessageCreateWithoutSenderInput, CustomPaperMessageUncheckedCreateWithoutSenderInput> | CustomPaperMessageCreateWithoutSenderInput[] | CustomPaperMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: CustomPaperMessageCreateOrConnectWithoutSenderInput | CustomPaperMessageCreateOrConnectWithoutSenderInput[]
    createMany?: CustomPaperMessageCreateManySenderInputEnvelope
    connect?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
  }

  export type CourseProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseProgressCreateWithoutUserInput, CourseProgressUncheckedCreateWithoutUserInput> | CourseProgressCreateWithoutUserInput[] | CourseProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseProgressCreateOrConnectWithoutUserInput | CourseProgressCreateOrConnectWithoutUserInput[]
    createMany?: CourseProgressCreateManyUserInputEnvelope
    connect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
  }

  export type CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseEnrollmentCreateWithoutUserInput, CourseEnrollmentUncheckedCreateWithoutUserInput> | CourseEnrollmentCreateWithoutUserInput[] | CourseEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutUserInput | CourseEnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: CourseEnrollmentCreateManyUserInputEnvelope
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CollaboratorApplicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<CollaboratorApplicationCreateWithoutUserInput, CollaboratorApplicationUncheckedCreateWithoutUserInput> | CollaboratorApplicationCreateWithoutUserInput[] | CollaboratorApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CollaboratorApplicationCreateOrConnectWithoutUserInput | CollaboratorApplicationCreateOrConnectWithoutUserInput[]
    upsert?: CollaboratorApplicationUpsertWithWhereUniqueWithoutUserInput | CollaboratorApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CollaboratorApplicationCreateManyUserInputEnvelope
    set?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
    disconnect?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
    delete?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
    connect?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
    update?: CollaboratorApplicationUpdateWithWhereUniqueWithoutUserInput | CollaboratorApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CollaboratorApplicationUpdateManyWithWhereWithoutUserInput | CollaboratorApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CollaboratorApplicationScalarWhereInput | CollaboratorApplicationScalarWhereInput[]
  }

  export type CollaboratorApplicationUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<CollaboratorApplicationCreateWithoutReviewerInput, CollaboratorApplicationUncheckedCreateWithoutReviewerInput> | CollaboratorApplicationCreateWithoutReviewerInput[] | CollaboratorApplicationUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: CollaboratorApplicationCreateOrConnectWithoutReviewerInput | CollaboratorApplicationCreateOrConnectWithoutReviewerInput[]
    upsert?: CollaboratorApplicationUpsertWithWhereUniqueWithoutReviewerInput | CollaboratorApplicationUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: CollaboratorApplicationCreateManyReviewerInputEnvelope
    set?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
    disconnect?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
    delete?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
    connect?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
    update?: CollaboratorApplicationUpdateWithWhereUniqueWithoutReviewerInput | CollaboratorApplicationUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: CollaboratorApplicationUpdateManyWithWhereWithoutReviewerInput | CollaboratorApplicationUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: CollaboratorApplicationScalarWhereInput | CollaboratorApplicationScalarWhereInput[]
  }

  export type EvaluationUpdateManyWithoutEvaluatorNestedInput = {
    create?: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput> | EvaluationCreateWithoutEvaluatorInput[] | EvaluationUncheckedCreateWithoutEvaluatorInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutEvaluatorInput | EvaluationCreateOrConnectWithoutEvaluatorInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutEvaluatorInput | EvaluationUpsertWithWhereUniqueWithoutEvaluatorInput[]
    createMany?: EvaluationCreateManyEvaluatorInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutEvaluatorInput | EvaluationUpdateWithWhereUniqueWithoutEvaluatorInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutEvaluatorInput | EvaluationUpdateManyWithWhereWithoutEvaluatorInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput> | NoteCreateWithoutAuthorInput[] | NoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutAuthorInput | NoteCreateOrConnectWithoutAuthorInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutAuthorInput | NoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: NoteCreateManyAuthorInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutAuthorInput | NoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutAuthorInput | NoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type InterviewUpdateManyWithoutInterviewerNestedInput = {
    create?: XOR<InterviewCreateWithoutInterviewerInput, InterviewUncheckedCreateWithoutInterviewerInput> | InterviewCreateWithoutInterviewerInput[] | InterviewUncheckedCreateWithoutInterviewerInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutInterviewerInput | InterviewCreateOrConnectWithoutInterviewerInput[]
    upsert?: InterviewUpsertWithWhereUniqueWithoutInterviewerInput | InterviewUpsertWithWhereUniqueWithoutInterviewerInput[]
    createMany?: InterviewCreateManyInterviewerInputEnvelope
    set?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    disconnect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    delete?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    update?: InterviewUpdateWithWhereUniqueWithoutInterviewerInput | InterviewUpdateWithWhereUniqueWithoutInterviewerInput[]
    updateMany?: InterviewUpdateManyWithWhereWithoutInterviewerInput | InterviewUpdateManyWithWhereWithoutInterviewerInput[]
    deleteMany?: InterviewScalarWhereInput | InterviewScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutUserNestedInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutUserInput | CertificateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutUserInput | CertificateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutUserInput | CertificateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type LibraryUpdateManyWithoutUserNestedInput = {
    create?: XOR<LibraryCreateWithoutUserInput, LibraryUncheckedCreateWithoutUserInput> | LibraryCreateWithoutUserInput[] | LibraryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LibraryCreateOrConnectWithoutUserInput | LibraryCreateOrConnectWithoutUserInput[]
    upsert?: LibraryUpsertWithWhereUniqueWithoutUserInput | LibraryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LibraryCreateManyUserInputEnvelope
    set?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
    disconnect?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
    delete?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
    connect?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
    update?: LibraryUpdateWithWhereUniqueWithoutUserInput | LibraryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LibraryUpdateManyWithWhereWithoutUserInput | LibraryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LibraryScalarWhereInput | LibraryScalarWhereInput[]
  }

  export type CustomPaperUpdateManyWithoutUserNestedInput = {
    create?: XOR<CustomPaperCreateWithoutUserInput, CustomPaperUncheckedCreateWithoutUserInput> | CustomPaperCreateWithoutUserInput[] | CustomPaperUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomPaperCreateOrConnectWithoutUserInput | CustomPaperCreateOrConnectWithoutUserInput[]
    upsert?: CustomPaperUpsertWithWhereUniqueWithoutUserInput | CustomPaperUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CustomPaperCreateManyUserInputEnvelope
    set?: CustomPaperWhereUniqueInput | CustomPaperWhereUniqueInput[]
    disconnect?: CustomPaperWhereUniqueInput | CustomPaperWhereUniqueInput[]
    delete?: CustomPaperWhereUniqueInput | CustomPaperWhereUniqueInput[]
    connect?: CustomPaperWhereUniqueInput | CustomPaperWhereUniqueInput[]
    update?: CustomPaperUpdateWithWhereUniqueWithoutUserInput | CustomPaperUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CustomPaperUpdateManyWithWhereWithoutUserInput | CustomPaperUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CustomPaperScalarWhereInput | CustomPaperScalarWhereInput[]
  }

  export type CustomPaperMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<CustomPaperMessageCreateWithoutSenderInput, CustomPaperMessageUncheckedCreateWithoutSenderInput> | CustomPaperMessageCreateWithoutSenderInput[] | CustomPaperMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: CustomPaperMessageCreateOrConnectWithoutSenderInput | CustomPaperMessageCreateOrConnectWithoutSenderInput[]
    upsert?: CustomPaperMessageUpsertWithWhereUniqueWithoutSenderInput | CustomPaperMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: CustomPaperMessageCreateManySenderInputEnvelope
    set?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
    disconnect?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
    delete?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
    connect?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
    update?: CustomPaperMessageUpdateWithWhereUniqueWithoutSenderInput | CustomPaperMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: CustomPaperMessageUpdateManyWithWhereWithoutSenderInput | CustomPaperMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: CustomPaperMessageScalarWhereInput | CustomPaperMessageScalarWhereInput[]
  }

  export type CourseProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseProgressCreateWithoutUserInput, CourseProgressUncheckedCreateWithoutUserInput> | CourseProgressCreateWithoutUserInput[] | CourseProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseProgressCreateOrConnectWithoutUserInput | CourseProgressCreateOrConnectWithoutUserInput[]
    upsert?: CourseProgressUpsertWithWhereUniqueWithoutUserInput | CourseProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseProgressCreateManyUserInputEnvelope
    set?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    disconnect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    delete?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    connect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    update?: CourseProgressUpdateWithWhereUniqueWithoutUserInput | CourseProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseProgressUpdateManyWithWhereWithoutUserInput | CourseProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseProgressScalarWhereInput | CourseProgressScalarWhereInput[]
  }

  export type CourseEnrollmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseEnrollmentCreateWithoutUserInput, CourseEnrollmentUncheckedCreateWithoutUserInput> | CourseEnrollmentCreateWithoutUserInput[] | CourseEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutUserInput | CourseEnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: CourseEnrollmentUpsertWithWhereUniqueWithoutUserInput | CourseEnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseEnrollmentCreateManyUserInputEnvelope
    set?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    disconnect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    delete?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    update?: CourseEnrollmentUpdateWithWhereUniqueWithoutUserInput | CourseEnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseEnrollmentUpdateManyWithWhereWithoutUserInput | CourseEnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
  }

  export type BlogPostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutUserInput | LikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutUserInput | LikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutUserInput | LikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CollaboratorApplicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CollaboratorApplicationCreateWithoutUserInput, CollaboratorApplicationUncheckedCreateWithoutUserInput> | CollaboratorApplicationCreateWithoutUserInput[] | CollaboratorApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CollaboratorApplicationCreateOrConnectWithoutUserInput | CollaboratorApplicationCreateOrConnectWithoutUserInput[]
    upsert?: CollaboratorApplicationUpsertWithWhereUniqueWithoutUserInput | CollaboratorApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CollaboratorApplicationCreateManyUserInputEnvelope
    set?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
    disconnect?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
    delete?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
    connect?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
    update?: CollaboratorApplicationUpdateWithWhereUniqueWithoutUserInput | CollaboratorApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CollaboratorApplicationUpdateManyWithWhereWithoutUserInput | CollaboratorApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CollaboratorApplicationScalarWhereInput | CollaboratorApplicationScalarWhereInput[]
  }

  export type CollaboratorApplicationUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<CollaboratorApplicationCreateWithoutReviewerInput, CollaboratorApplicationUncheckedCreateWithoutReviewerInput> | CollaboratorApplicationCreateWithoutReviewerInput[] | CollaboratorApplicationUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: CollaboratorApplicationCreateOrConnectWithoutReviewerInput | CollaboratorApplicationCreateOrConnectWithoutReviewerInput[]
    upsert?: CollaboratorApplicationUpsertWithWhereUniqueWithoutReviewerInput | CollaboratorApplicationUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: CollaboratorApplicationCreateManyReviewerInputEnvelope
    set?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
    disconnect?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
    delete?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
    connect?: CollaboratorApplicationWhereUniqueInput | CollaboratorApplicationWhereUniqueInput[]
    update?: CollaboratorApplicationUpdateWithWhereUniqueWithoutReviewerInput | CollaboratorApplicationUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: CollaboratorApplicationUpdateManyWithWhereWithoutReviewerInput | CollaboratorApplicationUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: CollaboratorApplicationScalarWhereInput | CollaboratorApplicationScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput = {
    create?: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput> | EvaluationCreateWithoutEvaluatorInput[] | EvaluationUncheckedCreateWithoutEvaluatorInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutEvaluatorInput | EvaluationCreateOrConnectWithoutEvaluatorInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutEvaluatorInput | EvaluationUpsertWithWhereUniqueWithoutEvaluatorInput[]
    createMany?: EvaluationCreateManyEvaluatorInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutEvaluatorInput | EvaluationUpdateWithWhereUniqueWithoutEvaluatorInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutEvaluatorInput | EvaluationUpdateManyWithWhereWithoutEvaluatorInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput> | NoteCreateWithoutAuthorInput[] | NoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutAuthorInput | NoteCreateOrConnectWithoutAuthorInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutAuthorInput | NoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: NoteCreateManyAuthorInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutAuthorInput | NoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutAuthorInput | NoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type InterviewUncheckedUpdateManyWithoutInterviewerNestedInput = {
    create?: XOR<InterviewCreateWithoutInterviewerInput, InterviewUncheckedCreateWithoutInterviewerInput> | InterviewCreateWithoutInterviewerInput[] | InterviewUncheckedCreateWithoutInterviewerInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutInterviewerInput | InterviewCreateOrConnectWithoutInterviewerInput[]
    upsert?: InterviewUpsertWithWhereUniqueWithoutInterviewerInput | InterviewUpsertWithWhereUniqueWithoutInterviewerInput[]
    createMany?: InterviewCreateManyInterviewerInputEnvelope
    set?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    disconnect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    delete?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    update?: InterviewUpdateWithWhereUniqueWithoutInterviewerInput | InterviewUpdateWithWhereUniqueWithoutInterviewerInput[]
    updateMany?: InterviewUpdateManyWithWhereWithoutInterviewerInput | InterviewUpdateManyWithWhereWithoutInterviewerInput[]
    deleteMany?: InterviewScalarWhereInput | InterviewScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutUserInput | CertificateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutUserInput | CertificateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutUserInput | CertificateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type LibraryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LibraryCreateWithoutUserInput, LibraryUncheckedCreateWithoutUserInput> | LibraryCreateWithoutUserInput[] | LibraryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LibraryCreateOrConnectWithoutUserInput | LibraryCreateOrConnectWithoutUserInput[]
    upsert?: LibraryUpsertWithWhereUniqueWithoutUserInput | LibraryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LibraryCreateManyUserInputEnvelope
    set?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
    disconnect?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
    delete?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
    connect?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
    update?: LibraryUpdateWithWhereUniqueWithoutUserInput | LibraryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LibraryUpdateManyWithWhereWithoutUserInput | LibraryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LibraryScalarWhereInput | LibraryScalarWhereInput[]
  }

  export type CustomPaperUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CustomPaperCreateWithoutUserInput, CustomPaperUncheckedCreateWithoutUserInput> | CustomPaperCreateWithoutUserInput[] | CustomPaperUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomPaperCreateOrConnectWithoutUserInput | CustomPaperCreateOrConnectWithoutUserInput[]
    upsert?: CustomPaperUpsertWithWhereUniqueWithoutUserInput | CustomPaperUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CustomPaperCreateManyUserInputEnvelope
    set?: CustomPaperWhereUniqueInput | CustomPaperWhereUniqueInput[]
    disconnect?: CustomPaperWhereUniqueInput | CustomPaperWhereUniqueInput[]
    delete?: CustomPaperWhereUniqueInput | CustomPaperWhereUniqueInput[]
    connect?: CustomPaperWhereUniqueInput | CustomPaperWhereUniqueInput[]
    update?: CustomPaperUpdateWithWhereUniqueWithoutUserInput | CustomPaperUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CustomPaperUpdateManyWithWhereWithoutUserInput | CustomPaperUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CustomPaperScalarWhereInput | CustomPaperScalarWhereInput[]
  }

  export type CustomPaperMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<CustomPaperMessageCreateWithoutSenderInput, CustomPaperMessageUncheckedCreateWithoutSenderInput> | CustomPaperMessageCreateWithoutSenderInput[] | CustomPaperMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: CustomPaperMessageCreateOrConnectWithoutSenderInput | CustomPaperMessageCreateOrConnectWithoutSenderInput[]
    upsert?: CustomPaperMessageUpsertWithWhereUniqueWithoutSenderInput | CustomPaperMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: CustomPaperMessageCreateManySenderInputEnvelope
    set?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
    disconnect?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
    delete?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
    connect?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
    update?: CustomPaperMessageUpdateWithWhereUniqueWithoutSenderInput | CustomPaperMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: CustomPaperMessageUpdateManyWithWhereWithoutSenderInput | CustomPaperMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: CustomPaperMessageScalarWhereInput | CustomPaperMessageScalarWhereInput[]
  }

  export type CourseProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseProgressCreateWithoutUserInput, CourseProgressUncheckedCreateWithoutUserInput> | CourseProgressCreateWithoutUserInput[] | CourseProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseProgressCreateOrConnectWithoutUserInput | CourseProgressCreateOrConnectWithoutUserInput[]
    upsert?: CourseProgressUpsertWithWhereUniqueWithoutUserInput | CourseProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseProgressCreateManyUserInputEnvelope
    set?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    disconnect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    delete?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    connect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    update?: CourseProgressUpdateWithWhereUniqueWithoutUserInput | CourseProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseProgressUpdateManyWithWhereWithoutUserInput | CourseProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseProgressScalarWhereInput | CourseProgressScalarWhereInput[]
  }

  export type CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseEnrollmentCreateWithoutUserInput, CourseEnrollmentUncheckedCreateWithoutUserInput> | CourseEnrollmentCreateWithoutUserInput[] | CourseEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutUserInput | CourseEnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: CourseEnrollmentUpsertWithWhereUniqueWithoutUserInput | CourseEnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseEnrollmentCreateManyUserInputEnvelope
    set?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    disconnect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    delete?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    update?: CourseEnrollmentUpdateWithWhereUniqueWithoutUserInput | CourseEnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseEnrollmentUpdateManyWithWhereWithoutUserInput | CourseEnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutUserInput | LikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutUserInput | LikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutUserInput | LikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type CustomPaperCreateNestedOneWithoutOrderInput = {
    create?: XOR<CustomPaperCreateWithoutOrderInput, CustomPaperUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CustomPaperCreateOrConnectWithoutOrderInput
    connect?: CustomPaperWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type CustomPaperUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<CustomPaperCreateWithoutOrderInput, CustomPaperUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CustomPaperCreateOrConnectWithoutOrderInput
    connect?: CustomPaperWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type UserUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type CustomPaperUpdateOneWithoutOrderNestedInput = {
    create?: XOR<CustomPaperCreateWithoutOrderInput, CustomPaperUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CustomPaperCreateOrConnectWithoutOrderInput
    upsert?: CustomPaperUpsertWithoutOrderInput
    disconnect?: CustomPaperWhereInput | boolean
    delete?: CustomPaperWhereInput | boolean
    connect?: CustomPaperWhereUniqueInput
    update?: XOR<XOR<CustomPaperUpdateToOneWithWhereWithoutOrderInput, CustomPaperUpdateWithoutOrderInput>, CustomPaperUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type CustomPaperUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<CustomPaperCreateWithoutOrderInput, CustomPaperUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CustomPaperCreateOrConnectWithoutOrderInput
    upsert?: CustomPaperUpsertWithoutOrderInput
    disconnect?: CustomPaperWhereInput | boolean
    delete?: CustomPaperWhereInput | boolean
    connect?: CustomPaperWhereUniqueInput
    update?: XOR<XOR<CustomPaperUpdateToOneWithWhereWithoutOrderInput, CustomPaperUpdateWithoutOrderInput>, CustomPaperUncheckedUpdateWithoutOrderInput>
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type PaperCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<PaperCreateWithoutOrderItemsInput, PaperUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: PaperCreateOrConnectWithoutOrderItemsInput
    connect?: PaperWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<CourseCreateWithoutOrderItemsInput, CourseUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutOrderItemsInput
    connect?: CourseWhereUniqueInput
  }

  export type EbookCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<EbookCreateWithoutOrderItemsInput, EbookUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: EbookCreateOrConnectWithoutOrderItemsInput
    connect?: EbookWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type PaperUpdateOneWithoutOrderItemsNestedInput = {
    create?: XOR<PaperCreateWithoutOrderItemsInput, PaperUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: PaperCreateOrConnectWithoutOrderItemsInput
    upsert?: PaperUpsertWithoutOrderItemsInput
    disconnect?: PaperWhereInput | boolean
    delete?: PaperWhereInput | boolean
    connect?: PaperWhereUniqueInput
    update?: XOR<XOR<PaperUpdateToOneWithWhereWithoutOrderItemsInput, PaperUpdateWithoutOrderItemsInput>, PaperUncheckedUpdateWithoutOrderItemsInput>
  }

  export type CourseUpdateOneWithoutOrderItemsNestedInput = {
    create?: XOR<CourseCreateWithoutOrderItemsInput, CourseUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutOrderItemsInput
    upsert?: CourseUpsertWithoutOrderItemsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutOrderItemsInput, CourseUpdateWithoutOrderItemsInput>, CourseUncheckedUpdateWithoutOrderItemsInput>
  }

  export type EbookUpdateOneWithoutOrderItemsNestedInput = {
    create?: XOR<EbookCreateWithoutOrderItemsInput, EbookUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: EbookCreateOrConnectWithoutOrderItemsInput
    upsert?: EbookUpsertWithoutOrderItemsInput
    disconnect?: EbookWhereInput | boolean
    delete?: EbookWhereInput | boolean
    connect?: EbookWhereUniqueInput
    update?: XOR<XOR<EbookUpdateToOneWithWhereWithoutOrderItemsInput, EbookUpdateWithoutOrderItemsInput>, EbookUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderItemCreateNestedManyWithoutPaperInput = {
    create?: XOR<OrderItemCreateWithoutPaperInput, OrderItemUncheckedCreateWithoutPaperInput> | OrderItemCreateWithoutPaperInput[] | OrderItemUncheckedCreateWithoutPaperInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutPaperInput | OrderItemCreateOrConnectWithoutPaperInput[]
    createMany?: OrderItemCreateManyPaperInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutPaperInput = {
    create?: XOR<OrderItemCreateWithoutPaperInput, OrderItemUncheckedCreateWithoutPaperInput> | OrderItemCreateWithoutPaperInput[] | OrderItemUncheckedCreateWithoutPaperInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutPaperInput | OrderItemCreateOrConnectWithoutPaperInput[]
    createMany?: OrderItemCreateManyPaperInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type EnumPaperTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaperType
  }

  export type EnumAcademicAreaFieldUpdateOperationsInput = {
    set?: $Enums.AcademicArea
  }

  export type OrderItemUpdateManyWithoutPaperNestedInput = {
    create?: XOR<OrderItemCreateWithoutPaperInput, OrderItemUncheckedCreateWithoutPaperInput> | OrderItemCreateWithoutPaperInput[] | OrderItemUncheckedCreateWithoutPaperInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutPaperInput | OrderItemCreateOrConnectWithoutPaperInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutPaperInput | OrderItemUpsertWithWhereUniqueWithoutPaperInput[]
    createMany?: OrderItemCreateManyPaperInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutPaperInput | OrderItemUpdateWithWhereUniqueWithoutPaperInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutPaperInput | OrderItemUpdateManyWithWhereWithoutPaperInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutPaperNestedInput = {
    create?: XOR<OrderItemCreateWithoutPaperInput, OrderItemUncheckedCreateWithoutPaperInput> | OrderItemCreateWithoutPaperInput[] | OrderItemUncheckedCreateWithoutPaperInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutPaperInput | OrderItemCreateOrConnectWithoutPaperInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutPaperInput | OrderItemUpsertWithWhereUniqueWithoutPaperInput[]
    createMany?: OrderItemCreateManyPaperInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutPaperInput | OrderItemUpdateWithWhereUniqueWithoutPaperInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutPaperInput | OrderItemUpdateManyWithWhereWithoutPaperInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderItemCreateNestedManyWithoutCourseInput = {
    create?: XOR<OrderItemCreateWithoutCourseInput, OrderItemUncheckedCreateWithoutCourseInput> | OrderItemCreateWithoutCourseInput[] | OrderItemUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutCourseInput | OrderItemCreateOrConnectWithoutCourseInput[]
    createMany?: OrderItemCreateManyCourseInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutCourseInput = {
    create?: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput> | CertificateCreateWithoutCourseInput[] | CertificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput | CertificateCreateOrConnectWithoutCourseInput[]
    createMany?: CertificateCreateManyCourseInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type CourseModuleCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
  }

  export type CourseEnrollmentCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput> | CourseEnrollmentCreateWithoutCourseInput[] | CourseEnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutCourseInput | CourseEnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: CourseEnrollmentCreateManyCourseInputEnvelope
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<OrderItemCreateWithoutCourseInput, OrderItemUncheckedCreateWithoutCourseInput> | OrderItemCreateWithoutCourseInput[] | OrderItemUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutCourseInput | OrderItemCreateOrConnectWithoutCourseInput[]
    createMany?: OrderItemCreateManyCourseInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput> | CertificateCreateWithoutCourseInput[] | CertificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput | CertificateCreateOrConnectWithoutCourseInput[]
    createMany?: CertificateCreateManyCourseInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type CourseModuleUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
  }

  export type CourseEnrollmentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput> | CourseEnrollmentCreateWithoutCourseInput[] | CourseEnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutCourseInput | CourseEnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: CourseEnrollmentCreateManyCourseInputEnvelope
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
  }

  export type EnumCourseLevelFieldUpdateOperationsInput = {
    set?: $Enums.CourseLevel
  }

  export type EnumCourseStatusFieldUpdateOperationsInput = {
    set?: $Enums.CourseStatus
  }

  export type OrderItemUpdateManyWithoutCourseNestedInput = {
    create?: XOR<OrderItemCreateWithoutCourseInput, OrderItemUncheckedCreateWithoutCourseInput> | OrderItemCreateWithoutCourseInput[] | OrderItemUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutCourseInput | OrderItemCreateOrConnectWithoutCourseInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutCourseInput | OrderItemUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: OrderItemCreateManyCourseInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutCourseInput | OrderItemUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutCourseInput | OrderItemUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput> | CertificateCreateWithoutCourseInput[] | CertificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput | CertificateCreateOrConnectWithoutCourseInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutCourseInput | CertificateUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CertificateCreateManyCourseInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutCourseInput | CertificateUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutCourseInput | CertificateUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type CourseModuleUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    upsert?: CourseModuleUpsertWithWhereUniqueWithoutCourseInput | CourseModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    set?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    disconnect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    delete?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    update?: CourseModuleUpdateWithWhereUniqueWithoutCourseInput | CourseModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseModuleUpdateManyWithWhereWithoutCourseInput | CourseModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
  }

  export type CourseEnrollmentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput> | CourseEnrollmentCreateWithoutCourseInput[] | CourseEnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutCourseInput | CourseEnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: CourseEnrollmentUpsertWithWhereUniqueWithoutCourseInput | CourseEnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseEnrollmentCreateManyCourseInputEnvelope
    set?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    disconnect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    delete?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    update?: CourseEnrollmentUpdateWithWhereUniqueWithoutCourseInput | CourseEnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseEnrollmentUpdateManyWithWhereWithoutCourseInput | CourseEnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<OrderItemCreateWithoutCourseInput, OrderItemUncheckedCreateWithoutCourseInput> | OrderItemCreateWithoutCourseInput[] | OrderItemUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutCourseInput | OrderItemCreateOrConnectWithoutCourseInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutCourseInput | OrderItemUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: OrderItemCreateManyCourseInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutCourseInput | OrderItemUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutCourseInput | OrderItemUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput> | CertificateCreateWithoutCourseInput[] | CertificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput | CertificateCreateOrConnectWithoutCourseInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutCourseInput | CertificateUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CertificateCreateManyCourseInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutCourseInput | CertificateUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutCourseInput | CertificateUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type CourseModuleUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    upsert?: CourseModuleUpsertWithWhereUniqueWithoutCourseInput | CourseModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    set?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    disconnect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    delete?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    update?: CourseModuleUpdateWithWhereUniqueWithoutCourseInput | CourseModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseModuleUpdateManyWithWhereWithoutCourseInput | CourseModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
  }

  export type CourseEnrollmentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput> | CourseEnrollmentCreateWithoutCourseInput[] | CourseEnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutCourseInput | CourseEnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: CourseEnrollmentUpsertWithWhereUniqueWithoutCourseInput | CourseEnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseEnrollmentCreateManyCourseInputEnvelope
    set?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    disconnect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    delete?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    update?: CourseEnrollmentUpdateWithWhereUniqueWithoutCourseInput | CourseEnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseEnrollmentUpdateManyWithWhereWithoutCourseInput | CourseEnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
  }

  export type EbookFileCreateNestedManyWithoutEbookInput = {
    create?: XOR<EbookFileCreateWithoutEbookInput, EbookFileUncheckedCreateWithoutEbookInput> | EbookFileCreateWithoutEbookInput[] | EbookFileUncheckedCreateWithoutEbookInput[]
    connectOrCreate?: EbookFileCreateOrConnectWithoutEbookInput | EbookFileCreateOrConnectWithoutEbookInput[]
    createMany?: EbookFileCreateManyEbookInputEnvelope
    connect?: EbookFileWhereUniqueInput | EbookFileWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutEbookInput = {
    create?: XOR<OrderItemCreateWithoutEbookInput, OrderItemUncheckedCreateWithoutEbookInput> | OrderItemCreateWithoutEbookInput[] | OrderItemUncheckedCreateWithoutEbookInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutEbookInput | OrderItemCreateOrConnectWithoutEbookInput[]
    createMany?: OrderItemCreateManyEbookInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type EbookFileUncheckedCreateNestedManyWithoutEbookInput = {
    create?: XOR<EbookFileCreateWithoutEbookInput, EbookFileUncheckedCreateWithoutEbookInput> | EbookFileCreateWithoutEbookInput[] | EbookFileUncheckedCreateWithoutEbookInput[]
    connectOrCreate?: EbookFileCreateOrConnectWithoutEbookInput | EbookFileCreateOrConnectWithoutEbookInput[]
    createMany?: EbookFileCreateManyEbookInputEnvelope
    connect?: EbookFileWhereUniqueInput | EbookFileWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutEbookInput = {
    create?: XOR<OrderItemCreateWithoutEbookInput, OrderItemUncheckedCreateWithoutEbookInput> | OrderItemCreateWithoutEbookInput[] | OrderItemUncheckedCreateWithoutEbookInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutEbookInput | OrderItemCreateOrConnectWithoutEbookInput[]
    createMany?: OrderItemCreateManyEbookInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type EbookFileUpdateManyWithoutEbookNestedInput = {
    create?: XOR<EbookFileCreateWithoutEbookInput, EbookFileUncheckedCreateWithoutEbookInput> | EbookFileCreateWithoutEbookInput[] | EbookFileUncheckedCreateWithoutEbookInput[]
    connectOrCreate?: EbookFileCreateOrConnectWithoutEbookInput | EbookFileCreateOrConnectWithoutEbookInput[]
    upsert?: EbookFileUpsertWithWhereUniqueWithoutEbookInput | EbookFileUpsertWithWhereUniqueWithoutEbookInput[]
    createMany?: EbookFileCreateManyEbookInputEnvelope
    set?: EbookFileWhereUniqueInput | EbookFileWhereUniqueInput[]
    disconnect?: EbookFileWhereUniqueInput | EbookFileWhereUniqueInput[]
    delete?: EbookFileWhereUniqueInput | EbookFileWhereUniqueInput[]
    connect?: EbookFileWhereUniqueInput | EbookFileWhereUniqueInput[]
    update?: EbookFileUpdateWithWhereUniqueWithoutEbookInput | EbookFileUpdateWithWhereUniqueWithoutEbookInput[]
    updateMany?: EbookFileUpdateManyWithWhereWithoutEbookInput | EbookFileUpdateManyWithWhereWithoutEbookInput[]
    deleteMany?: EbookFileScalarWhereInput | EbookFileScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutEbookNestedInput = {
    create?: XOR<OrderItemCreateWithoutEbookInput, OrderItemUncheckedCreateWithoutEbookInput> | OrderItemCreateWithoutEbookInput[] | OrderItemUncheckedCreateWithoutEbookInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutEbookInput | OrderItemCreateOrConnectWithoutEbookInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutEbookInput | OrderItemUpsertWithWhereUniqueWithoutEbookInput[]
    createMany?: OrderItemCreateManyEbookInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutEbookInput | OrderItemUpdateWithWhereUniqueWithoutEbookInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutEbookInput | OrderItemUpdateManyWithWhereWithoutEbookInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type EbookFileUncheckedUpdateManyWithoutEbookNestedInput = {
    create?: XOR<EbookFileCreateWithoutEbookInput, EbookFileUncheckedCreateWithoutEbookInput> | EbookFileCreateWithoutEbookInput[] | EbookFileUncheckedCreateWithoutEbookInput[]
    connectOrCreate?: EbookFileCreateOrConnectWithoutEbookInput | EbookFileCreateOrConnectWithoutEbookInput[]
    upsert?: EbookFileUpsertWithWhereUniqueWithoutEbookInput | EbookFileUpsertWithWhereUniqueWithoutEbookInput[]
    createMany?: EbookFileCreateManyEbookInputEnvelope
    set?: EbookFileWhereUniqueInput | EbookFileWhereUniqueInput[]
    disconnect?: EbookFileWhereUniqueInput | EbookFileWhereUniqueInput[]
    delete?: EbookFileWhereUniqueInput | EbookFileWhereUniqueInput[]
    connect?: EbookFileWhereUniqueInput | EbookFileWhereUniqueInput[]
    update?: EbookFileUpdateWithWhereUniqueWithoutEbookInput | EbookFileUpdateWithWhereUniqueWithoutEbookInput[]
    updateMany?: EbookFileUpdateManyWithWhereWithoutEbookInput | EbookFileUpdateManyWithWhereWithoutEbookInput[]
    deleteMany?: EbookFileScalarWhereInput | EbookFileScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutEbookNestedInput = {
    create?: XOR<OrderItemCreateWithoutEbookInput, OrderItemUncheckedCreateWithoutEbookInput> | OrderItemCreateWithoutEbookInput[] | OrderItemUncheckedCreateWithoutEbookInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutEbookInput | OrderItemCreateOrConnectWithoutEbookInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutEbookInput | OrderItemUpsertWithWhereUniqueWithoutEbookInput[]
    createMany?: OrderItemCreateManyEbookInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutEbookInput | OrderItemUpdateWithWhereUniqueWithoutEbookInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutEbookInput | OrderItemUpdateManyWithWhereWithoutEbookInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type EbookCreateNestedOneWithoutFilesInput = {
    create?: XOR<EbookCreateWithoutFilesInput, EbookUncheckedCreateWithoutFilesInput>
    connectOrCreate?: EbookCreateOrConnectWithoutFilesInput
    connect?: EbookWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EbookUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<EbookCreateWithoutFilesInput, EbookUncheckedCreateWithoutFilesInput>
    connectOrCreate?: EbookCreateOrConnectWithoutFilesInput
    upsert?: EbookUpsertWithoutFilesInput
    connect?: EbookWhereUniqueInput
    update?: XOR<XOR<EbookUpdateToOneWithWhereWithoutFilesInput, EbookUpdateWithoutFilesInput>, EbookUncheckedUpdateWithoutFilesInput>
  }

  export type UserCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificatesInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<CourseCreateWithoutCertificatesInput, CourseUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCertificatesInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificatesInput
    upsert?: UserUpsertWithoutCertificatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCertificatesInput, UserUpdateWithoutCertificatesInput>, UserUncheckedUpdateWithoutCertificatesInput>
  }

  export type CourseUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<CourseCreateWithoutCertificatesInput, CourseUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCertificatesInput
    upsert?: CourseUpsertWithoutCertificatesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCertificatesInput, CourseUpdateWithoutCertificatesInput>, CourseUncheckedUpdateWithoutCertificatesInput>
  }

  export type UserCreateNestedOneWithoutLibraryInput = {
    create?: XOR<UserCreateWithoutLibraryInput, UserUncheckedCreateWithoutLibraryInput>
    connectOrCreate?: UserCreateOrConnectWithoutLibraryInput
    connect?: UserWhereUniqueInput
  }

  export type EnumLibraryItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.LibraryItemType
  }

  export type UserUpdateOneRequiredWithoutLibraryNestedInput = {
    create?: XOR<UserCreateWithoutLibraryInput, UserUncheckedCreateWithoutLibraryInput>
    connectOrCreate?: UserCreateOrConnectWithoutLibraryInput
    upsert?: UserUpsertWithoutLibraryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLibraryInput, UserUpdateWithoutLibraryInput>, UserUncheckedUpdateWithoutLibraryInput>
  }

  export type BlogPostCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput> | BlogPostCreateWithoutCategoryInput[] | BlogPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoryInput | BlogPostCreateOrConnectWithoutCategoryInput[]
    createMany?: BlogPostCreateManyCategoryInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type NewsletterSubscriptionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<NewsletterSubscriptionCreateWithoutCategoryInput, NewsletterSubscriptionUncheckedCreateWithoutCategoryInput> | NewsletterSubscriptionCreateWithoutCategoryInput[] | NewsletterSubscriptionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: NewsletterSubscriptionCreateOrConnectWithoutCategoryInput | NewsletterSubscriptionCreateOrConnectWithoutCategoryInput[]
    createMany?: NewsletterSubscriptionCreateManyCategoryInputEnvelope
    connect?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput> | BlogPostCreateWithoutCategoryInput[] | BlogPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoryInput | BlogPostCreateOrConnectWithoutCategoryInput[]
    createMany?: BlogPostCreateManyCategoryInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type NewsletterSubscriptionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<NewsletterSubscriptionCreateWithoutCategoryInput, NewsletterSubscriptionUncheckedCreateWithoutCategoryInput> | NewsletterSubscriptionCreateWithoutCategoryInput[] | NewsletterSubscriptionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: NewsletterSubscriptionCreateOrConnectWithoutCategoryInput | NewsletterSubscriptionCreateOrConnectWithoutCategoryInput[]
    createMany?: NewsletterSubscriptionCreateManyCategoryInputEnvelope
    connect?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
  }

  export type BlogPostUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput> | BlogPostCreateWithoutCategoryInput[] | BlogPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoryInput | BlogPostCreateOrConnectWithoutCategoryInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutCategoryInput | BlogPostUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BlogPostCreateManyCategoryInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutCategoryInput | BlogPostUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutCategoryInput | BlogPostUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type NewsletterSubscriptionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<NewsletterSubscriptionCreateWithoutCategoryInput, NewsletterSubscriptionUncheckedCreateWithoutCategoryInput> | NewsletterSubscriptionCreateWithoutCategoryInput[] | NewsletterSubscriptionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: NewsletterSubscriptionCreateOrConnectWithoutCategoryInput | NewsletterSubscriptionCreateOrConnectWithoutCategoryInput[]
    upsert?: NewsletterSubscriptionUpsertWithWhereUniqueWithoutCategoryInput | NewsletterSubscriptionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: NewsletterSubscriptionCreateManyCategoryInputEnvelope
    set?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
    disconnect?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
    delete?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
    connect?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
    update?: NewsletterSubscriptionUpdateWithWhereUniqueWithoutCategoryInput | NewsletterSubscriptionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: NewsletterSubscriptionUpdateManyWithWhereWithoutCategoryInput | NewsletterSubscriptionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: NewsletterSubscriptionScalarWhereInput | NewsletterSubscriptionScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput> | BlogPostCreateWithoutCategoryInput[] | BlogPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoryInput | BlogPostCreateOrConnectWithoutCategoryInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutCategoryInput | BlogPostUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BlogPostCreateManyCategoryInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutCategoryInput | BlogPostUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutCategoryInput | BlogPostUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type NewsletterSubscriptionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<NewsletterSubscriptionCreateWithoutCategoryInput, NewsletterSubscriptionUncheckedCreateWithoutCategoryInput> | NewsletterSubscriptionCreateWithoutCategoryInput[] | NewsletterSubscriptionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: NewsletterSubscriptionCreateOrConnectWithoutCategoryInput | NewsletterSubscriptionCreateOrConnectWithoutCategoryInput[]
    upsert?: NewsletterSubscriptionUpsertWithWhereUniqueWithoutCategoryInput | NewsletterSubscriptionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: NewsletterSubscriptionCreateManyCategoryInputEnvelope
    set?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
    disconnect?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
    delete?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
    connect?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
    update?: NewsletterSubscriptionUpdateWithWhereUniqueWithoutCategoryInput | NewsletterSubscriptionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: NewsletterSubscriptionUpdateManyWithWhereWithoutCategoryInput | NewsletterSubscriptionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: NewsletterSubscriptionScalarWhereInput | NewsletterSubscriptionScalarWhereInput[]
  }

  export type BlogTagCreateNestedManyWithoutTagInput = {
    create?: XOR<BlogTagCreateWithoutTagInput, BlogTagUncheckedCreateWithoutTagInput> | BlogTagCreateWithoutTagInput[] | BlogTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutTagInput | BlogTagCreateOrConnectWithoutTagInput[]
    createMany?: BlogTagCreateManyTagInputEnvelope
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
  }

  export type BlogTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<BlogTagCreateWithoutTagInput, BlogTagUncheckedCreateWithoutTagInput> | BlogTagCreateWithoutTagInput[] | BlogTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutTagInput | BlogTagCreateOrConnectWithoutTagInput[]
    createMany?: BlogTagCreateManyTagInputEnvelope
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
  }

  export type BlogTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<BlogTagCreateWithoutTagInput, BlogTagUncheckedCreateWithoutTagInput> | BlogTagCreateWithoutTagInput[] | BlogTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutTagInput | BlogTagCreateOrConnectWithoutTagInput[]
    upsert?: BlogTagUpsertWithWhereUniqueWithoutTagInput | BlogTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: BlogTagCreateManyTagInputEnvelope
    set?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    disconnect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    delete?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    update?: BlogTagUpdateWithWhereUniqueWithoutTagInput | BlogTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: BlogTagUpdateManyWithWhereWithoutTagInput | BlogTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
  }

  export type BlogTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<BlogTagCreateWithoutTagInput, BlogTagUncheckedCreateWithoutTagInput> | BlogTagCreateWithoutTagInput[] | BlogTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutTagInput | BlogTagCreateOrConnectWithoutTagInput[]
    upsert?: BlogTagUpsertWithWhereUniqueWithoutTagInput | BlogTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: BlogTagCreateManyTagInputEnvelope
    set?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    disconnect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    delete?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    update?: BlogTagUpdateWithWhereUniqueWithoutTagInput | BlogTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: BlogTagUpdateManyWithWhereWithoutTagInput | BlogTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
  }

  export type BlogPostCreatemetaKeywordsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutBlogPostsInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutPostsInput = {
    create?: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput
    connect?: CategoryWhereUniqueInput
  }

  export type BlogTagCreateNestedManyWithoutPostInput = {
    create?: XOR<BlogTagCreateWithoutPostInput, BlogTagUncheckedCreateWithoutPostInput> | BlogTagCreateWithoutPostInput[] | BlogTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutPostInput | BlogTagCreateOrConnectWithoutPostInput[]
    createMany?: BlogTagCreateManyPostInputEnvelope
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutPostInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type PostAnalyticsCreateNestedManyWithoutPostInput = {
    create?: XOR<PostAnalyticsCreateWithoutPostInput, PostAnalyticsUncheckedCreateWithoutPostInput> | PostAnalyticsCreateWithoutPostInput[] | PostAnalyticsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostAnalyticsCreateOrConnectWithoutPostInput | PostAnalyticsCreateOrConnectWithoutPostInput[]
    createMany?: PostAnalyticsCreateManyPostInputEnvelope
    connect?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
  }

  export type PostNotificationCreateNestedManyWithoutPostInput = {
    create?: XOR<PostNotificationCreateWithoutPostInput, PostNotificationUncheckedCreateWithoutPostInput> | PostNotificationCreateWithoutPostInput[] | PostNotificationUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostNotificationCreateOrConnectWithoutPostInput | PostNotificationCreateOrConnectWithoutPostInput[]
    createMany?: PostNotificationCreateManyPostInputEnvelope
    connect?: PostNotificationWhereUniqueInput | PostNotificationWhereUniqueInput[]
  }

  export type BlogTagUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<BlogTagCreateWithoutPostInput, BlogTagUncheckedCreateWithoutPostInput> | BlogTagCreateWithoutPostInput[] | BlogTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutPostInput | BlogTagCreateOrConnectWithoutPostInput[]
    createMany?: BlogTagCreateManyPostInputEnvelope
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type PostAnalyticsUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostAnalyticsCreateWithoutPostInput, PostAnalyticsUncheckedCreateWithoutPostInput> | PostAnalyticsCreateWithoutPostInput[] | PostAnalyticsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostAnalyticsCreateOrConnectWithoutPostInput | PostAnalyticsCreateOrConnectWithoutPostInput[]
    createMany?: PostAnalyticsCreateManyPostInputEnvelope
    connect?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
  }

  export type PostNotificationUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostNotificationCreateWithoutPostInput, PostNotificationUncheckedCreateWithoutPostInput> | PostNotificationCreateWithoutPostInput[] | PostNotificationUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostNotificationCreateOrConnectWithoutPostInput | PostNotificationCreateOrConnectWithoutPostInput[]
    createMany?: PostNotificationCreateManyPostInputEnvelope
    connect?: PostNotificationWhereUniqueInput | PostNotificationWhereUniqueInput[]
  }

  export type EnumPostStatusFieldUpdateOperationsInput = {
    set?: $Enums.PostStatus
  }

  export type BlogPostUpdatemetaKeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutBlogPostsNestedInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    upsert?: UserUpsertWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogPostsInput, UserUpdateWithoutBlogPostsInput>, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type CategoryUpdateOneWithoutPostsNestedInput = {
    create?: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput
    upsert?: CategoryUpsertWithoutPostsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutPostsInput, CategoryUpdateWithoutPostsInput>, CategoryUncheckedUpdateWithoutPostsInput>
  }

  export type BlogTagUpdateManyWithoutPostNestedInput = {
    create?: XOR<BlogTagCreateWithoutPostInput, BlogTagUncheckedCreateWithoutPostInput> | BlogTagCreateWithoutPostInput[] | BlogTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutPostInput | BlogTagCreateOrConnectWithoutPostInput[]
    upsert?: BlogTagUpsertWithWhereUniqueWithoutPostInput | BlogTagUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: BlogTagCreateManyPostInputEnvelope
    set?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    disconnect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    delete?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    update?: BlogTagUpdateWithWhereUniqueWithoutPostInput | BlogTagUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: BlogTagUpdateManyWithWhereWithoutPostInput | BlogTagUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutPostNestedInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPostInput | LikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPostInput | LikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPostInput | LikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type PostAnalyticsUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostAnalyticsCreateWithoutPostInput, PostAnalyticsUncheckedCreateWithoutPostInput> | PostAnalyticsCreateWithoutPostInput[] | PostAnalyticsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostAnalyticsCreateOrConnectWithoutPostInput | PostAnalyticsCreateOrConnectWithoutPostInput[]
    upsert?: PostAnalyticsUpsertWithWhereUniqueWithoutPostInput | PostAnalyticsUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostAnalyticsCreateManyPostInputEnvelope
    set?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
    disconnect?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
    delete?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
    connect?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
    update?: PostAnalyticsUpdateWithWhereUniqueWithoutPostInput | PostAnalyticsUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostAnalyticsUpdateManyWithWhereWithoutPostInput | PostAnalyticsUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostAnalyticsScalarWhereInput | PostAnalyticsScalarWhereInput[]
  }

  export type PostNotificationUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostNotificationCreateWithoutPostInput, PostNotificationUncheckedCreateWithoutPostInput> | PostNotificationCreateWithoutPostInput[] | PostNotificationUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostNotificationCreateOrConnectWithoutPostInput | PostNotificationCreateOrConnectWithoutPostInput[]
    upsert?: PostNotificationUpsertWithWhereUniqueWithoutPostInput | PostNotificationUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostNotificationCreateManyPostInputEnvelope
    set?: PostNotificationWhereUniqueInput | PostNotificationWhereUniqueInput[]
    disconnect?: PostNotificationWhereUniqueInput | PostNotificationWhereUniqueInput[]
    delete?: PostNotificationWhereUniqueInput | PostNotificationWhereUniqueInput[]
    connect?: PostNotificationWhereUniqueInput | PostNotificationWhereUniqueInput[]
    update?: PostNotificationUpdateWithWhereUniqueWithoutPostInput | PostNotificationUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostNotificationUpdateManyWithWhereWithoutPostInput | PostNotificationUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostNotificationScalarWhereInput | PostNotificationScalarWhereInput[]
  }

  export type BlogTagUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<BlogTagCreateWithoutPostInput, BlogTagUncheckedCreateWithoutPostInput> | BlogTagCreateWithoutPostInput[] | BlogTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutPostInput | BlogTagCreateOrConnectWithoutPostInput[]
    upsert?: BlogTagUpsertWithWhereUniqueWithoutPostInput | BlogTagUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: BlogTagCreateManyPostInputEnvelope
    set?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    disconnect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    delete?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    update?: BlogTagUpdateWithWhereUniqueWithoutPostInput | BlogTagUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: BlogTagUpdateManyWithWhereWithoutPostInput | BlogTagUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPostInput | LikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPostInput | LikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPostInput | LikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type PostAnalyticsUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostAnalyticsCreateWithoutPostInput, PostAnalyticsUncheckedCreateWithoutPostInput> | PostAnalyticsCreateWithoutPostInput[] | PostAnalyticsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostAnalyticsCreateOrConnectWithoutPostInput | PostAnalyticsCreateOrConnectWithoutPostInput[]
    upsert?: PostAnalyticsUpsertWithWhereUniqueWithoutPostInput | PostAnalyticsUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostAnalyticsCreateManyPostInputEnvelope
    set?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
    disconnect?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
    delete?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
    connect?: PostAnalyticsWhereUniqueInput | PostAnalyticsWhereUniqueInput[]
    update?: PostAnalyticsUpdateWithWhereUniqueWithoutPostInput | PostAnalyticsUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostAnalyticsUpdateManyWithWhereWithoutPostInput | PostAnalyticsUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostAnalyticsScalarWhereInput | PostAnalyticsScalarWhereInput[]
  }

  export type PostNotificationUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostNotificationCreateWithoutPostInput, PostNotificationUncheckedCreateWithoutPostInput> | PostNotificationCreateWithoutPostInput[] | PostNotificationUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostNotificationCreateOrConnectWithoutPostInput | PostNotificationCreateOrConnectWithoutPostInput[]
    upsert?: PostNotificationUpsertWithWhereUniqueWithoutPostInput | PostNotificationUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostNotificationCreateManyPostInputEnvelope
    set?: PostNotificationWhereUniqueInput | PostNotificationWhereUniqueInput[]
    disconnect?: PostNotificationWhereUniqueInput | PostNotificationWhereUniqueInput[]
    delete?: PostNotificationWhereUniqueInput | PostNotificationWhereUniqueInput[]
    connect?: PostNotificationWhereUniqueInput | PostNotificationWhereUniqueInput[]
    update?: PostNotificationUpdateWithWhereUniqueWithoutPostInput | PostNotificationUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostNotificationUpdateManyWithWhereWithoutPostInput | PostNotificationUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostNotificationScalarWhereInput | PostNotificationScalarWhereInput[]
  }

  export type BlogPostCreateNestedOneWithoutTagsInput = {
    create?: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutTagsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutPostsInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput
    connect?: TagWhereUniqueInput
  }

  export type BlogPostUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutTagsInput
    upsert?: BlogPostUpsertWithoutTagsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutTagsInput, BlogPostUpdateWithoutTagsInput>, BlogPostUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput
    upsert?: TagUpsertWithoutPostsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutPostsInput, TagUpdateWithoutPostsInput>, TagUncheckedUpdateWithoutPostsInput>
  }

  export type BlogPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<BlogPostCreateWithoutCommentsInput, BlogPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutCommentsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type BlogPostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<BlogPostCreateWithoutCommentsInput, BlogPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutCommentsInput
    upsert?: BlogPostUpsertWithoutCommentsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutCommentsInput, BlogPostUpdateWithoutCommentsInput>, BlogPostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type BlogPostCreateNestedOneWithoutLikesInput = {
    create?: XOR<BlogPostCreateWithoutLikesInput, BlogPostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutLikesInput
    connect?: BlogPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLikesInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    connect?: UserWhereUniqueInput
  }

  export type BlogPostUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<BlogPostCreateWithoutLikesInput, BlogPostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutLikesInput
    upsert?: BlogPostUpsertWithoutLikesInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutLikesInput, BlogPostUpdateWithoutLikesInput>, BlogPostUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    upsert?: UserUpsertWithoutLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikesInput, UserUpdateWithoutLikesInput>, UserUncheckedUpdateWithoutLikesInput>
  }

  export type UserCreateNestedOneWithoutCollaboratorApplicationsInput = {
    create?: XOR<UserCreateWithoutCollaboratorApplicationsInput, UserUncheckedCreateWithoutCollaboratorApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCollaboratorApplicationsInput
    connect?: UserWhereUniqueInput
  }

  export type EvaluationCreateNestedManyWithoutApplicationInput = {
    create?: XOR<EvaluationCreateWithoutApplicationInput, EvaluationUncheckedCreateWithoutApplicationInput> | EvaluationCreateWithoutApplicationInput[] | EvaluationUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutApplicationInput | EvaluationCreateOrConnectWithoutApplicationInput[]
    createMany?: EvaluationCreateManyApplicationInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutApplicationInput = {
    create?: XOR<NoteCreateWithoutApplicationInput, NoteUncheckedCreateWithoutApplicationInput> | NoteCreateWithoutApplicationInput[] | NoteUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutApplicationInput | NoteCreateOrConnectWithoutApplicationInput[]
    createMany?: NoteCreateManyApplicationInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type InterviewCreateNestedManyWithoutApplicationInput = {
    create?: XOR<InterviewCreateWithoutApplicationInput, InterviewUncheckedCreateWithoutApplicationInput> | InterviewCreateWithoutApplicationInput[] | InterviewUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutApplicationInput | InterviewCreateOrConnectWithoutApplicationInput[]
    createMany?: InterviewCreateManyApplicationInputEnvelope
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutReviewedApplicationsInput = {
    create?: XOR<UserCreateWithoutReviewedApplicationsInput, UserUncheckedCreateWithoutReviewedApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedApplicationsInput
    connect?: UserWhereUniqueInput
  }

  export type EvaluationUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<EvaluationCreateWithoutApplicationInput, EvaluationUncheckedCreateWithoutApplicationInput> | EvaluationCreateWithoutApplicationInput[] | EvaluationUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutApplicationInput | EvaluationCreateOrConnectWithoutApplicationInput[]
    createMany?: EvaluationCreateManyApplicationInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<NoteCreateWithoutApplicationInput, NoteUncheckedCreateWithoutApplicationInput> | NoteCreateWithoutApplicationInput[] | NoteUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutApplicationInput | NoteCreateOrConnectWithoutApplicationInput[]
    createMany?: NoteCreateManyApplicationInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type InterviewUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<InterviewCreateWithoutApplicationInput, InterviewUncheckedCreateWithoutApplicationInput> | InterviewCreateWithoutApplicationInput[] | InterviewUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutApplicationInput | InterviewCreateOrConnectWithoutApplicationInput[]
    createMany?: InterviewCreateManyApplicationInputEnvelope
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationStatus
  }

  export type EnumApplicationStageFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationStage
  }

  export type UserUpdateOneRequiredWithoutCollaboratorApplicationsNestedInput = {
    create?: XOR<UserCreateWithoutCollaboratorApplicationsInput, UserUncheckedCreateWithoutCollaboratorApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCollaboratorApplicationsInput
    upsert?: UserUpsertWithoutCollaboratorApplicationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCollaboratorApplicationsInput, UserUpdateWithoutCollaboratorApplicationsInput>, UserUncheckedUpdateWithoutCollaboratorApplicationsInput>
  }

  export type EvaluationUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<EvaluationCreateWithoutApplicationInput, EvaluationUncheckedCreateWithoutApplicationInput> | EvaluationCreateWithoutApplicationInput[] | EvaluationUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutApplicationInput | EvaluationCreateOrConnectWithoutApplicationInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutApplicationInput | EvaluationUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: EvaluationCreateManyApplicationInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutApplicationInput | EvaluationUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutApplicationInput | EvaluationUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<NoteCreateWithoutApplicationInput, NoteUncheckedCreateWithoutApplicationInput> | NoteCreateWithoutApplicationInput[] | NoteUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutApplicationInput | NoteCreateOrConnectWithoutApplicationInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutApplicationInput | NoteUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: NoteCreateManyApplicationInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutApplicationInput | NoteUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutApplicationInput | NoteUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type InterviewUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<InterviewCreateWithoutApplicationInput, InterviewUncheckedCreateWithoutApplicationInput> | InterviewCreateWithoutApplicationInput[] | InterviewUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutApplicationInput | InterviewCreateOrConnectWithoutApplicationInput[]
    upsert?: InterviewUpsertWithWhereUniqueWithoutApplicationInput | InterviewUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: InterviewCreateManyApplicationInputEnvelope
    set?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    disconnect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    delete?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    update?: InterviewUpdateWithWhereUniqueWithoutApplicationInput | InterviewUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: InterviewUpdateManyWithWhereWithoutApplicationInput | InterviewUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: InterviewScalarWhereInput | InterviewScalarWhereInput[]
  }

  export type UserUpdateOneWithoutReviewedApplicationsNestedInput = {
    create?: XOR<UserCreateWithoutReviewedApplicationsInput, UserUncheckedCreateWithoutReviewedApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedApplicationsInput
    upsert?: UserUpsertWithoutReviewedApplicationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewedApplicationsInput, UserUpdateWithoutReviewedApplicationsInput>, UserUncheckedUpdateWithoutReviewedApplicationsInput>
  }

  export type EvaluationUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<EvaluationCreateWithoutApplicationInput, EvaluationUncheckedCreateWithoutApplicationInput> | EvaluationCreateWithoutApplicationInput[] | EvaluationUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutApplicationInput | EvaluationCreateOrConnectWithoutApplicationInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutApplicationInput | EvaluationUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: EvaluationCreateManyApplicationInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutApplicationInput | EvaluationUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutApplicationInput | EvaluationUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<NoteCreateWithoutApplicationInput, NoteUncheckedCreateWithoutApplicationInput> | NoteCreateWithoutApplicationInput[] | NoteUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutApplicationInput | NoteCreateOrConnectWithoutApplicationInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutApplicationInput | NoteUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: NoteCreateManyApplicationInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutApplicationInput | NoteUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutApplicationInput | NoteUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type InterviewUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<InterviewCreateWithoutApplicationInput, InterviewUncheckedCreateWithoutApplicationInput> | InterviewCreateWithoutApplicationInput[] | InterviewUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutApplicationInput | InterviewCreateOrConnectWithoutApplicationInput[]
    upsert?: InterviewUpsertWithWhereUniqueWithoutApplicationInput | InterviewUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: InterviewCreateManyApplicationInputEnvelope
    set?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    disconnect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    delete?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    update?: InterviewUpdateWithWhereUniqueWithoutApplicationInput | InterviewUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: InterviewUpdateManyWithWhereWithoutApplicationInput | InterviewUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: InterviewScalarWhereInput | InterviewScalarWhereInput[]
  }

  export type EnumMessageStatusFieldUpdateOperationsInput = {
    set?: $Enums.MessageStatus
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type EnumLegalTypeFieldUpdateOperationsInput = {
    set?: $Enums.LegalType
  }

  export type MessageTemplateCreatevariablesInput = {
    set: string[]
  }

  export type MessageTemplateUpdatevariablesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CustomPaperCreaterequirementFilesInput = {
    set: string[]
  }

  export type CustomPaperCreatedeliveryFilesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCustomPapersInput = {
    create?: XOR<UserCreateWithoutCustomPapersInput, UserUncheckedCreateWithoutCustomPapersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomPapersInput
    connect?: UserWhereUniqueInput
  }

  export type CustomPaperMessageCreateNestedManyWithoutCustomPaperInput = {
    create?: XOR<CustomPaperMessageCreateWithoutCustomPaperInput, CustomPaperMessageUncheckedCreateWithoutCustomPaperInput> | CustomPaperMessageCreateWithoutCustomPaperInput[] | CustomPaperMessageUncheckedCreateWithoutCustomPaperInput[]
    connectOrCreate?: CustomPaperMessageCreateOrConnectWithoutCustomPaperInput | CustomPaperMessageCreateOrConnectWithoutCustomPaperInput[]
    createMany?: CustomPaperMessageCreateManyCustomPaperInputEnvelope
    connect?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
  }

  export type OrderCreateNestedOneWithoutCustomPaperInput = {
    create?: XOR<OrderCreateWithoutCustomPaperInput, OrderUncheckedCreateWithoutCustomPaperInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCustomPaperInput
    connect?: OrderWhereUniqueInput
  }

  export type CustomPaperMessageUncheckedCreateNestedManyWithoutCustomPaperInput = {
    create?: XOR<CustomPaperMessageCreateWithoutCustomPaperInput, CustomPaperMessageUncheckedCreateWithoutCustomPaperInput> | CustomPaperMessageCreateWithoutCustomPaperInput[] | CustomPaperMessageUncheckedCreateWithoutCustomPaperInput[]
    connectOrCreate?: CustomPaperMessageCreateOrConnectWithoutCustomPaperInput | CustomPaperMessageCreateOrConnectWithoutCustomPaperInput[]
    createMany?: CustomPaperMessageCreateManyCustomPaperInputEnvelope
    connect?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
  }

  export type EnumCustomPaperUrgencyFieldUpdateOperationsInput = {
    set?: $Enums.CustomPaperUrgency
  }

  export type CustomPaperUpdaterequirementFilesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CustomPaperUpdatedeliveryFilesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumCustomPaperStatusFieldUpdateOperationsInput = {
    set?: $Enums.CustomPaperStatus
  }

  export type UserUpdateOneWithoutCustomPapersNestedInput = {
    create?: XOR<UserCreateWithoutCustomPapersInput, UserUncheckedCreateWithoutCustomPapersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomPapersInput
    upsert?: UserUpsertWithoutCustomPapersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomPapersInput, UserUpdateWithoutCustomPapersInput>, UserUncheckedUpdateWithoutCustomPapersInput>
  }

  export type CustomPaperMessageUpdateManyWithoutCustomPaperNestedInput = {
    create?: XOR<CustomPaperMessageCreateWithoutCustomPaperInput, CustomPaperMessageUncheckedCreateWithoutCustomPaperInput> | CustomPaperMessageCreateWithoutCustomPaperInput[] | CustomPaperMessageUncheckedCreateWithoutCustomPaperInput[]
    connectOrCreate?: CustomPaperMessageCreateOrConnectWithoutCustomPaperInput | CustomPaperMessageCreateOrConnectWithoutCustomPaperInput[]
    upsert?: CustomPaperMessageUpsertWithWhereUniqueWithoutCustomPaperInput | CustomPaperMessageUpsertWithWhereUniqueWithoutCustomPaperInput[]
    createMany?: CustomPaperMessageCreateManyCustomPaperInputEnvelope
    set?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
    disconnect?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
    delete?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
    connect?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
    update?: CustomPaperMessageUpdateWithWhereUniqueWithoutCustomPaperInput | CustomPaperMessageUpdateWithWhereUniqueWithoutCustomPaperInput[]
    updateMany?: CustomPaperMessageUpdateManyWithWhereWithoutCustomPaperInput | CustomPaperMessageUpdateManyWithWhereWithoutCustomPaperInput[]
    deleteMany?: CustomPaperMessageScalarWhereInput | CustomPaperMessageScalarWhereInput[]
  }

  export type OrderUpdateOneWithoutCustomPaperNestedInput = {
    create?: XOR<OrderCreateWithoutCustomPaperInput, OrderUncheckedCreateWithoutCustomPaperInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCustomPaperInput
    upsert?: OrderUpsertWithoutCustomPaperInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutCustomPaperInput, OrderUpdateWithoutCustomPaperInput>, OrderUncheckedUpdateWithoutCustomPaperInput>
  }

  export type CustomPaperMessageUncheckedUpdateManyWithoutCustomPaperNestedInput = {
    create?: XOR<CustomPaperMessageCreateWithoutCustomPaperInput, CustomPaperMessageUncheckedCreateWithoutCustomPaperInput> | CustomPaperMessageCreateWithoutCustomPaperInput[] | CustomPaperMessageUncheckedCreateWithoutCustomPaperInput[]
    connectOrCreate?: CustomPaperMessageCreateOrConnectWithoutCustomPaperInput | CustomPaperMessageCreateOrConnectWithoutCustomPaperInput[]
    upsert?: CustomPaperMessageUpsertWithWhereUniqueWithoutCustomPaperInput | CustomPaperMessageUpsertWithWhereUniqueWithoutCustomPaperInput[]
    createMany?: CustomPaperMessageCreateManyCustomPaperInputEnvelope
    set?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
    disconnect?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
    delete?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
    connect?: CustomPaperMessageWhereUniqueInput | CustomPaperMessageWhereUniqueInput[]
    update?: CustomPaperMessageUpdateWithWhereUniqueWithoutCustomPaperInput | CustomPaperMessageUpdateWithWhereUniqueWithoutCustomPaperInput[]
    updateMany?: CustomPaperMessageUpdateManyWithWhereWithoutCustomPaperInput | CustomPaperMessageUpdateManyWithWhereWithoutCustomPaperInput[]
    deleteMany?: CustomPaperMessageScalarWhereInput | CustomPaperMessageScalarWhereInput[]
  }

  export type CustomPaperMessageCreateattachmentsInput = {
    set: string[]
  }

  export type CustomPaperCreateNestedOneWithoutMessagesInput = {
    create?: XOR<CustomPaperCreateWithoutMessagesInput, CustomPaperUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CustomPaperCreateOrConnectWithoutMessagesInput
    connect?: CustomPaperWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCustomPaperMessagesInput = {
    create?: XOR<UserCreateWithoutCustomPaperMessagesInput, UserUncheckedCreateWithoutCustomPaperMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomPaperMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type CustomPaperMessageUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CustomPaperUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<CustomPaperCreateWithoutMessagesInput, CustomPaperUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CustomPaperCreateOrConnectWithoutMessagesInput
    upsert?: CustomPaperUpsertWithoutMessagesInput
    connect?: CustomPaperWhereUniqueInput
    update?: XOR<XOR<CustomPaperUpdateToOneWithWhereWithoutMessagesInput, CustomPaperUpdateWithoutMessagesInput>, CustomPaperUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutCustomPaperMessagesNestedInput = {
    create?: XOR<UserCreateWithoutCustomPaperMessagesInput, UserUncheckedCreateWithoutCustomPaperMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomPaperMessagesInput
    upsert?: UserUpsertWithoutCustomPaperMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomPaperMessagesInput, UserUpdateWithoutCustomPaperMessagesInput>, UserUncheckedUpdateWithoutCustomPaperMessagesInput>
  }

  export type CourseCreateNestedOneWithoutModulesInput = {
    create?: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModulesInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseLessonCreateNestedManyWithoutModuleInput = {
    create?: XOR<CourseLessonCreateWithoutModuleInput, CourseLessonUncheckedCreateWithoutModuleInput> | CourseLessonCreateWithoutModuleInput[] | CourseLessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: CourseLessonCreateOrConnectWithoutModuleInput | CourseLessonCreateOrConnectWithoutModuleInput[]
    createMany?: CourseLessonCreateManyModuleInputEnvelope
    connect?: CourseLessonWhereUniqueInput | CourseLessonWhereUniqueInput[]
  }

  export type CourseLessonUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<CourseLessonCreateWithoutModuleInput, CourseLessonUncheckedCreateWithoutModuleInput> | CourseLessonCreateWithoutModuleInput[] | CourseLessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: CourseLessonCreateOrConnectWithoutModuleInput | CourseLessonCreateOrConnectWithoutModuleInput[]
    createMany?: CourseLessonCreateManyModuleInputEnvelope
    connect?: CourseLessonWhereUniqueInput | CourseLessonWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModulesInput
    upsert?: CourseUpsertWithoutModulesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutModulesInput, CourseUpdateWithoutModulesInput>, CourseUncheckedUpdateWithoutModulesInput>
  }

  export type CourseLessonUpdateManyWithoutModuleNestedInput = {
    create?: XOR<CourseLessonCreateWithoutModuleInput, CourseLessonUncheckedCreateWithoutModuleInput> | CourseLessonCreateWithoutModuleInput[] | CourseLessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: CourseLessonCreateOrConnectWithoutModuleInput | CourseLessonCreateOrConnectWithoutModuleInput[]
    upsert?: CourseLessonUpsertWithWhereUniqueWithoutModuleInput | CourseLessonUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: CourseLessonCreateManyModuleInputEnvelope
    set?: CourseLessonWhereUniqueInput | CourseLessonWhereUniqueInput[]
    disconnect?: CourseLessonWhereUniqueInput | CourseLessonWhereUniqueInput[]
    delete?: CourseLessonWhereUniqueInput | CourseLessonWhereUniqueInput[]
    connect?: CourseLessonWhereUniqueInput | CourseLessonWhereUniqueInput[]
    update?: CourseLessonUpdateWithWhereUniqueWithoutModuleInput | CourseLessonUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: CourseLessonUpdateManyWithWhereWithoutModuleInput | CourseLessonUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: CourseLessonScalarWhereInput | CourseLessonScalarWhereInput[]
  }

  export type CourseLessonUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<CourseLessonCreateWithoutModuleInput, CourseLessonUncheckedCreateWithoutModuleInput> | CourseLessonCreateWithoutModuleInput[] | CourseLessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: CourseLessonCreateOrConnectWithoutModuleInput | CourseLessonCreateOrConnectWithoutModuleInput[]
    upsert?: CourseLessonUpsertWithWhereUniqueWithoutModuleInput | CourseLessonUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: CourseLessonCreateManyModuleInputEnvelope
    set?: CourseLessonWhereUniqueInput | CourseLessonWhereUniqueInput[]
    disconnect?: CourseLessonWhereUniqueInput | CourseLessonWhereUniqueInput[]
    delete?: CourseLessonWhereUniqueInput | CourseLessonWhereUniqueInput[]
    connect?: CourseLessonWhereUniqueInput | CourseLessonWhereUniqueInput[]
    update?: CourseLessonUpdateWithWhereUniqueWithoutModuleInput | CourseLessonUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: CourseLessonUpdateManyWithWhereWithoutModuleInput | CourseLessonUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: CourseLessonScalarWhereInput | CourseLessonScalarWhereInput[]
  }

  export type CourseLessonCreateattachmentsInput = {
    set: string[]
  }

  export type CourseModuleCreateNestedOneWithoutLessonsInput = {
    create?: XOR<CourseModuleCreateWithoutLessonsInput, CourseModuleUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutLessonsInput
    connect?: CourseModuleWhereUniqueInput
  }

  export type CourseProgressCreateNestedManyWithoutLessonInput = {
    create?: XOR<CourseProgressCreateWithoutLessonInput, CourseProgressUncheckedCreateWithoutLessonInput> | CourseProgressCreateWithoutLessonInput[] | CourseProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CourseProgressCreateOrConnectWithoutLessonInput | CourseProgressCreateOrConnectWithoutLessonInput[]
    createMany?: CourseProgressCreateManyLessonInputEnvelope
    connect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
  }

  export type CourseProgressUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<CourseProgressCreateWithoutLessonInput, CourseProgressUncheckedCreateWithoutLessonInput> | CourseProgressCreateWithoutLessonInput[] | CourseProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CourseProgressCreateOrConnectWithoutLessonInput | CourseProgressCreateOrConnectWithoutLessonInput[]
    createMany?: CourseProgressCreateManyLessonInputEnvelope
    connect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
  }

  export type CourseLessonUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourseModuleUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<CourseModuleCreateWithoutLessonsInput, CourseModuleUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutLessonsInput
    upsert?: CourseModuleUpsertWithoutLessonsInput
    connect?: CourseModuleWhereUniqueInput
    update?: XOR<XOR<CourseModuleUpdateToOneWithWhereWithoutLessonsInput, CourseModuleUpdateWithoutLessonsInput>, CourseModuleUncheckedUpdateWithoutLessonsInput>
  }

  export type CourseProgressUpdateManyWithoutLessonNestedInput = {
    create?: XOR<CourseProgressCreateWithoutLessonInput, CourseProgressUncheckedCreateWithoutLessonInput> | CourseProgressCreateWithoutLessonInput[] | CourseProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CourseProgressCreateOrConnectWithoutLessonInput | CourseProgressCreateOrConnectWithoutLessonInput[]
    upsert?: CourseProgressUpsertWithWhereUniqueWithoutLessonInput | CourseProgressUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: CourseProgressCreateManyLessonInputEnvelope
    set?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    disconnect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    delete?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    connect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    update?: CourseProgressUpdateWithWhereUniqueWithoutLessonInput | CourseProgressUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: CourseProgressUpdateManyWithWhereWithoutLessonInput | CourseProgressUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: CourseProgressScalarWhereInput | CourseProgressScalarWhereInput[]
  }

  export type CourseProgressUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<CourseProgressCreateWithoutLessonInput, CourseProgressUncheckedCreateWithoutLessonInput> | CourseProgressCreateWithoutLessonInput[] | CourseProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CourseProgressCreateOrConnectWithoutLessonInput | CourseProgressCreateOrConnectWithoutLessonInput[]
    upsert?: CourseProgressUpsertWithWhereUniqueWithoutLessonInput | CourseProgressUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: CourseProgressCreateManyLessonInputEnvelope
    set?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    disconnect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    delete?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    connect?: CourseProgressWhereUniqueInput | CourseProgressWhereUniqueInput[]
    update?: CourseProgressUpdateWithWhereUniqueWithoutLessonInput | CourseProgressUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: CourseProgressUpdateManyWithWhereWithoutLessonInput | CourseProgressUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: CourseProgressScalarWhereInput | CourseProgressScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCourseProgressInput = {
    create?: XOR<UserCreateWithoutCourseProgressInput, UserUncheckedCreateWithoutCourseProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseProgressInput
    connect?: UserWhereUniqueInput
  }

  export type CourseLessonCreateNestedOneWithoutProgressInput = {
    create?: XOR<CourseLessonCreateWithoutProgressInput, CourseLessonUncheckedCreateWithoutProgressInput>
    connectOrCreate?: CourseLessonCreateOrConnectWithoutProgressInput
    connect?: CourseLessonWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCourseProgressNestedInput = {
    create?: XOR<UserCreateWithoutCourseProgressInput, UserUncheckedCreateWithoutCourseProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseProgressInput
    upsert?: UserUpsertWithoutCourseProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCourseProgressInput, UserUpdateWithoutCourseProgressInput>, UserUncheckedUpdateWithoutCourseProgressInput>
  }

  export type CourseLessonUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<CourseLessonCreateWithoutProgressInput, CourseLessonUncheckedCreateWithoutProgressInput>
    connectOrCreate?: CourseLessonCreateOrConnectWithoutProgressInput
    upsert?: CourseLessonUpsertWithoutProgressInput
    connect?: CourseLessonWhereUniqueInput
    update?: XOR<XOR<CourseLessonUpdateToOneWithWhereWithoutProgressInput, CourseLessonUpdateWithoutProgressInput>, CourseLessonUncheckedUpdateWithoutProgressInput>
  }

  export type UserCreateNestedOneWithoutCourseEnrollmentsInput = {
    create?: XOR<UserCreateWithoutCourseEnrollmentsInput, UserUncheckedCreateWithoutCourseEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseEnrollmentsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCourseEnrollmentsNestedInput = {
    create?: XOR<UserCreateWithoutCourseEnrollmentsInput, UserUncheckedCreateWithoutCourseEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseEnrollmentsInput
    upsert?: UserUpsertWithoutCourseEnrollmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCourseEnrollmentsInput, UserUpdateWithoutCourseEnrollmentsInput>, UserUncheckedUpdateWithoutCourseEnrollmentsInput>
  }

  export type CourseUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    upsert?: CourseUpsertWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutEnrollmentsInput, CourseUpdateWithoutEnrollmentsInput>, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type BlogPostCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<BlogPostCreateWithoutAnalyticsInput, BlogPostUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutAnalyticsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BlogPostUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<BlogPostCreateWithoutAnalyticsInput, BlogPostUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutAnalyticsInput
    upsert?: BlogPostUpsertWithoutAnalyticsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutAnalyticsInput, BlogPostUpdateWithoutAnalyticsInput>, BlogPostUncheckedUpdateWithoutAnalyticsInput>
  }

  export type NewsletterSubscriptionCreateNestedManyWithoutSubscriberInput = {
    create?: XOR<NewsletterSubscriptionCreateWithoutSubscriberInput, NewsletterSubscriptionUncheckedCreateWithoutSubscriberInput> | NewsletterSubscriptionCreateWithoutSubscriberInput[] | NewsletterSubscriptionUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: NewsletterSubscriptionCreateOrConnectWithoutSubscriberInput | NewsletterSubscriptionCreateOrConnectWithoutSubscriberInput[]
    createMany?: NewsletterSubscriptionCreateManySubscriberInputEnvelope
    connect?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
  }

  export type NewsletterSubscriptionUncheckedCreateNestedManyWithoutSubscriberInput = {
    create?: XOR<NewsletterSubscriptionCreateWithoutSubscriberInput, NewsletterSubscriptionUncheckedCreateWithoutSubscriberInput> | NewsletterSubscriptionCreateWithoutSubscriberInput[] | NewsletterSubscriptionUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: NewsletterSubscriptionCreateOrConnectWithoutSubscriberInput | NewsletterSubscriptionCreateOrConnectWithoutSubscriberInput[]
    createMany?: NewsletterSubscriptionCreateManySubscriberInputEnvelope
    connect?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
  }

  export type NewsletterSubscriptionUpdateManyWithoutSubscriberNestedInput = {
    create?: XOR<NewsletterSubscriptionCreateWithoutSubscriberInput, NewsletterSubscriptionUncheckedCreateWithoutSubscriberInput> | NewsletterSubscriptionCreateWithoutSubscriberInput[] | NewsletterSubscriptionUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: NewsletterSubscriptionCreateOrConnectWithoutSubscriberInput | NewsletterSubscriptionCreateOrConnectWithoutSubscriberInput[]
    upsert?: NewsletterSubscriptionUpsertWithWhereUniqueWithoutSubscriberInput | NewsletterSubscriptionUpsertWithWhereUniqueWithoutSubscriberInput[]
    createMany?: NewsletterSubscriptionCreateManySubscriberInputEnvelope
    set?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
    disconnect?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
    delete?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
    connect?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
    update?: NewsletterSubscriptionUpdateWithWhereUniqueWithoutSubscriberInput | NewsletterSubscriptionUpdateWithWhereUniqueWithoutSubscriberInput[]
    updateMany?: NewsletterSubscriptionUpdateManyWithWhereWithoutSubscriberInput | NewsletterSubscriptionUpdateManyWithWhereWithoutSubscriberInput[]
    deleteMany?: NewsletterSubscriptionScalarWhereInput | NewsletterSubscriptionScalarWhereInput[]
  }

  export type NewsletterSubscriptionUncheckedUpdateManyWithoutSubscriberNestedInput = {
    create?: XOR<NewsletterSubscriptionCreateWithoutSubscriberInput, NewsletterSubscriptionUncheckedCreateWithoutSubscriberInput> | NewsletterSubscriptionCreateWithoutSubscriberInput[] | NewsletterSubscriptionUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: NewsletterSubscriptionCreateOrConnectWithoutSubscriberInput | NewsletterSubscriptionCreateOrConnectWithoutSubscriberInput[]
    upsert?: NewsletterSubscriptionUpsertWithWhereUniqueWithoutSubscriberInput | NewsletterSubscriptionUpsertWithWhereUniqueWithoutSubscriberInput[]
    createMany?: NewsletterSubscriptionCreateManySubscriberInputEnvelope
    set?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
    disconnect?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
    delete?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
    connect?: NewsletterSubscriptionWhereUniqueInput | NewsletterSubscriptionWhereUniqueInput[]
    update?: NewsletterSubscriptionUpdateWithWhereUniqueWithoutSubscriberInput | NewsletterSubscriptionUpdateWithWhereUniqueWithoutSubscriberInput[]
    updateMany?: NewsletterSubscriptionUpdateManyWithWhereWithoutSubscriberInput | NewsletterSubscriptionUpdateManyWithWhereWithoutSubscriberInput[]
    deleteMany?: NewsletterSubscriptionScalarWhereInput | NewsletterSubscriptionScalarWhereInput[]
  }

  export type NewsletterSubscriberCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<NewsletterSubscriberCreateWithoutSubscriptionsInput, NewsletterSubscriberUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: NewsletterSubscriberCreateOrConnectWithoutSubscriptionsInput
    connect?: NewsletterSubscriberWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutSubscribersInput = {
    create?: XOR<CategoryCreateWithoutSubscribersInput, CategoryUncheckedCreateWithoutSubscribersInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubscribersInput
    connect?: CategoryWhereUniqueInput
  }

  export type NewsletterSubscriberUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<NewsletterSubscriberCreateWithoutSubscriptionsInput, NewsletterSubscriberUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: NewsletterSubscriberCreateOrConnectWithoutSubscriptionsInput
    upsert?: NewsletterSubscriberUpsertWithoutSubscriptionsInput
    connect?: NewsletterSubscriberWhereUniqueInput
    update?: XOR<XOR<NewsletterSubscriberUpdateToOneWithWhereWithoutSubscriptionsInput, NewsletterSubscriberUpdateWithoutSubscriptionsInput>, NewsletterSubscriberUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type CategoryUpdateOneRequiredWithoutSubscribersNestedInput = {
    create?: XOR<CategoryCreateWithoutSubscribersInput, CategoryUncheckedCreateWithoutSubscribersInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubscribersInput
    upsert?: CategoryUpsertWithoutSubscribersInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutSubscribersInput, CategoryUpdateWithoutSubscribersInput>, CategoryUncheckedUpdateWithoutSubscribersInput>
  }

  export type BlogPostCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<BlogPostCreateWithoutNotificationsInput, BlogPostUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutNotificationsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type BlogPostUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<BlogPostCreateWithoutNotificationsInput, BlogPostUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutNotificationsInput
    upsert?: BlogPostUpsertWithoutNotificationsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutNotificationsInput, BlogPostUpdateWithoutNotificationsInput>, BlogPostUncheckedUpdateWithoutNotificationsInput>
  }

  export type CollaboratorApplicationCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<CollaboratorApplicationCreateWithoutEvaluationsInput, CollaboratorApplicationUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: CollaboratorApplicationCreateOrConnectWithoutEvaluationsInput
    connect?: CollaboratorApplicationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<UserCreateWithoutEvaluationsInput, UserUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvaluationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumEvaluationRecommendationFieldUpdateOperationsInput = {
    set?: $Enums.EvaluationRecommendation
  }

  export type CollaboratorApplicationUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<CollaboratorApplicationCreateWithoutEvaluationsInput, CollaboratorApplicationUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: CollaboratorApplicationCreateOrConnectWithoutEvaluationsInput
    upsert?: CollaboratorApplicationUpsertWithoutEvaluationsInput
    connect?: CollaboratorApplicationWhereUniqueInput
    update?: XOR<XOR<CollaboratorApplicationUpdateToOneWithWhereWithoutEvaluationsInput, CollaboratorApplicationUpdateWithoutEvaluationsInput>, CollaboratorApplicationUncheckedUpdateWithoutEvaluationsInput>
  }

  export type UserUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<UserCreateWithoutEvaluationsInput, UserUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvaluationsInput
    upsert?: UserUpsertWithoutEvaluationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEvaluationsInput, UserUpdateWithoutEvaluationsInput>, UserUncheckedUpdateWithoutEvaluationsInput>
  }

  export type CollaboratorApplicationCreateNestedOneWithoutNotesInput = {
    create?: XOR<CollaboratorApplicationCreateWithoutNotesInput, CollaboratorApplicationUncheckedCreateWithoutNotesInput>
    connectOrCreate?: CollaboratorApplicationCreateOrConnectWithoutNotesInput
    connect?: CollaboratorApplicationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotesInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    connect?: UserWhereUniqueInput
  }

  export type CollaboratorApplicationUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<CollaboratorApplicationCreateWithoutNotesInput, CollaboratorApplicationUncheckedCreateWithoutNotesInput>
    connectOrCreate?: CollaboratorApplicationCreateOrConnectWithoutNotesInput
    upsert?: CollaboratorApplicationUpsertWithoutNotesInput
    connect?: CollaboratorApplicationWhereUniqueInput
    update?: XOR<XOR<CollaboratorApplicationUpdateToOneWithWhereWithoutNotesInput, CollaboratorApplicationUpdateWithoutNotesInput>, CollaboratorApplicationUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    upsert?: UserUpsertWithoutNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotesInput, UserUpdateWithoutNotesInput>, UserUncheckedUpdateWithoutNotesInput>
  }

  export type CollaboratorApplicationCreateNestedOneWithoutInterviewsInput = {
    create?: XOR<CollaboratorApplicationCreateWithoutInterviewsInput, CollaboratorApplicationUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: CollaboratorApplicationCreateOrConnectWithoutInterviewsInput
    connect?: CollaboratorApplicationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInterviewsInput = {
    create?: XOR<UserCreateWithoutInterviewsInput, UserUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterviewsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInterviewTypeFieldUpdateOperationsInput = {
    set?: $Enums.InterviewType
  }

  export type EnumInterviewStatusFieldUpdateOperationsInput = {
    set?: $Enums.InterviewStatus
  }

  export type NullableEnumInterviewResultFieldUpdateOperationsInput = {
    set?: $Enums.InterviewResult | null
  }

  export type CollaboratorApplicationUpdateOneRequiredWithoutInterviewsNestedInput = {
    create?: XOR<CollaboratorApplicationCreateWithoutInterviewsInput, CollaboratorApplicationUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: CollaboratorApplicationCreateOrConnectWithoutInterviewsInput
    upsert?: CollaboratorApplicationUpsertWithoutInterviewsInput
    connect?: CollaboratorApplicationWhereUniqueInput
    update?: XOR<XOR<CollaboratorApplicationUpdateToOneWithWhereWithoutInterviewsInput, CollaboratorApplicationUpdateWithoutInterviewsInput>, CollaboratorApplicationUncheckedUpdateWithoutInterviewsInput>
  }

  export type UserUpdateOneRequiredWithoutInterviewsNestedInput = {
    create?: XOR<UserCreateWithoutInterviewsInput, UserUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterviewsInput
    upsert?: UserUpsertWithoutInterviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInterviewsInput, UserUpdateWithoutInterviewsInput>, UserUncheckedUpdateWithoutInterviewsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaperTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaperType | EnumPaperTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaperType[] | ListEnumPaperTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaperType[] | ListEnumPaperTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaperTypeFilter<$PrismaModel> | $Enums.PaperType
  }

  export type NestedEnumAcademicAreaFilter<$PrismaModel = never> = {
    equals?: $Enums.AcademicArea | EnumAcademicAreaFieldRefInput<$PrismaModel>
    in?: $Enums.AcademicArea[] | ListEnumAcademicAreaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AcademicArea[] | ListEnumAcademicAreaFieldRefInput<$PrismaModel>
    not?: NestedEnumAcademicAreaFilter<$PrismaModel> | $Enums.AcademicArea
  }

  export type NestedEnumPaperTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaperType | EnumPaperTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaperType[] | ListEnumPaperTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaperType[] | ListEnumPaperTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaperTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaperType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaperTypeFilter<$PrismaModel>
    _max?: NestedEnumPaperTypeFilter<$PrismaModel>
  }

  export type NestedEnumAcademicAreaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AcademicArea | EnumAcademicAreaFieldRefInput<$PrismaModel>
    in?: $Enums.AcademicArea[] | ListEnumAcademicAreaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AcademicArea[] | ListEnumAcademicAreaFieldRefInput<$PrismaModel>
    not?: NestedEnumAcademicAreaWithAggregatesFilter<$PrismaModel> | $Enums.AcademicArea
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAcademicAreaFilter<$PrismaModel>
    _max?: NestedEnumAcademicAreaFilter<$PrismaModel>
  }

  export type NestedEnumCourseLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevel | EnumCourseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelFilter<$PrismaModel> | $Enums.CourseLevel
  }

  export type NestedEnumCourseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusFilter<$PrismaModel> | $Enums.CourseStatus
  }

  export type NestedEnumCourseLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevel | EnumCourseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelWithAggregatesFilter<$PrismaModel> | $Enums.CourseLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseLevelFilter<$PrismaModel>
    _max?: NestedEnumCourseLevelFilter<$PrismaModel>
  }

  export type NestedEnumCourseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CourseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseStatusFilter<$PrismaModel>
    _max?: NestedEnumCourseStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLibraryItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LibraryItemType | EnumLibraryItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LibraryItemType[] | ListEnumLibraryItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LibraryItemType[] | ListEnumLibraryItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLibraryItemTypeFilter<$PrismaModel> | $Enums.LibraryItemType
  }

  export type NestedEnumLibraryItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LibraryItemType | EnumLibraryItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LibraryItemType[] | ListEnumLibraryItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LibraryItemType[] | ListEnumLibraryItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLibraryItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.LibraryItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLibraryItemTypeFilter<$PrismaModel>
    _max?: NestedEnumLibraryItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type NestedEnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type NestedEnumApplicationStageFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStage | EnumApplicationStageFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStage[] | ListEnumApplicationStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStage[] | ListEnumApplicationStageFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStageFilter<$PrismaModel> | $Enums.ApplicationStage
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStage | EnumApplicationStageFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStage[] | ListEnumApplicationStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStage[] | ListEnumApplicationStageFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStageWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStageFilter<$PrismaModel>
    _max?: NestedEnumApplicationStageFilter<$PrismaModel>
  }

  export type NestedEnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumLegalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LegalType | EnumLegalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LegalType[] | ListEnumLegalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LegalType[] | ListEnumLegalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLegalTypeFilter<$PrismaModel> | $Enums.LegalType
  }

  export type NestedEnumLegalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LegalType | EnumLegalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LegalType[] | ListEnumLegalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LegalType[] | ListEnumLegalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLegalTypeWithAggregatesFilter<$PrismaModel> | $Enums.LegalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLegalTypeFilter<$PrismaModel>
    _max?: NestedEnumLegalTypeFilter<$PrismaModel>
  }

  export type NestedEnumCustomPaperUrgencyFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomPaperUrgency | EnumCustomPaperUrgencyFieldRefInput<$PrismaModel>
    in?: $Enums.CustomPaperUrgency[] | ListEnumCustomPaperUrgencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomPaperUrgency[] | ListEnumCustomPaperUrgencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomPaperUrgencyFilter<$PrismaModel> | $Enums.CustomPaperUrgency
  }

  export type NestedEnumCustomPaperStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomPaperStatus | EnumCustomPaperStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CustomPaperStatus[] | ListEnumCustomPaperStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomPaperStatus[] | ListEnumCustomPaperStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomPaperStatusFilter<$PrismaModel> | $Enums.CustomPaperStatus
  }

  export type NestedEnumCustomPaperUrgencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomPaperUrgency | EnumCustomPaperUrgencyFieldRefInput<$PrismaModel>
    in?: $Enums.CustomPaperUrgency[] | ListEnumCustomPaperUrgencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomPaperUrgency[] | ListEnumCustomPaperUrgencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomPaperUrgencyWithAggregatesFilter<$PrismaModel> | $Enums.CustomPaperUrgency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomPaperUrgencyFilter<$PrismaModel>
    _max?: NestedEnumCustomPaperUrgencyFilter<$PrismaModel>
  }

  export type NestedEnumCustomPaperStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomPaperStatus | EnumCustomPaperStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CustomPaperStatus[] | ListEnumCustomPaperStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomPaperStatus[] | ListEnumCustomPaperStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomPaperStatusWithAggregatesFilter<$PrismaModel> | $Enums.CustomPaperStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomPaperStatusFilter<$PrismaModel>
    _max?: NestedEnumCustomPaperStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumEvaluationRecommendationFilter<$PrismaModel = never> = {
    equals?: $Enums.EvaluationRecommendation | EnumEvaluationRecommendationFieldRefInput<$PrismaModel>
    in?: $Enums.EvaluationRecommendation[] | ListEnumEvaluationRecommendationFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvaluationRecommendation[] | ListEnumEvaluationRecommendationFieldRefInput<$PrismaModel>
    not?: NestedEnumEvaluationRecommendationFilter<$PrismaModel> | $Enums.EvaluationRecommendation
  }

  export type NestedEnumEvaluationRecommendationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvaluationRecommendation | EnumEvaluationRecommendationFieldRefInput<$PrismaModel>
    in?: $Enums.EvaluationRecommendation[] | ListEnumEvaluationRecommendationFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvaluationRecommendation[] | ListEnumEvaluationRecommendationFieldRefInput<$PrismaModel>
    not?: NestedEnumEvaluationRecommendationWithAggregatesFilter<$PrismaModel> | $Enums.EvaluationRecommendation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvaluationRecommendationFilter<$PrismaModel>
    _max?: NestedEnumEvaluationRecommendationFilter<$PrismaModel>
  }

  export type NestedEnumInterviewTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewType | EnumInterviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewType[] | ListEnumInterviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterviewType[] | ListEnumInterviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInterviewTypeFilter<$PrismaModel> | $Enums.InterviewType
  }

  export type NestedEnumInterviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewStatus | EnumInterviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewStatus[] | ListEnumInterviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterviewStatus[] | ListEnumInterviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterviewStatusFilter<$PrismaModel> | $Enums.InterviewStatus
  }

  export type NestedEnumInterviewResultNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewResult | EnumInterviewResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.InterviewResult[] | ListEnumInterviewResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InterviewResult[] | ListEnumInterviewResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInterviewResultNullableFilter<$PrismaModel> | $Enums.InterviewResult | null
  }

  export type NestedEnumInterviewTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewType | EnumInterviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewType[] | ListEnumInterviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterviewType[] | ListEnumInterviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInterviewTypeWithAggregatesFilter<$PrismaModel> | $Enums.InterviewType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterviewTypeFilter<$PrismaModel>
    _max?: NestedEnumInterviewTypeFilter<$PrismaModel>
  }

  export type NestedEnumInterviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewStatus | EnumInterviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewStatus[] | ListEnumInterviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterviewStatus[] | ListEnumInterviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.InterviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterviewStatusFilter<$PrismaModel>
    _max?: NestedEnumInterviewStatusFilter<$PrismaModel>
  }

  export type NestedEnumInterviewResultNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewResult | EnumInterviewResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.InterviewResult[] | ListEnumInterviewResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InterviewResult[] | ListEnumInterviewResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInterviewResultNullableWithAggregatesFilter<$PrismaModel> | $Enums.InterviewResult | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInterviewResultNullableFilter<$PrismaModel>
    _max?: NestedEnumInterviewResultNullableFilter<$PrismaModel>
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    totalAmount: number
    status?: $Enums.OrderStatus
    paymentMethod?: $Enums.PaymentMethod | null
    paymentStatus?: $Enums.PaymentStatus
    customerName: string
    customerEmail: string
    customerCpfCnpj: string
    customerPhone?: string | null
    pixCode?: string | null
    boletoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
    customPaper?: CustomPaperCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    totalAmount: number
    status?: $Enums.OrderStatus
    paymentMethod?: $Enums.PaymentMethod | null
    paymentStatus?: $Enums.PaymentStatus
    customerName: string
    customerEmail: string
    customerCpfCnpj: string
    customerPhone?: string | null
    pixCode?: string | null
    boletoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    customPaper?: CustomPaperUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CollaboratorApplicationCreateWithoutUserInput = {
    id?: string
    fullName: string
    email: string
    phone: string
    cpf?: string | null
    birthDate?: Date | string | null
    zipCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    area: string
    education?: string | null
    experience: string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability: string
    expectedSalary?: number | null
    resumeUrl?: string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: string | null
    github?: string | null
    status?: $Enums.ApplicationStatus
    stage?: $Enums.ApplicationStage
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    evaluations?: EvaluationCreateNestedManyWithoutApplicationInput
    notes?: NoteCreateNestedManyWithoutApplicationInput
    interviews?: InterviewCreateNestedManyWithoutApplicationInput
    reviewer?: UserCreateNestedOneWithoutReviewedApplicationsInput
  }

  export type CollaboratorApplicationUncheckedCreateWithoutUserInput = {
    id?: string
    fullName: string
    email: string
    phone: string
    cpf?: string | null
    birthDate?: Date | string | null
    zipCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    area: string
    education?: string | null
    experience: string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability: string
    expectedSalary?: number | null
    resumeUrl?: string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: string | null
    github?: string | null
    status?: $Enums.ApplicationStatus
    stage?: $Enums.ApplicationStage
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    reviewerId?: string | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutApplicationInput
    notes?: NoteUncheckedCreateNestedManyWithoutApplicationInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type CollaboratorApplicationCreateOrConnectWithoutUserInput = {
    where: CollaboratorApplicationWhereUniqueInput
    create: XOR<CollaboratorApplicationCreateWithoutUserInput, CollaboratorApplicationUncheckedCreateWithoutUserInput>
  }

  export type CollaboratorApplicationCreateManyUserInputEnvelope = {
    data: CollaboratorApplicationCreateManyUserInput | CollaboratorApplicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CollaboratorApplicationCreateWithoutReviewerInput = {
    id?: string
    fullName: string
    email: string
    phone: string
    cpf?: string | null
    birthDate?: Date | string | null
    zipCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    area: string
    education?: string | null
    experience: string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability: string
    expectedSalary?: number | null
    resumeUrl?: string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: string | null
    github?: string | null
    status?: $Enums.ApplicationStatus
    stage?: $Enums.ApplicationStage
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    user: UserCreateNestedOneWithoutCollaboratorApplicationsInput
    evaluations?: EvaluationCreateNestedManyWithoutApplicationInput
    notes?: NoteCreateNestedManyWithoutApplicationInput
    interviews?: InterviewCreateNestedManyWithoutApplicationInput
  }

  export type CollaboratorApplicationUncheckedCreateWithoutReviewerInput = {
    id?: string
    userId: string
    fullName: string
    email: string
    phone: string
    cpf?: string | null
    birthDate?: Date | string | null
    zipCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    area: string
    education?: string | null
    experience: string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability: string
    expectedSalary?: number | null
    resumeUrl?: string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: string | null
    github?: string | null
    status?: $Enums.ApplicationStatus
    stage?: $Enums.ApplicationStage
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutApplicationInput
    notes?: NoteUncheckedCreateNestedManyWithoutApplicationInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type CollaboratorApplicationCreateOrConnectWithoutReviewerInput = {
    where: CollaboratorApplicationWhereUniqueInput
    create: XOR<CollaboratorApplicationCreateWithoutReviewerInput, CollaboratorApplicationUncheckedCreateWithoutReviewerInput>
  }

  export type CollaboratorApplicationCreateManyReviewerInputEnvelope = {
    data: CollaboratorApplicationCreateManyReviewerInput | CollaboratorApplicationCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationCreateWithoutEvaluatorInput = {
    id?: string
    experienceScore: number
    skillsScore: number
    educationScore: number
    culturalFitScore: number
    totalScore: number
    recommendation: $Enums.EvaluationRecommendation
    comments: string
    createdAt?: Date | string
    application: CollaboratorApplicationCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutEvaluatorInput = {
    id?: string
    applicationId: string
    experienceScore: number
    skillsScore: number
    educationScore: number
    culturalFitScore: number
    totalScore: number
    recommendation: $Enums.EvaluationRecommendation
    comments: string
    createdAt?: Date | string
  }

  export type EvaluationCreateOrConnectWithoutEvaluatorInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput>
  }

  export type EvaluationCreateManyEvaluatorInputEnvelope = {
    data: EvaluationCreateManyEvaluatorInput | EvaluationCreateManyEvaluatorInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutAuthorInput = {
    id?: string
    content: string
    isPrivate?: boolean
    createdAt?: Date | string
    application: CollaboratorApplicationCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutAuthorInput = {
    id?: string
    applicationId: string
    content: string
    isPrivate?: boolean
    createdAt?: Date | string
  }

  export type NoteCreateOrConnectWithoutAuthorInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput>
  }

  export type NoteCreateManyAuthorInputEnvelope = {
    data: NoteCreateManyAuthorInput | NoteCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type InterviewCreateWithoutInterviewerInput = {
    id?: string
    scheduledAt: Date | string
    duration: number
    type: $Enums.InterviewType
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.InterviewStatus
    feedback?: string | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
    application: CollaboratorApplicationCreateNestedOneWithoutInterviewsInput
  }

  export type InterviewUncheckedCreateWithoutInterviewerInput = {
    id?: string
    applicationId: string
    scheduledAt: Date | string
    duration: number
    type: $Enums.InterviewType
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.InterviewStatus
    feedback?: string | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewCreateOrConnectWithoutInterviewerInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutInterviewerInput, InterviewUncheckedCreateWithoutInterviewerInput>
  }

  export type InterviewCreateManyInterviewerInputEnvelope = {
    data: InterviewCreateManyInterviewerInput | InterviewCreateManyInterviewerInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutUserInput = {
    id?: string
    certificateNumber: string
    grade: number
    completionDate: Date | string
    qrCodeUrl: string
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutUserInput = {
    id?: string
    courseId: string
    certificateNumber: string
    grade: number
    completionDate: Date | string
    qrCodeUrl: string
    createdAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutUserInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput>
  }

  export type CertificateCreateManyUserInputEnvelope = {
    data: CertificateCreateManyUserInput | CertificateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LibraryCreateWithoutUserInput = {
    id?: string
    itemType: $Enums.LibraryItemType
    itemId: string
    downloadUrl: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LibraryUncheckedCreateWithoutUserInput = {
    id?: string
    itemType: $Enums.LibraryItemType
    itemId: string
    downloadUrl: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LibraryCreateOrConnectWithoutUserInput = {
    where: LibraryWhereUniqueInput
    create: XOR<LibraryCreateWithoutUserInput, LibraryUncheckedCreateWithoutUserInput>
  }

  export type LibraryCreateManyUserInputEnvelope = {
    data: LibraryCreateManyUserInput | LibraryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CustomPaperCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    pageCount: number
    deadline: Date | string
    urgency: $Enums.CustomPaperUrgency
    requirements: string
    keywords?: string | null
    references?: string | null
    requirementFiles?: CustomPaperCreaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperCreatedeliveryFilesInput | string[]
    quotedPrice?: number | null
    finalPrice?: number | null
    paymentStatus?: $Enums.PaymentStatus
    status?: $Enums.CustomPaperStatus
    adminNotes?: string | null
    rejectionReason?: string | null
    requestedAt?: Date | string
    quotedAt?: Date | string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    messages?: CustomPaperMessageCreateNestedManyWithoutCustomPaperInput
    order?: OrderCreateNestedOneWithoutCustomPaperInput
  }

  export type CustomPaperUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    pageCount: number
    deadline: Date | string
    urgency: $Enums.CustomPaperUrgency
    requirements: string
    keywords?: string | null
    references?: string | null
    requirementFiles?: CustomPaperCreaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperCreatedeliveryFilesInput | string[]
    quotedPrice?: number | null
    finalPrice?: number | null
    paymentStatus?: $Enums.PaymentStatus
    status?: $Enums.CustomPaperStatus
    adminNotes?: string | null
    rejectionReason?: string | null
    requestedAt?: Date | string
    quotedAt?: Date | string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    orderId?: string | null
    messages?: CustomPaperMessageUncheckedCreateNestedManyWithoutCustomPaperInput
  }

  export type CustomPaperCreateOrConnectWithoutUserInput = {
    where: CustomPaperWhereUniqueInput
    create: XOR<CustomPaperCreateWithoutUserInput, CustomPaperUncheckedCreateWithoutUserInput>
  }

  export type CustomPaperCreateManyUserInputEnvelope = {
    data: CustomPaperCreateManyUserInput | CustomPaperCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CustomPaperMessageCreateWithoutSenderInput = {
    id?: string
    content: string
    attachments?: CustomPaperMessageCreateattachmentsInput | string[]
    isFromAdmin: boolean
    isRead?: boolean
    createdAt?: Date | string
    customPaper: CustomPaperCreateNestedOneWithoutMessagesInput
  }

  export type CustomPaperMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    customPaperId: string
    content: string
    attachments?: CustomPaperMessageCreateattachmentsInput | string[]
    isFromAdmin: boolean
    isRead?: boolean
    createdAt?: Date | string
  }

  export type CustomPaperMessageCreateOrConnectWithoutSenderInput = {
    where: CustomPaperMessageWhereUniqueInput
    create: XOR<CustomPaperMessageCreateWithoutSenderInput, CustomPaperMessageUncheckedCreateWithoutSenderInput>
  }

  export type CustomPaperMessageCreateManySenderInputEnvelope = {
    data: CustomPaperMessageCreateManySenderInput | CustomPaperMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type CourseProgressCreateWithoutUserInput = {
    id?: string
    completed?: boolean
    watchTime?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lesson: CourseLessonCreateNestedOneWithoutProgressInput
  }

  export type CourseProgressUncheckedCreateWithoutUserInput = {
    id?: string
    lessonId: string
    completed?: boolean
    watchTime?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseProgressCreateOrConnectWithoutUserInput = {
    where: CourseProgressWhereUniqueInput
    create: XOR<CourseProgressCreateWithoutUserInput, CourseProgressUncheckedCreateWithoutUserInput>
  }

  export type CourseProgressCreateManyUserInputEnvelope = {
    data: CourseProgressCreateManyUserInput | CourseProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseEnrollmentCreateWithoutUserInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    course: CourseCreateNestedOneWithoutEnrollmentsInput
  }

  export type CourseEnrollmentUncheckedCreateWithoutUserInput = {
    id?: string
    courseId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
  }

  export type CourseEnrollmentCreateOrConnectWithoutUserInput = {
    where: CourseEnrollmentWhereUniqueInput
    create: XOR<CourseEnrollmentCreateWithoutUserInput, CourseEnrollmentUncheckedCreateWithoutUserInput>
  }

  export type CourseEnrollmentCreateManyUserInputEnvelope = {
    data: CourseEnrollmentCreateManyUserInput | CourseEnrollmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: BlogTagCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: LikeCreateNestedManyWithoutPostInput
    analytics?: PostAnalyticsCreateNestedManyWithoutPostInput
    notifications?: PostNotificationCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    categoryId?: string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: BlogTagUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    analytics?: PostAnalyticsUncheckedCreateNestedManyWithoutPostInput
    notifications?: PostNotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostCreateManyAuthorInputEnvelope = {
    data: BlogPostCreateManyAuthorInput | BlogPostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    content: string
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post: BlogPostCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    postId: string
    parentId?: string | null
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    post: BlogPostCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutUserInput = {
    id?: string
    postId: string
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutUserInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput>
  }

  export type LikeCreateManyUserInputEnvelope = {
    data: LikeCreateManyUserInput | LikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringNullableFilter<"Order"> | string | null
    totalAmount?: IntFilter<"Order"> | number
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    paymentMethod?: EnumPaymentMethodNullableFilter<"Order"> | $Enums.PaymentMethod | null
    paymentStatus?: EnumPaymentStatusFilter<"Order"> | $Enums.PaymentStatus
    customerName?: StringFilter<"Order"> | string
    customerEmail?: StringFilter<"Order"> | string
    customerCpfCnpj?: StringFilter<"Order"> | string
    customerPhone?: StringNullableFilter<"Order"> | string | null
    pixCode?: StringNullableFilter<"Order"> | string | null
    boletoUrl?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type CollaboratorApplicationUpsertWithWhereUniqueWithoutUserInput = {
    where: CollaboratorApplicationWhereUniqueInput
    update: XOR<CollaboratorApplicationUpdateWithoutUserInput, CollaboratorApplicationUncheckedUpdateWithoutUserInput>
    create: XOR<CollaboratorApplicationCreateWithoutUserInput, CollaboratorApplicationUncheckedCreateWithoutUserInput>
  }

  export type CollaboratorApplicationUpdateWithWhereUniqueWithoutUserInput = {
    where: CollaboratorApplicationWhereUniqueInput
    data: XOR<CollaboratorApplicationUpdateWithoutUserInput, CollaboratorApplicationUncheckedUpdateWithoutUserInput>
  }

  export type CollaboratorApplicationUpdateManyWithWhereWithoutUserInput = {
    where: CollaboratorApplicationScalarWhereInput
    data: XOR<CollaboratorApplicationUpdateManyMutationInput, CollaboratorApplicationUncheckedUpdateManyWithoutUserInput>
  }

  export type CollaboratorApplicationScalarWhereInput = {
    AND?: CollaboratorApplicationScalarWhereInput | CollaboratorApplicationScalarWhereInput[]
    OR?: CollaboratorApplicationScalarWhereInput[]
    NOT?: CollaboratorApplicationScalarWhereInput | CollaboratorApplicationScalarWhereInput[]
    id?: StringFilter<"CollaboratorApplication"> | string
    userId?: StringFilter<"CollaboratorApplication"> | string
    fullName?: StringFilter<"CollaboratorApplication"> | string
    email?: StringFilter<"CollaboratorApplication"> | string
    phone?: StringFilter<"CollaboratorApplication"> | string
    cpf?: StringNullableFilter<"CollaboratorApplication"> | string | null
    birthDate?: DateTimeNullableFilter<"CollaboratorApplication"> | Date | string | null
    zipCode?: StringNullableFilter<"CollaboratorApplication"> | string | null
    address?: StringNullableFilter<"CollaboratorApplication"> | string | null
    city?: StringNullableFilter<"CollaboratorApplication"> | string | null
    state?: StringNullableFilter<"CollaboratorApplication"> | string | null
    area?: StringFilter<"CollaboratorApplication"> | string
    education?: StringNullableFilter<"CollaboratorApplication"> | string | null
    experience?: StringFilter<"CollaboratorApplication"> | string
    skills?: JsonNullableFilter<"CollaboratorApplication">
    availability?: StringFilter<"CollaboratorApplication"> | string
    expectedSalary?: FloatNullableFilter<"CollaboratorApplication"> | number | null
    resumeUrl?: StringNullableFilter<"CollaboratorApplication"> | string | null
    portfolioUrls?: JsonNullableFilter<"CollaboratorApplication">
    linkedin?: StringNullableFilter<"CollaboratorApplication"> | string | null
    github?: StringNullableFilter<"CollaboratorApplication"> | string | null
    status?: EnumApplicationStatusFilter<"CollaboratorApplication"> | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFilter<"CollaboratorApplication"> | $Enums.ApplicationStage
    score?: IntNullableFilter<"CollaboratorApplication"> | number | null
    createdAt?: DateTimeFilter<"CollaboratorApplication"> | Date | string
    updatedAt?: DateTimeFilter<"CollaboratorApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"CollaboratorApplication"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"CollaboratorApplication"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"CollaboratorApplication"> | Date | string | null
    reviewerId?: StringNullableFilter<"CollaboratorApplication"> | string | null
  }

  export type CollaboratorApplicationUpsertWithWhereUniqueWithoutReviewerInput = {
    where: CollaboratorApplicationWhereUniqueInput
    update: XOR<CollaboratorApplicationUpdateWithoutReviewerInput, CollaboratorApplicationUncheckedUpdateWithoutReviewerInput>
    create: XOR<CollaboratorApplicationCreateWithoutReviewerInput, CollaboratorApplicationUncheckedCreateWithoutReviewerInput>
  }

  export type CollaboratorApplicationUpdateWithWhereUniqueWithoutReviewerInput = {
    where: CollaboratorApplicationWhereUniqueInput
    data: XOR<CollaboratorApplicationUpdateWithoutReviewerInput, CollaboratorApplicationUncheckedUpdateWithoutReviewerInput>
  }

  export type CollaboratorApplicationUpdateManyWithWhereWithoutReviewerInput = {
    where: CollaboratorApplicationScalarWhereInput
    data: XOR<CollaboratorApplicationUpdateManyMutationInput, CollaboratorApplicationUncheckedUpdateManyWithoutReviewerInput>
  }

  export type EvaluationUpsertWithWhereUniqueWithoutEvaluatorInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutEvaluatorInput, EvaluationUncheckedUpdateWithoutEvaluatorInput>
    create: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutEvaluatorInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutEvaluatorInput, EvaluationUncheckedUpdateWithoutEvaluatorInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutEvaluatorInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutEvaluatorInput>
  }

  export type EvaluationScalarWhereInput = {
    AND?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
    OR?: EvaluationScalarWhereInput[]
    NOT?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
    id?: StringFilter<"Evaluation"> | string
    applicationId?: StringFilter<"Evaluation"> | string
    evaluatorId?: StringFilter<"Evaluation"> | string
    experienceScore?: IntFilter<"Evaluation"> | number
    skillsScore?: IntFilter<"Evaluation"> | number
    educationScore?: IntFilter<"Evaluation"> | number
    culturalFitScore?: IntFilter<"Evaluation"> | number
    totalScore?: IntFilter<"Evaluation"> | number
    recommendation?: EnumEvaluationRecommendationFilter<"Evaluation"> | $Enums.EvaluationRecommendation
    comments?: StringFilter<"Evaluation"> | string
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
  }

  export type NoteUpsertWithWhereUniqueWithoutAuthorInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutAuthorInput, NoteUncheckedUpdateWithoutAuthorInput>
    create: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutAuthorInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutAuthorInput, NoteUncheckedUpdateWithoutAuthorInput>
  }

  export type NoteUpdateManyWithWhereWithoutAuthorInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutAuthorInput>
  }

  export type NoteScalarWhereInput = {
    AND?: NoteScalarWhereInput | NoteScalarWhereInput[]
    OR?: NoteScalarWhereInput[]
    NOT?: NoteScalarWhereInput | NoteScalarWhereInput[]
    id?: StringFilter<"Note"> | string
    applicationId?: StringFilter<"Note"> | string
    authorId?: StringFilter<"Note"> | string
    content?: StringFilter<"Note"> | string
    isPrivate?: BoolFilter<"Note"> | boolean
    createdAt?: DateTimeFilter<"Note"> | Date | string
  }

  export type InterviewUpsertWithWhereUniqueWithoutInterviewerInput = {
    where: InterviewWhereUniqueInput
    update: XOR<InterviewUpdateWithoutInterviewerInput, InterviewUncheckedUpdateWithoutInterviewerInput>
    create: XOR<InterviewCreateWithoutInterviewerInput, InterviewUncheckedCreateWithoutInterviewerInput>
  }

  export type InterviewUpdateWithWhereUniqueWithoutInterviewerInput = {
    where: InterviewWhereUniqueInput
    data: XOR<InterviewUpdateWithoutInterviewerInput, InterviewUncheckedUpdateWithoutInterviewerInput>
  }

  export type InterviewUpdateManyWithWhereWithoutInterviewerInput = {
    where: InterviewScalarWhereInput
    data: XOR<InterviewUpdateManyMutationInput, InterviewUncheckedUpdateManyWithoutInterviewerInput>
  }

  export type InterviewScalarWhereInput = {
    AND?: InterviewScalarWhereInput | InterviewScalarWhereInput[]
    OR?: InterviewScalarWhereInput[]
    NOT?: InterviewScalarWhereInput | InterviewScalarWhereInput[]
    id?: StringFilter<"Interview"> | string
    applicationId?: StringFilter<"Interview"> | string
    scheduledAt?: DateTimeFilter<"Interview"> | Date | string
    duration?: IntFilter<"Interview"> | number
    type?: EnumInterviewTypeFilter<"Interview"> | $Enums.InterviewType
    location?: StringNullableFilter<"Interview"> | string | null
    meetingUrl?: StringNullableFilter<"Interview"> | string | null
    interviewerId?: StringFilter<"Interview"> | string
    status?: EnumInterviewStatusFilter<"Interview"> | $Enums.InterviewStatus
    feedback?: StringNullableFilter<"Interview"> | string | null
    result?: EnumInterviewResultNullableFilter<"Interview"> | $Enums.InterviewResult | null
    createdAt?: DateTimeFilter<"Interview"> | Date | string
    updatedAt?: DateTimeFilter<"Interview"> | Date | string
  }

  export type CertificateUpsertWithWhereUniqueWithoutUserInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutUserInput, CertificateUncheckedUpdateWithoutUserInput>
    create: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutUserInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutUserInput, CertificateUncheckedUpdateWithoutUserInput>
  }

  export type CertificateUpdateManyWithWhereWithoutUserInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutUserInput>
  }

  export type CertificateScalarWhereInput = {
    AND?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    OR?: CertificateScalarWhereInput[]
    NOT?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    id?: StringFilter<"Certificate"> | string
    userId?: StringFilter<"Certificate"> | string
    courseId?: StringFilter<"Certificate"> | string
    certificateNumber?: StringFilter<"Certificate"> | string
    grade?: IntFilter<"Certificate"> | number
    completionDate?: DateTimeFilter<"Certificate"> | Date | string
    qrCodeUrl?: StringFilter<"Certificate"> | string
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
  }

  export type LibraryUpsertWithWhereUniqueWithoutUserInput = {
    where: LibraryWhereUniqueInput
    update: XOR<LibraryUpdateWithoutUserInput, LibraryUncheckedUpdateWithoutUserInput>
    create: XOR<LibraryCreateWithoutUserInput, LibraryUncheckedCreateWithoutUserInput>
  }

  export type LibraryUpdateWithWhereUniqueWithoutUserInput = {
    where: LibraryWhereUniqueInput
    data: XOR<LibraryUpdateWithoutUserInput, LibraryUncheckedUpdateWithoutUserInput>
  }

  export type LibraryUpdateManyWithWhereWithoutUserInput = {
    where: LibraryScalarWhereInput
    data: XOR<LibraryUpdateManyMutationInput, LibraryUncheckedUpdateManyWithoutUserInput>
  }

  export type LibraryScalarWhereInput = {
    AND?: LibraryScalarWhereInput | LibraryScalarWhereInput[]
    OR?: LibraryScalarWhereInput[]
    NOT?: LibraryScalarWhereInput | LibraryScalarWhereInput[]
    id?: StringFilter<"Library"> | string
    userId?: StringFilter<"Library"> | string
    itemType?: EnumLibraryItemTypeFilter<"Library"> | $Enums.LibraryItemType
    itemId?: StringFilter<"Library"> | string
    downloadUrl?: StringFilter<"Library"> | string
    expiresAt?: DateTimeNullableFilter<"Library"> | Date | string | null
    createdAt?: DateTimeFilter<"Library"> | Date | string
  }

  export type CustomPaperUpsertWithWhereUniqueWithoutUserInput = {
    where: CustomPaperWhereUniqueInput
    update: XOR<CustomPaperUpdateWithoutUserInput, CustomPaperUncheckedUpdateWithoutUserInput>
    create: XOR<CustomPaperCreateWithoutUserInput, CustomPaperUncheckedCreateWithoutUserInput>
  }

  export type CustomPaperUpdateWithWhereUniqueWithoutUserInput = {
    where: CustomPaperWhereUniqueInput
    data: XOR<CustomPaperUpdateWithoutUserInput, CustomPaperUncheckedUpdateWithoutUserInput>
  }

  export type CustomPaperUpdateManyWithWhereWithoutUserInput = {
    where: CustomPaperScalarWhereInput
    data: XOR<CustomPaperUpdateManyMutationInput, CustomPaperUncheckedUpdateManyWithoutUserInput>
  }

  export type CustomPaperScalarWhereInput = {
    AND?: CustomPaperScalarWhereInput | CustomPaperScalarWhereInput[]
    OR?: CustomPaperScalarWhereInput[]
    NOT?: CustomPaperScalarWhereInput | CustomPaperScalarWhereInput[]
    id?: StringFilter<"CustomPaper"> | string
    userId?: StringNullableFilter<"CustomPaper"> | string | null
    title?: StringFilter<"CustomPaper"> | string
    description?: StringFilter<"CustomPaper"> | string
    paperType?: EnumPaperTypeFilter<"CustomPaper"> | $Enums.PaperType
    academicArea?: EnumAcademicAreaFilter<"CustomPaper"> | $Enums.AcademicArea
    pageCount?: IntFilter<"CustomPaper"> | number
    deadline?: DateTimeFilter<"CustomPaper"> | Date | string
    urgency?: EnumCustomPaperUrgencyFilter<"CustomPaper"> | $Enums.CustomPaperUrgency
    requirements?: StringFilter<"CustomPaper"> | string
    keywords?: StringNullableFilter<"CustomPaper"> | string | null
    references?: StringNullableFilter<"CustomPaper"> | string | null
    requirementFiles?: StringNullableListFilter<"CustomPaper">
    deliveryFiles?: StringNullableListFilter<"CustomPaper">
    quotedPrice?: IntNullableFilter<"CustomPaper"> | number | null
    finalPrice?: IntNullableFilter<"CustomPaper"> | number | null
    paymentStatus?: EnumPaymentStatusFilter<"CustomPaper"> | $Enums.PaymentStatus
    status?: EnumCustomPaperStatusFilter<"CustomPaper"> | $Enums.CustomPaperStatus
    adminNotes?: StringNullableFilter<"CustomPaper"> | string | null
    rejectionReason?: StringNullableFilter<"CustomPaper"> | string | null
    requestedAt?: DateTimeFilter<"CustomPaper"> | Date | string
    quotedAt?: DateTimeNullableFilter<"CustomPaper"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"CustomPaper"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"CustomPaper"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CustomPaper"> | Date | string | null
    orderId?: StringNullableFilter<"CustomPaper"> | string | null
  }

  export type CustomPaperMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: CustomPaperMessageWhereUniqueInput
    update: XOR<CustomPaperMessageUpdateWithoutSenderInput, CustomPaperMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<CustomPaperMessageCreateWithoutSenderInput, CustomPaperMessageUncheckedCreateWithoutSenderInput>
  }

  export type CustomPaperMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: CustomPaperMessageWhereUniqueInput
    data: XOR<CustomPaperMessageUpdateWithoutSenderInput, CustomPaperMessageUncheckedUpdateWithoutSenderInput>
  }

  export type CustomPaperMessageUpdateManyWithWhereWithoutSenderInput = {
    where: CustomPaperMessageScalarWhereInput
    data: XOR<CustomPaperMessageUpdateManyMutationInput, CustomPaperMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type CustomPaperMessageScalarWhereInput = {
    AND?: CustomPaperMessageScalarWhereInput | CustomPaperMessageScalarWhereInput[]
    OR?: CustomPaperMessageScalarWhereInput[]
    NOT?: CustomPaperMessageScalarWhereInput | CustomPaperMessageScalarWhereInput[]
    id?: StringFilter<"CustomPaperMessage"> | string
    customPaperId?: StringFilter<"CustomPaperMessage"> | string
    senderId?: StringFilter<"CustomPaperMessage"> | string
    content?: StringFilter<"CustomPaperMessage"> | string
    attachments?: StringNullableListFilter<"CustomPaperMessage">
    isFromAdmin?: BoolFilter<"CustomPaperMessage"> | boolean
    isRead?: BoolFilter<"CustomPaperMessage"> | boolean
    createdAt?: DateTimeFilter<"CustomPaperMessage"> | Date | string
  }

  export type CourseProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: CourseProgressWhereUniqueInput
    update: XOR<CourseProgressUpdateWithoutUserInput, CourseProgressUncheckedUpdateWithoutUserInput>
    create: XOR<CourseProgressCreateWithoutUserInput, CourseProgressUncheckedCreateWithoutUserInput>
  }

  export type CourseProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: CourseProgressWhereUniqueInput
    data: XOR<CourseProgressUpdateWithoutUserInput, CourseProgressUncheckedUpdateWithoutUserInput>
  }

  export type CourseProgressUpdateManyWithWhereWithoutUserInput = {
    where: CourseProgressScalarWhereInput
    data: XOR<CourseProgressUpdateManyMutationInput, CourseProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type CourseProgressScalarWhereInput = {
    AND?: CourseProgressScalarWhereInput | CourseProgressScalarWhereInput[]
    OR?: CourseProgressScalarWhereInput[]
    NOT?: CourseProgressScalarWhereInput | CourseProgressScalarWhereInput[]
    id?: StringFilter<"CourseProgress"> | string
    userId?: StringFilter<"CourseProgress"> | string
    lessonId?: StringFilter<"CourseProgress"> | string
    completed?: BoolFilter<"CourseProgress"> | boolean
    watchTime?: IntFilter<"CourseProgress"> | number
    completedAt?: DateTimeNullableFilter<"CourseProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"CourseProgress"> | Date | string
    updatedAt?: DateTimeFilter<"CourseProgress"> | Date | string
  }

  export type CourseEnrollmentUpsertWithWhereUniqueWithoutUserInput = {
    where: CourseEnrollmentWhereUniqueInput
    update: XOR<CourseEnrollmentUpdateWithoutUserInput, CourseEnrollmentUncheckedUpdateWithoutUserInput>
    create: XOR<CourseEnrollmentCreateWithoutUserInput, CourseEnrollmentUncheckedCreateWithoutUserInput>
  }

  export type CourseEnrollmentUpdateWithWhereUniqueWithoutUserInput = {
    where: CourseEnrollmentWhereUniqueInput
    data: XOR<CourseEnrollmentUpdateWithoutUserInput, CourseEnrollmentUncheckedUpdateWithoutUserInput>
  }

  export type CourseEnrollmentUpdateManyWithWhereWithoutUserInput = {
    where: CourseEnrollmentScalarWhereInput
    data: XOR<CourseEnrollmentUpdateManyMutationInput, CourseEnrollmentUncheckedUpdateManyWithoutUserInput>
  }

  export type CourseEnrollmentScalarWhereInput = {
    AND?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
    OR?: CourseEnrollmentScalarWhereInput[]
    NOT?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
    id?: StringFilter<"CourseEnrollment"> | string
    userId?: StringFilter<"CourseEnrollment"> | string
    courseId?: StringFilter<"CourseEnrollment"> | string
    enrolledAt?: DateTimeFilter<"CourseEnrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"CourseEnrollment"> | Date | string | null
    progress?: IntFilter<"CourseEnrollment"> | number
  }

  export type BlogPostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutAuthorInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type BlogPostScalarWhereInput = {
    AND?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    OR?: BlogPostScalarWhereInput[]
    NOT?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    coverImageUrl?: StringNullableFilter<"BlogPost"> | string | null
    published?: BoolFilter<"BlogPost"> | boolean
    status?: EnumPostStatusFilter<"BlogPost"> | $Enums.PostStatus
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    authorId?: StringFilter<"BlogPost"> | string
    categoryId?: StringNullableFilter<"BlogPost"> | string | null
    views?: IntFilter<"BlogPost"> | number
    metaTitle?: StringNullableFilter<"BlogPost"> | string | null
    metaDescription?: StringNullableFilter<"BlogPost"> | string | null
    metaKeywords?: StringNullableListFilter<"BlogPost">
    ogImage?: StringNullableFilter<"BlogPost"> | string | null
    canonicalUrl?: StringNullableFilter<"BlogPost"> | string | null
    readingTime?: IntNullableFilter<"BlogPost"> | number | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    approved?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type LikeUpsertWithWhereUniqueWithoutUserInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutUserInput, LikeUncheckedUpdateWithoutUserInput>
    create: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutUserInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutUserInput, LikeUncheckedUpdateWithoutUserInput>
  }

  export type LikeUpdateManyWithWhereWithoutUserInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutUserInput>
  }

  export type LikeScalarWhereInput = {
    AND?: LikeScalarWhereInput | LikeScalarWhereInput[]
    OR?: LikeScalarWhereInput[]
    NOT?: LikeScalarWhereInput | LikeScalarWhereInput[]
    id?: StringFilter<"Like"> | string
    postId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    collaboratorApplications?: CollaboratorApplicationCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    interviews?: InterviewCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    library?: LibraryCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    collaboratorApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    library?: LibraryUncheckedCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperUncheckedCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageUncheckedCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    paper?: PaperCreateNestedOneWithoutOrderItemsInput
    course?: CourseCreateNestedOneWithoutOrderItemsInput
    ebook?: EbookCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    paperId?: string | null
    courseId?: string | null
    ebookId?: string | null
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type CustomPaperCreateWithoutOrderInput = {
    id?: string
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    pageCount: number
    deadline: Date | string
    urgency: $Enums.CustomPaperUrgency
    requirements: string
    keywords?: string | null
    references?: string | null
    requirementFiles?: CustomPaperCreaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperCreatedeliveryFilesInput | string[]
    quotedPrice?: number | null
    finalPrice?: number | null
    paymentStatus?: $Enums.PaymentStatus
    status?: $Enums.CustomPaperStatus
    adminNotes?: string | null
    rejectionReason?: string | null
    requestedAt?: Date | string
    quotedAt?: Date | string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCustomPapersInput
    messages?: CustomPaperMessageCreateNestedManyWithoutCustomPaperInput
  }

  export type CustomPaperUncheckedCreateWithoutOrderInput = {
    id?: string
    userId?: string | null
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    pageCount: number
    deadline: Date | string
    urgency: $Enums.CustomPaperUrgency
    requirements: string
    keywords?: string | null
    references?: string | null
    requirementFiles?: CustomPaperCreaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperCreatedeliveryFilesInput | string[]
    quotedPrice?: number | null
    finalPrice?: number | null
    paymentStatus?: $Enums.PaymentStatus
    status?: $Enums.CustomPaperStatus
    adminNotes?: string | null
    rejectionReason?: string | null
    requestedAt?: Date | string
    quotedAt?: Date | string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    messages?: CustomPaperMessageUncheckedCreateNestedManyWithoutCustomPaperInput
  }

  export type CustomPaperCreateOrConnectWithoutOrderInput = {
    where: CustomPaperWhereUniqueInput
    create: XOR<CustomPaperCreateWithoutOrderInput, CustomPaperUncheckedCreateWithoutOrderInput>
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    collaboratorApplications?: CollaboratorApplicationUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    library?: LibraryUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    collaboratorApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    library?: LibraryUncheckedUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUncheckedUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUncheckedUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    title?: StringFilter<"OrderItem"> | string
    description?: StringNullableFilter<"OrderItem"> | string | null
    price?: IntFilter<"OrderItem"> | number
    paperId?: StringNullableFilter<"OrderItem"> | string | null
    courseId?: StringNullableFilter<"OrderItem"> | string | null
    ebookId?: StringNullableFilter<"OrderItem"> | string | null
  }

  export type CustomPaperUpsertWithoutOrderInput = {
    update: XOR<CustomPaperUpdateWithoutOrderInput, CustomPaperUncheckedUpdateWithoutOrderInput>
    create: XOR<CustomPaperCreateWithoutOrderInput, CustomPaperUncheckedCreateWithoutOrderInput>
    where?: CustomPaperWhereInput
  }

  export type CustomPaperUpdateToOneWithWhereWithoutOrderInput = {
    where?: CustomPaperWhereInput
    data: XOR<CustomPaperUpdateWithoutOrderInput, CustomPaperUncheckedUpdateWithoutOrderInput>
  }

  export type CustomPaperUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    pageCount?: IntFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    urgency?: EnumCustomPaperUrgencyFieldUpdateOperationsInput | $Enums.CustomPaperUrgency
    requirements?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    requirementFiles?: CustomPaperUpdaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperUpdatedeliveryFilesInput | string[]
    quotedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    status?: EnumCustomPaperStatusFieldUpdateOperationsInput | $Enums.CustomPaperStatus
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCustomPapersNestedInput
    messages?: CustomPaperMessageUpdateManyWithoutCustomPaperNestedInput
  }

  export type CustomPaperUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    pageCount?: IntFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    urgency?: EnumCustomPaperUrgencyFieldUpdateOperationsInput | $Enums.CustomPaperUrgency
    requirements?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    requirementFiles?: CustomPaperUpdaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperUpdatedeliveryFilesInput | string[]
    quotedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    status?: EnumCustomPaperStatusFieldUpdateOperationsInput | $Enums.CustomPaperStatus
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: CustomPaperMessageUncheckedUpdateManyWithoutCustomPaperNestedInput
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    totalAmount: number
    status?: $Enums.OrderStatus
    paymentMethod?: $Enums.PaymentMethod | null
    paymentStatus?: $Enums.PaymentStatus
    customerName: string
    customerEmail: string
    customerCpfCnpj: string
    customerPhone?: string | null
    pixCode?: string | null
    boletoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    customPaper?: CustomPaperCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    userId?: string | null
    totalAmount: number
    status?: $Enums.OrderStatus
    paymentMethod?: $Enums.PaymentMethod | null
    paymentStatus?: $Enums.PaymentStatus
    customerName: string
    customerEmail: string
    customerCpfCnpj: string
    customerPhone?: string | null
    pixCode?: string | null
    boletoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customPaper?: CustomPaperUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type PaperCreateWithoutOrderItemsInput = {
    id?: string
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    price: number
    pageCount: number
    authorName: string
    language?: string
    keywords?: string | null
    previewUrl?: string | null
    fileUrl: string
    thumbnailUrl?: string | null
    isFree?: boolean
    createdAt?: Date | string
  }

  export type PaperUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    price: number
    pageCount: number
    authorName: string
    language?: string
    keywords?: string | null
    previewUrl?: string | null
    fileUrl: string
    thumbnailUrl?: string | null
    isFree?: boolean
    createdAt?: Date | string
  }

  export type PaperCreateOrConnectWithoutOrderItemsInput = {
    where: PaperWhereUniqueInput
    create: XOR<PaperCreateWithoutOrderItemsInput, PaperUncheckedCreateWithoutOrderItemsInput>
  }

  export type CourseCreateWithoutOrderItemsInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    instructorName: string
    instructorBio?: string | null
    price: number
    duration: number
    level?: $Enums.CourseLevel
    thumbnailUrl?: string | null
    videoUrl?: string | null
    status?: $Enums.CourseStatus
    isFeatured?: boolean
    createdAt?: Date | string
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    instructorName: string
    instructorBio?: string | null
    price: number
    duration: number
    level?: $Enums.CourseLevel
    thumbnailUrl?: string | null
    videoUrl?: string | null
    status?: $Enums.CourseStatus
    isFeatured?: boolean
    createdAt?: Date | string
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutOrderItemsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutOrderItemsInput, CourseUncheckedCreateWithoutOrderItemsInput>
  }

  export type EbookCreateWithoutOrderItemsInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    authorName: string
    price: number
    pageCount: number
    fileUrl: string
    coverUrl?: string | null
    createdAt?: Date | string
    files?: EbookFileCreateNestedManyWithoutEbookInput
  }

  export type EbookUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    authorName: string
    price: number
    pageCount: number
    fileUrl: string
    coverUrl?: string | null
    createdAt?: Date | string
    files?: EbookFileUncheckedCreateNestedManyWithoutEbookInput
  }

  export type EbookCreateOrConnectWithoutOrderItemsInput = {
    where: EbookWhereUniqueInput
    create: XOR<EbookCreateWithoutOrderItemsInput, EbookUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerCpfCnpj?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    customPaper?: CustomPaperUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerCpfCnpj?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customPaper?: CustomPaperUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type PaperUpsertWithoutOrderItemsInput = {
    update: XOR<PaperUpdateWithoutOrderItemsInput, PaperUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<PaperCreateWithoutOrderItemsInput, PaperUncheckedCreateWithoutOrderItemsInput>
    where?: PaperWhereInput
  }

  export type PaperUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: PaperWhereInput
    data: XOR<PaperUpdateWithoutOrderItemsInput, PaperUncheckedUpdateWithoutOrderItemsInput>
  }

  export type PaperUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    price?: IntFieldUpdateOperationsInput | number
    pageCount?: IntFieldUpdateOperationsInput | number
    authorName?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaperUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    price?: IntFieldUpdateOperationsInput | number
    pageCount?: IntFieldUpdateOperationsInput | number
    authorName?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUpsertWithoutOrderItemsInput = {
    update: XOR<CourseUpdateWithoutOrderItemsInput, CourseUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<CourseCreateWithoutOrderItemsInput, CourseUncheckedCreateWithoutOrderItemsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutOrderItemsInput, CourseUncheckedUpdateWithoutOrderItemsInput>
  }

  export type CourseUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    instructorName?: StringFieldUpdateOperationsInput | string
    instructorBio?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    instructorName?: StringFieldUpdateOperationsInput | string
    instructorBio?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type EbookUpsertWithoutOrderItemsInput = {
    update: XOR<EbookUpdateWithoutOrderItemsInput, EbookUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<EbookCreateWithoutOrderItemsInput, EbookUncheckedCreateWithoutOrderItemsInput>
    where?: EbookWhereInput
  }

  export type EbookUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: EbookWhereInput
    data: XOR<EbookUpdateWithoutOrderItemsInput, EbookUncheckedUpdateWithoutOrderItemsInput>
  }

  export type EbookUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    authorName?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    pageCount?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: EbookFileUpdateManyWithoutEbookNestedInput
  }

  export type EbookUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    authorName?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    pageCount?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: EbookFileUncheckedUpdateManyWithoutEbookNestedInput
  }

  export type OrderItemCreateWithoutPaperInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    order: OrderCreateNestedOneWithoutItemsInput
    course?: CourseCreateNestedOneWithoutOrderItemsInput
    ebook?: EbookCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutPaperInput = {
    id?: string
    orderId: string
    title: string
    description?: string | null
    price: number
    courseId?: string | null
    ebookId?: string | null
  }

  export type OrderItemCreateOrConnectWithoutPaperInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutPaperInput, OrderItemUncheckedCreateWithoutPaperInput>
  }

  export type OrderItemCreateManyPaperInputEnvelope = {
    data: OrderItemCreateManyPaperInput | OrderItemCreateManyPaperInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemUpsertWithWhereUniqueWithoutPaperInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutPaperInput, OrderItemUncheckedUpdateWithoutPaperInput>
    create: XOR<OrderItemCreateWithoutPaperInput, OrderItemUncheckedCreateWithoutPaperInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutPaperInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutPaperInput, OrderItemUncheckedUpdateWithoutPaperInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutPaperInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutPaperInput>
  }

  export type OrderItemCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    order: OrderCreateNestedOneWithoutItemsInput
    paper?: PaperCreateNestedOneWithoutOrderItemsInput
    ebook?: EbookCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutCourseInput = {
    id?: string
    orderId: string
    title: string
    description?: string | null
    price: number
    paperId?: string | null
    ebookId?: string | null
  }

  export type OrderItemCreateOrConnectWithoutCourseInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutCourseInput, OrderItemUncheckedCreateWithoutCourseInput>
  }

  export type OrderItemCreateManyCourseInputEnvelope = {
    data: OrderItemCreateManyCourseInput | OrderItemCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutCourseInput = {
    id?: string
    certificateNumber: string
    grade: number
    completionDate: Date | string
    qrCodeUrl: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    certificateNumber: string
    grade: number
    completionDate: Date | string
    qrCodeUrl: string
    createdAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutCourseInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput>
  }

  export type CertificateCreateManyCourseInputEnvelope = {
    data: CertificateCreateManyCourseInput | CertificateCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseModuleCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lessons?: CourseLessonCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleUncheckedCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lessons?: CourseLessonUncheckedCreateNestedManyWithoutModuleInput
  }

  export type CourseModuleCreateOrConnectWithoutCourseInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput>
  }

  export type CourseModuleCreateManyCourseInputEnvelope = {
    data: CourseModuleCreateManyCourseInput | CourseModuleCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseEnrollmentCreateWithoutCourseInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
    user: UserCreateNestedOneWithoutCourseEnrollmentsInput
  }

  export type CourseEnrollmentUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
  }

  export type CourseEnrollmentCreateOrConnectWithoutCourseInput = {
    where: CourseEnrollmentWhereUniqueInput
    create: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type CourseEnrollmentCreateManyCourseInputEnvelope = {
    data: CourseEnrollmentCreateManyCourseInput | CourseEnrollmentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemUpsertWithWhereUniqueWithoutCourseInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutCourseInput, OrderItemUncheckedUpdateWithoutCourseInput>
    create: XOR<OrderItemCreateWithoutCourseInput, OrderItemUncheckedCreateWithoutCourseInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutCourseInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutCourseInput, OrderItemUncheckedUpdateWithoutCourseInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutCourseInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutCourseInput>
  }

  export type CertificateUpsertWithWhereUniqueWithoutCourseInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutCourseInput, CertificateUncheckedUpdateWithoutCourseInput>
    create: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutCourseInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutCourseInput, CertificateUncheckedUpdateWithoutCourseInput>
  }

  export type CertificateUpdateManyWithWhereWithoutCourseInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseModuleUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseModuleWhereUniqueInput
    update: XOR<CourseModuleUpdateWithoutCourseInput, CourseModuleUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput>
  }

  export type CourseModuleUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseModuleWhereUniqueInput
    data: XOR<CourseModuleUpdateWithoutCourseInput, CourseModuleUncheckedUpdateWithoutCourseInput>
  }

  export type CourseModuleUpdateManyWithWhereWithoutCourseInput = {
    where: CourseModuleScalarWhereInput
    data: XOR<CourseModuleUpdateManyMutationInput, CourseModuleUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseModuleScalarWhereInput = {
    AND?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
    OR?: CourseModuleScalarWhereInput[]
    NOT?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
    id?: StringFilter<"CourseModule"> | string
    courseId?: StringFilter<"CourseModule"> | string
    title?: StringFilter<"CourseModule"> | string
    description?: StringNullableFilter<"CourseModule"> | string | null
    order?: IntFilter<"CourseModule"> | number
    createdAt?: DateTimeFilter<"CourseModule"> | Date | string
    updatedAt?: DateTimeFilter<"CourseModule"> | Date | string
  }

  export type CourseEnrollmentUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseEnrollmentWhereUniqueInput
    update: XOR<CourseEnrollmentUpdateWithoutCourseInput, CourseEnrollmentUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type CourseEnrollmentUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseEnrollmentWhereUniqueInput
    data: XOR<CourseEnrollmentUpdateWithoutCourseInput, CourseEnrollmentUncheckedUpdateWithoutCourseInput>
  }

  export type CourseEnrollmentUpdateManyWithWhereWithoutCourseInput = {
    where: CourseEnrollmentScalarWhereInput
    data: XOR<CourseEnrollmentUpdateManyMutationInput, CourseEnrollmentUncheckedUpdateManyWithoutCourseInput>
  }

  export type EbookFileCreateWithoutEbookInput = {
    id?: string
    fileUrl: string
    fileName: string
    fileSize?: number | null
    createdAt?: Date | string
  }

  export type EbookFileUncheckedCreateWithoutEbookInput = {
    id?: string
    fileUrl: string
    fileName: string
    fileSize?: number | null
    createdAt?: Date | string
  }

  export type EbookFileCreateOrConnectWithoutEbookInput = {
    where: EbookFileWhereUniqueInput
    create: XOR<EbookFileCreateWithoutEbookInput, EbookFileUncheckedCreateWithoutEbookInput>
  }

  export type EbookFileCreateManyEbookInputEnvelope = {
    data: EbookFileCreateManyEbookInput | EbookFileCreateManyEbookInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutEbookInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    order: OrderCreateNestedOneWithoutItemsInput
    paper?: PaperCreateNestedOneWithoutOrderItemsInput
    course?: CourseCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutEbookInput = {
    id?: string
    orderId: string
    title: string
    description?: string | null
    price: number
    paperId?: string | null
    courseId?: string | null
  }

  export type OrderItemCreateOrConnectWithoutEbookInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutEbookInput, OrderItemUncheckedCreateWithoutEbookInput>
  }

  export type OrderItemCreateManyEbookInputEnvelope = {
    data: OrderItemCreateManyEbookInput | OrderItemCreateManyEbookInput[]
    skipDuplicates?: boolean
  }

  export type EbookFileUpsertWithWhereUniqueWithoutEbookInput = {
    where: EbookFileWhereUniqueInput
    update: XOR<EbookFileUpdateWithoutEbookInput, EbookFileUncheckedUpdateWithoutEbookInput>
    create: XOR<EbookFileCreateWithoutEbookInput, EbookFileUncheckedCreateWithoutEbookInput>
  }

  export type EbookFileUpdateWithWhereUniqueWithoutEbookInput = {
    where: EbookFileWhereUniqueInput
    data: XOR<EbookFileUpdateWithoutEbookInput, EbookFileUncheckedUpdateWithoutEbookInput>
  }

  export type EbookFileUpdateManyWithWhereWithoutEbookInput = {
    where: EbookFileScalarWhereInput
    data: XOR<EbookFileUpdateManyMutationInput, EbookFileUncheckedUpdateManyWithoutEbookInput>
  }

  export type EbookFileScalarWhereInput = {
    AND?: EbookFileScalarWhereInput | EbookFileScalarWhereInput[]
    OR?: EbookFileScalarWhereInput[]
    NOT?: EbookFileScalarWhereInput | EbookFileScalarWhereInput[]
    id?: StringFilter<"EbookFile"> | string
    ebookId?: StringFilter<"EbookFile"> | string
    fileUrl?: StringFilter<"EbookFile"> | string
    fileName?: StringFilter<"EbookFile"> | string
    fileSize?: IntNullableFilter<"EbookFile"> | number | null
    createdAt?: DateTimeFilter<"EbookFile"> | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutEbookInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutEbookInput, OrderItemUncheckedUpdateWithoutEbookInput>
    create: XOR<OrderItemCreateWithoutEbookInput, OrderItemUncheckedCreateWithoutEbookInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutEbookInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutEbookInput, OrderItemUncheckedUpdateWithoutEbookInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutEbookInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutEbookInput>
  }

  export type EbookCreateWithoutFilesInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    authorName: string
    price: number
    pageCount: number
    fileUrl: string
    coverUrl?: string | null
    createdAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutEbookInput
  }

  export type EbookUncheckedCreateWithoutFilesInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    authorName: string
    price: number
    pageCount: number
    fileUrl: string
    coverUrl?: string | null
    createdAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutEbookInput
  }

  export type EbookCreateOrConnectWithoutFilesInput = {
    where: EbookWhereUniqueInput
    create: XOR<EbookCreateWithoutFilesInput, EbookUncheckedCreateWithoutFilesInput>
  }

  export type EbookUpsertWithoutFilesInput = {
    update: XOR<EbookUpdateWithoutFilesInput, EbookUncheckedUpdateWithoutFilesInput>
    create: XOR<EbookCreateWithoutFilesInput, EbookUncheckedCreateWithoutFilesInput>
    where?: EbookWhereInput
  }

  export type EbookUpdateToOneWithWhereWithoutFilesInput = {
    where?: EbookWhereInput
    data: XOR<EbookUpdateWithoutFilesInput, EbookUncheckedUpdateWithoutFilesInput>
  }

  export type EbookUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    authorName?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    pageCount?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutEbookNestedInput
  }

  export type EbookUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    authorName?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    pageCount?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutEbookNestedInput
  }

  export type UserCreateWithoutCertificatesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    interviews?: InterviewCreateNestedManyWithoutInterviewerInput
    library?: LibraryCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCertificatesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutInterviewerInput
    library?: LibraryUncheckedCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperUncheckedCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageUncheckedCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCertificatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
  }

  export type CourseCreateWithoutCertificatesInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    instructorName: string
    instructorBio?: string | null
    price: number
    duration: number
    level?: $Enums.CourseLevel
    thumbnailUrl?: string | null
    videoUrl?: string | null
    status?: $Enums.CourseStatus
    isFeatured?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutCourseInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCertificatesInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    instructorName: string
    instructorBio?: string | null
    price: number
    duration: number
    level?: $Enums.CourseLevel
    thumbnailUrl?: string | null
    videoUrl?: string | null
    status?: $Enums.CourseStatus
    isFeatured?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutCourseInput
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCertificatesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCertificatesInput, CourseUncheckedCreateWithoutCertificatesInput>
  }

  export type UserUpsertWithoutCertificatesInput = {
    update: XOR<UserUpdateWithoutCertificatesInput, UserUncheckedUpdateWithoutCertificatesInput>
    create: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCertificatesInput, UserUncheckedUpdateWithoutCertificatesInput>
  }

  export type UserUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUpdateManyWithoutInterviewerNestedInput
    library?: LibraryUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutInterviewerNestedInput
    library?: LibraryUncheckedUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUncheckedUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUncheckedUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutCertificatesInput = {
    update: XOR<CourseUpdateWithoutCertificatesInput, CourseUncheckedUpdateWithoutCertificatesInput>
    create: XOR<CourseCreateWithoutCertificatesInput, CourseUncheckedCreateWithoutCertificatesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCertificatesInput, CourseUncheckedUpdateWithoutCertificatesInput>
  }

  export type CourseUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    instructorName?: StringFieldUpdateOperationsInput | string
    instructorBio?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    instructorName?: StringFieldUpdateOperationsInput | string
    instructorBio?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserCreateWithoutLibraryInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    interviews?: InterviewCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLibraryInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperUncheckedCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageUncheckedCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLibraryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLibraryInput, UserUncheckedCreateWithoutLibraryInput>
  }

  export type UserUpsertWithoutLibraryInput = {
    update: XOR<UserUpdateWithoutLibraryInput, UserUncheckedUpdateWithoutLibraryInput>
    create: XOR<UserCreateWithoutLibraryInput, UserUncheckedCreateWithoutLibraryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLibraryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLibraryInput, UserUncheckedUpdateWithoutLibraryInput>
  }

  export type UserUpdateWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUncheckedUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUncheckedUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogPostCreateWithoutCategoryInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutBlogPostsInput
    tags?: BlogTagCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: LikeCreateNestedManyWithoutPostInput
    analytics?: PostAnalyticsCreateNestedManyWithoutPostInput
    notifications?: PostNotificationCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    authorId: string
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: BlogTagUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    analytics?: PostAnalyticsUncheckedCreateNestedManyWithoutPostInput
    notifications?: PostNotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutCategoryInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput>
  }

  export type BlogPostCreateManyCategoryInputEnvelope = {
    data: BlogPostCreateManyCategoryInput | BlogPostCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type NewsletterSubscriptionCreateWithoutCategoryInput = {
    createdAt?: Date | string
    subscriber: NewsletterSubscriberCreateNestedOneWithoutSubscriptionsInput
  }

  export type NewsletterSubscriptionUncheckedCreateWithoutCategoryInput = {
    subscriberId: string
    createdAt?: Date | string
  }

  export type NewsletterSubscriptionCreateOrConnectWithoutCategoryInput = {
    where: NewsletterSubscriptionWhereUniqueInput
    create: XOR<NewsletterSubscriptionCreateWithoutCategoryInput, NewsletterSubscriptionUncheckedCreateWithoutCategoryInput>
  }

  export type NewsletterSubscriptionCreateManyCategoryInputEnvelope = {
    data: NewsletterSubscriptionCreateManyCategoryInput | NewsletterSubscriptionCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostUpsertWithWhereUniqueWithoutCategoryInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutCategoryInput, BlogPostUncheckedUpdateWithoutCategoryInput>
    create: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutCategoryInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutCategoryInput, BlogPostUncheckedUpdateWithoutCategoryInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutCategoryInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutCategoryInput>
  }

  export type NewsletterSubscriptionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: NewsletterSubscriptionWhereUniqueInput
    update: XOR<NewsletterSubscriptionUpdateWithoutCategoryInput, NewsletterSubscriptionUncheckedUpdateWithoutCategoryInput>
    create: XOR<NewsletterSubscriptionCreateWithoutCategoryInput, NewsletterSubscriptionUncheckedCreateWithoutCategoryInput>
  }

  export type NewsletterSubscriptionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: NewsletterSubscriptionWhereUniqueInput
    data: XOR<NewsletterSubscriptionUpdateWithoutCategoryInput, NewsletterSubscriptionUncheckedUpdateWithoutCategoryInput>
  }

  export type NewsletterSubscriptionUpdateManyWithWhereWithoutCategoryInput = {
    where: NewsletterSubscriptionScalarWhereInput
    data: XOR<NewsletterSubscriptionUpdateManyMutationInput, NewsletterSubscriptionUncheckedUpdateManyWithoutCategoryInput>
  }

  export type NewsletterSubscriptionScalarWhereInput = {
    AND?: NewsletterSubscriptionScalarWhereInput | NewsletterSubscriptionScalarWhereInput[]
    OR?: NewsletterSubscriptionScalarWhereInput[]
    NOT?: NewsletterSubscriptionScalarWhereInput | NewsletterSubscriptionScalarWhereInput[]
    subscriberId?: StringFilter<"NewsletterSubscription"> | string
    categoryId?: StringFilter<"NewsletterSubscription"> | string
    createdAt?: DateTimeFilter<"NewsletterSubscription"> | Date | string
  }

  export type BlogTagCreateWithoutTagInput = {
    post: BlogPostCreateNestedOneWithoutTagsInput
  }

  export type BlogTagUncheckedCreateWithoutTagInput = {
    postId: string
  }

  export type BlogTagCreateOrConnectWithoutTagInput = {
    where: BlogTagWhereUniqueInput
    create: XOR<BlogTagCreateWithoutTagInput, BlogTagUncheckedCreateWithoutTagInput>
  }

  export type BlogTagCreateManyTagInputEnvelope = {
    data: BlogTagCreateManyTagInput | BlogTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type BlogTagUpsertWithWhereUniqueWithoutTagInput = {
    where: BlogTagWhereUniqueInput
    update: XOR<BlogTagUpdateWithoutTagInput, BlogTagUncheckedUpdateWithoutTagInput>
    create: XOR<BlogTagCreateWithoutTagInput, BlogTagUncheckedCreateWithoutTagInput>
  }

  export type BlogTagUpdateWithWhereUniqueWithoutTagInput = {
    where: BlogTagWhereUniqueInput
    data: XOR<BlogTagUpdateWithoutTagInput, BlogTagUncheckedUpdateWithoutTagInput>
  }

  export type BlogTagUpdateManyWithWhereWithoutTagInput = {
    where: BlogTagScalarWhereInput
    data: XOR<BlogTagUpdateManyMutationInput, BlogTagUncheckedUpdateManyWithoutTagInput>
  }

  export type BlogTagScalarWhereInput = {
    AND?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
    OR?: BlogTagScalarWhereInput[]
    NOT?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
    postId?: StringFilter<"BlogTag"> | string
    tagId?: StringFilter<"BlogTag"> | string
  }

  export type UserCreateWithoutBlogPostsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    interviews?: InterviewCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    library?: LibraryCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogPostsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    library?: LibraryUncheckedCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperUncheckedCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageUncheckedCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
  }

  export type CategoryCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscribers?: NewsletterSubscriptionCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscribers?: NewsletterSubscriptionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutPostsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
  }

  export type BlogTagCreateWithoutPostInput = {
    tag: TagCreateNestedOneWithoutPostsInput
  }

  export type BlogTagUncheckedCreateWithoutPostInput = {
    tagId: string
  }

  export type BlogTagCreateOrConnectWithoutPostInput = {
    where: BlogTagWhereUniqueInput
    create: XOR<BlogTagCreateWithoutPostInput, BlogTagUncheckedCreateWithoutPostInput>
  }

  export type BlogTagCreateManyPostInputEnvelope = {
    data: BlogTagCreateManyPostInput | BlogTagCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    content: string
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    content: string
    userId: string
    parentId?: string | null
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutPostInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutPostInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput>
  }

  export type LikeCreateManyPostInputEnvelope = {
    data: LikeCreateManyPostInput | LikeCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostAnalyticsCreateWithoutPostInput = {
    id?: string
    date: Date | string
    views?: number
    uniqueViews?: number
    shares?: number
    avgTimeOnPage?: number
    bounceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostAnalyticsUncheckedCreateWithoutPostInput = {
    id?: string
    date: Date | string
    views?: number
    uniqueViews?: number
    shares?: number
    avgTimeOnPage?: number
    bounceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostAnalyticsCreateOrConnectWithoutPostInput = {
    where: PostAnalyticsWhereUniqueInput
    create: XOR<PostAnalyticsCreateWithoutPostInput, PostAnalyticsUncheckedCreateWithoutPostInput>
  }

  export type PostAnalyticsCreateManyPostInputEnvelope = {
    data: PostAnalyticsCreateManyPostInput | PostAnalyticsCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostNotificationCreateWithoutPostInput = {
    id?: string
    sentAt?: Date | string | null
    subscriberCount?: number
    subject?: string | null
    emailContent?: string | null
    createdAt?: Date | string
  }

  export type PostNotificationUncheckedCreateWithoutPostInput = {
    id?: string
    sentAt?: Date | string | null
    subscriberCount?: number
    subject?: string | null
    emailContent?: string | null
    createdAt?: Date | string
  }

  export type PostNotificationCreateOrConnectWithoutPostInput = {
    where: PostNotificationWhereUniqueInput
    create: XOR<PostNotificationCreateWithoutPostInput, PostNotificationUncheckedCreateWithoutPostInput>
  }

  export type PostNotificationCreateManyPostInputEnvelope = {
    data: PostNotificationCreateManyPostInput | PostNotificationCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBlogPostsInput = {
    update: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type UserUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    library?: LibraryUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    library?: LibraryUncheckedUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUncheckedUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUncheckedUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CategoryUpsertWithoutPostsInput = {
    update: XOR<CategoryUpdateWithoutPostsInput, CategoryUncheckedUpdateWithoutPostsInput>
    create: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutPostsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutPostsInput, CategoryUncheckedUpdateWithoutPostsInput>
  }

  export type CategoryUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribers?: NewsletterSubscriptionUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribers?: NewsletterSubscriptionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type BlogTagUpsertWithWhereUniqueWithoutPostInput = {
    where: BlogTagWhereUniqueInput
    update: XOR<BlogTagUpdateWithoutPostInput, BlogTagUncheckedUpdateWithoutPostInput>
    create: XOR<BlogTagCreateWithoutPostInput, BlogTagUncheckedCreateWithoutPostInput>
  }

  export type BlogTagUpdateWithWhereUniqueWithoutPostInput = {
    where: BlogTagWhereUniqueInput
    data: XOR<BlogTagUpdateWithoutPostInput, BlogTagUncheckedUpdateWithoutPostInput>
  }

  export type BlogTagUpdateManyWithWhereWithoutPostInput = {
    where: BlogTagScalarWhereInput
    data: XOR<BlogTagUpdateManyMutationInput, BlogTagUncheckedUpdateManyWithoutPostInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type LikeUpsertWithWhereUniqueWithoutPostInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutPostInput, LikeUncheckedUpdateWithoutPostInput>
    create: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutPostInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutPostInput, LikeUncheckedUpdateWithoutPostInput>
  }

  export type LikeUpdateManyWithWhereWithoutPostInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutPostInput>
  }

  export type PostAnalyticsUpsertWithWhereUniqueWithoutPostInput = {
    where: PostAnalyticsWhereUniqueInput
    update: XOR<PostAnalyticsUpdateWithoutPostInput, PostAnalyticsUncheckedUpdateWithoutPostInput>
    create: XOR<PostAnalyticsCreateWithoutPostInput, PostAnalyticsUncheckedCreateWithoutPostInput>
  }

  export type PostAnalyticsUpdateWithWhereUniqueWithoutPostInput = {
    where: PostAnalyticsWhereUniqueInput
    data: XOR<PostAnalyticsUpdateWithoutPostInput, PostAnalyticsUncheckedUpdateWithoutPostInput>
  }

  export type PostAnalyticsUpdateManyWithWhereWithoutPostInput = {
    where: PostAnalyticsScalarWhereInput
    data: XOR<PostAnalyticsUpdateManyMutationInput, PostAnalyticsUncheckedUpdateManyWithoutPostInput>
  }

  export type PostAnalyticsScalarWhereInput = {
    AND?: PostAnalyticsScalarWhereInput | PostAnalyticsScalarWhereInput[]
    OR?: PostAnalyticsScalarWhereInput[]
    NOT?: PostAnalyticsScalarWhereInput | PostAnalyticsScalarWhereInput[]
    id?: StringFilter<"PostAnalytics"> | string
    postId?: StringFilter<"PostAnalytics"> | string
    date?: DateTimeFilter<"PostAnalytics"> | Date | string
    views?: IntFilter<"PostAnalytics"> | number
    uniqueViews?: IntFilter<"PostAnalytics"> | number
    shares?: IntFilter<"PostAnalytics"> | number
    avgTimeOnPage?: IntFilter<"PostAnalytics"> | number
    bounceRate?: FloatFilter<"PostAnalytics"> | number
    createdAt?: DateTimeFilter<"PostAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"PostAnalytics"> | Date | string
  }

  export type PostNotificationUpsertWithWhereUniqueWithoutPostInput = {
    where: PostNotificationWhereUniqueInput
    update: XOR<PostNotificationUpdateWithoutPostInput, PostNotificationUncheckedUpdateWithoutPostInput>
    create: XOR<PostNotificationCreateWithoutPostInput, PostNotificationUncheckedCreateWithoutPostInput>
  }

  export type PostNotificationUpdateWithWhereUniqueWithoutPostInput = {
    where: PostNotificationWhereUniqueInput
    data: XOR<PostNotificationUpdateWithoutPostInput, PostNotificationUncheckedUpdateWithoutPostInput>
  }

  export type PostNotificationUpdateManyWithWhereWithoutPostInput = {
    where: PostNotificationScalarWhereInput
    data: XOR<PostNotificationUpdateManyMutationInput, PostNotificationUncheckedUpdateManyWithoutPostInput>
  }

  export type PostNotificationScalarWhereInput = {
    AND?: PostNotificationScalarWhereInput | PostNotificationScalarWhereInput[]
    OR?: PostNotificationScalarWhereInput[]
    NOT?: PostNotificationScalarWhereInput | PostNotificationScalarWhereInput[]
    id?: StringFilter<"PostNotification"> | string
    postId?: StringFilter<"PostNotification"> | string
    sentAt?: DateTimeNullableFilter<"PostNotification"> | Date | string | null
    subscriberCount?: IntFilter<"PostNotification"> | number
    subject?: StringNullableFilter<"PostNotification"> | string | null
    emailContent?: StringNullableFilter<"PostNotification"> | string | null
    createdAt?: DateTimeFilter<"PostNotification"> | Date | string
  }

  export type BlogPostCreateWithoutTagsInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutBlogPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: LikeCreateNestedManyWithoutPostInput
    analytics?: PostAnalyticsCreateNestedManyWithoutPostInput
    notifications?: PostNotificationCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    authorId: string
    categoryId?: string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    analytics?: PostAnalyticsUncheckedCreateNestedManyWithoutPostInput
    notifications?: PostNotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutTagsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateOrConnectWithoutPostsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
  }

  export type BlogPostUpsertWithoutTagsInput = {
    update: XOR<BlogPostUpdateWithoutTagsInput, BlogPostUncheckedUpdateWithoutTagsInput>
    create: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutTagsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutTagsInput, BlogPostUncheckedUpdateWithoutTagsInput>
  }

  export type BlogPostUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    analytics?: PostAnalyticsUpdateManyWithoutPostNestedInput
    notifications?: PostNotificationUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    analytics?: PostAnalyticsUncheckedUpdateManyWithoutPostNestedInput
    notifications?: PostNotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TagUpsertWithoutPostsInput = {
    update: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutPostsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
  }

  export type TagUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateWithoutCommentsInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutBlogPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: BlogTagCreateNestedManyWithoutPostInput
    likes?: LikeCreateNestedManyWithoutPostInput
    analytics?: PostAnalyticsCreateNestedManyWithoutPostInput
    notifications?: PostNotificationCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    authorId: string
    categoryId?: string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: BlogTagUncheckedCreateNestedManyWithoutPostInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    analytics?: PostAnalyticsUncheckedCreateNestedManyWithoutPostInput
    notifications?: PostNotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutCommentsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutCommentsInput, BlogPostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    interviews?: InterviewCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    library?: LibraryCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    likes?: LikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    library?: LibraryUncheckedCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperUncheckedCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageUncheckedCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post: BlogPostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    content: string
    postId: string
    userId: string
    parentId?: string | null
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutParentInput = {
    id?: string
    content: string
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post: BlogPostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string
    content: string
    postId: string
    userId: string
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostUpsertWithoutCommentsInput = {
    update: XOR<BlogPostUpdateWithoutCommentsInput, BlogPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<BlogPostCreateWithoutCommentsInput, BlogPostUncheckedCreateWithoutCommentsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutCommentsInput, BlogPostUncheckedUpdateWithoutCommentsInput>
  }

  export type BlogPostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: BlogTagUpdateManyWithoutPostNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    analytics?: PostAnalyticsUpdateManyWithoutPostNestedInput
    notifications?: PostNotificationUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: BlogTagUncheckedUpdateManyWithoutPostNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    analytics?: PostAnalyticsUncheckedUpdateManyWithoutPostNestedInput
    notifications?: PostNotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    library?: LibraryUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    library?: LibraryUncheckedUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUncheckedUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUncheckedUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type BlogPostCreateWithoutLikesInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutBlogPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: BlogTagCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    analytics?: PostAnalyticsCreateNestedManyWithoutPostInput
    notifications?: PostNotificationCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutLikesInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    authorId: string
    categoryId?: string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: BlogTagUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    analytics?: PostAnalyticsUncheckedCreateNestedManyWithoutPostInput
    notifications?: PostNotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutLikesInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutLikesInput, BlogPostUncheckedCreateWithoutLikesInput>
  }

  export type UserCreateWithoutLikesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    interviews?: InterviewCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    library?: LibraryCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLikesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    library?: LibraryUncheckedCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperUncheckedCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageUncheckedCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
  }

  export type BlogPostUpsertWithoutLikesInput = {
    update: XOR<BlogPostUpdateWithoutLikesInput, BlogPostUncheckedUpdateWithoutLikesInput>
    create: XOR<BlogPostCreateWithoutLikesInput, BlogPostUncheckedCreateWithoutLikesInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutLikesInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutLikesInput, BlogPostUncheckedUpdateWithoutLikesInput>
  }

  export type BlogPostUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: BlogTagUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    analytics?: PostAnalyticsUpdateManyWithoutPostNestedInput
    notifications?: PostNotificationUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: BlogTagUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    analytics?: PostAnalyticsUncheckedUpdateManyWithoutPostNestedInput
    notifications?: PostNotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutLikesInput = {
    update: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    library?: LibraryUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    library?: LibraryUncheckedUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUncheckedUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUncheckedUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCollaboratorApplicationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    interviews?: InterviewCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    library?: LibraryCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCollaboratorApplicationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    library?: LibraryUncheckedCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperUncheckedCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageUncheckedCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCollaboratorApplicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCollaboratorApplicationsInput, UserUncheckedCreateWithoutCollaboratorApplicationsInput>
  }

  export type EvaluationCreateWithoutApplicationInput = {
    id?: string
    experienceScore: number
    skillsScore: number
    educationScore: number
    culturalFitScore: number
    totalScore: number
    recommendation: $Enums.EvaluationRecommendation
    comments: string
    createdAt?: Date | string
    evaluator: UserCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutApplicationInput = {
    id?: string
    evaluatorId: string
    experienceScore: number
    skillsScore: number
    educationScore: number
    culturalFitScore: number
    totalScore: number
    recommendation: $Enums.EvaluationRecommendation
    comments: string
    createdAt?: Date | string
  }

  export type EvaluationCreateOrConnectWithoutApplicationInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutApplicationInput, EvaluationUncheckedCreateWithoutApplicationInput>
  }

  export type EvaluationCreateManyApplicationInputEnvelope = {
    data: EvaluationCreateManyApplicationInput | EvaluationCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutApplicationInput = {
    id?: string
    content: string
    isPrivate?: boolean
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutApplicationInput = {
    id?: string
    authorId: string
    content: string
    isPrivate?: boolean
    createdAt?: Date | string
  }

  export type NoteCreateOrConnectWithoutApplicationInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutApplicationInput, NoteUncheckedCreateWithoutApplicationInput>
  }

  export type NoteCreateManyApplicationInputEnvelope = {
    data: NoteCreateManyApplicationInput | NoteCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type InterviewCreateWithoutApplicationInput = {
    id?: string
    scheduledAt: Date | string
    duration: number
    type: $Enums.InterviewType
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.InterviewStatus
    feedback?: string | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interviewer: UserCreateNestedOneWithoutInterviewsInput
  }

  export type InterviewUncheckedCreateWithoutApplicationInput = {
    id?: string
    scheduledAt: Date | string
    duration: number
    type: $Enums.InterviewType
    location?: string | null
    meetingUrl?: string | null
    interviewerId: string
    status?: $Enums.InterviewStatus
    feedback?: string | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewCreateOrConnectWithoutApplicationInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutApplicationInput, InterviewUncheckedCreateWithoutApplicationInput>
  }

  export type InterviewCreateManyApplicationInputEnvelope = {
    data: InterviewCreateManyApplicationInput | InterviewCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutReviewedApplicationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationCreateNestedManyWithoutUserInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    interviews?: InterviewCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    library?: LibraryCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewedApplicationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutUserInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    library?: LibraryUncheckedCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperUncheckedCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageUncheckedCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewedApplicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewedApplicationsInput, UserUncheckedCreateWithoutReviewedApplicationsInput>
  }

  export type UserUpsertWithoutCollaboratorApplicationsInput = {
    update: XOR<UserUpdateWithoutCollaboratorApplicationsInput, UserUncheckedUpdateWithoutCollaboratorApplicationsInput>
    create: XOR<UserCreateWithoutCollaboratorApplicationsInput, UserUncheckedCreateWithoutCollaboratorApplicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCollaboratorApplicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCollaboratorApplicationsInput, UserUncheckedUpdateWithoutCollaboratorApplicationsInput>
  }

  export type UserUpdateWithoutCollaboratorApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    library?: LibraryUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCollaboratorApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    library?: LibraryUncheckedUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUncheckedUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUncheckedUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EvaluationUpsertWithWhereUniqueWithoutApplicationInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutApplicationInput, EvaluationUncheckedUpdateWithoutApplicationInput>
    create: XOR<EvaluationCreateWithoutApplicationInput, EvaluationUncheckedCreateWithoutApplicationInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutApplicationInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutApplicationInput, EvaluationUncheckedUpdateWithoutApplicationInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutApplicationInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutApplicationInput>
  }

  export type NoteUpsertWithWhereUniqueWithoutApplicationInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutApplicationInput, NoteUncheckedUpdateWithoutApplicationInput>
    create: XOR<NoteCreateWithoutApplicationInput, NoteUncheckedCreateWithoutApplicationInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutApplicationInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutApplicationInput, NoteUncheckedUpdateWithoutApplicationInput>
  }

  export type NoteUpdateManyWithWhereWithoutApplicationInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutApplicationInput>
  }

  export type InterviewUpsertWithWhereUniqueWithoutApplicationInput = {
    where: InterviewWhereUniqueInput
    update: XOR<InterviewUpdateWithoutApplicationInput, InterviewUncheckedUpdateWithoutApplicationInput>
    create: XOR<InterviewCreateWithoutApplicationInput, InterviewUncheckedCreateWithoutApplicationInput>
  }

  export type InterviewUpdateWithWhereUniqueWithoutApplicationInput = {
    where: InterviewWhereUniqueInput
    data: XOR<InterviewUpdateWithoutApplicationInput, InterviewUncheckedUpdateWithoutApplicationInput>
  }

  export type InterviewUpdateManyWithWhereWithoutApplicationInput = {
    where: InterviewScalarWhereInput
    data: XOR<InterviewUpdateManyMutationInput, InterviewUncheckedUpdateManyWithoutApplicationInput>
  }

  export type UserUpsertWithoutReviewedApplicationsInput = {
    update: XOR<UserUpdateWithoutReviewedApplicationsInput, UserUncheckedUpdateWithoutReviewedApplicationsInput>
    create: XOR<UserCreateWithoutReviewedApplicationsInput, UserUncheckedCreateWithoutReviewedApplicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewedApplicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewedApplicationsInput, UserUncheckedUpdateWithoutReviewedApplicationsInput>
  }

  export type UserUpdateWithoutReviewedApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUpdateManyWithoutUserNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    library?: LibraryUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewedApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutUserNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    library?: LibraryUncheckedUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUncheckedUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUncheckedUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCustomPapersInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    interviews?: InterviewCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    library?: LibraryCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCustomPapersInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    library?: LibraryUncheckedCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageUncheckedCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCustomPapersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomPapersInput, UserUncheckedCreateWithoutCustomPapersInput>
  }

  export type CustomPaperMessageCreateWithoutCustomPaperInput = {
    id?: string
    content: string
    attachments?: CustomPaperMessageCreateattachmentsInput | string[]
    isFromAdmin: boolean
    isRead?: boolean
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutCustomPaperMessagesInput
  }

  export type CustomPaperMessageUncheckedCreateWithoutCustomPaperInput = {
    id?: string
    senderId: string
    content: string
    attachments?: CustomPaperMessageCreateattachmentsInput | string[]
    isFromAdmin: boolean
    isRead?: boolean
    createdAt?: Date | string
  }

  export type CustomPaperMessageCreateOrConnectWithoutCustomPaperInput = {
    where: CustomPaperMessageWhereUniqueInput
    create: XOR<CustomPaperMessageCreateWithoutCustomPaperInput, CustomPaperMessageUncheckedCreateWithoutCustomPaperInput>
  }

  export type CustomPaperMessageCreateManyCustomPaperInputEnvelope = {
    data: CustomPaperMessageCreateManyCustomPaperInput | CustomPaperMessageCreateManyCustomPaperInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCustomPaperInput = {
    id?: string
    totalAmount: number
    status?: $Enums.OrderStatus
    paymentMethod?: $Enums.PaymentMethod | null
    paymentStatus?: $Enums.PaymentStatus
    customerName: string
    customerEmail: string
    customerCpfCnpj: string
    customerPhone?: string | null
    pixCode?: string | null
    boletoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomPaperInput = {
    id?: string
    userId?: string | null
    totalAmount: number
    status?: $Enums.OrderStatus
    paymentMethod?: $Enums.PaymentMethod | null
    paymentStatus?: $Enums.PaymentStatus
    customerName: string
    customerEmail: string
    customerCpfCnpj: string
    customerPhone?: string | null
    pixCode?: string | null
    boletoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomPaperInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomPaperInput, OrderUncheckedCreateWithoutCustomPaperInput>
  }

  export type UserUpsertWithoutCustomPapersInput = {
    update: XOR<UserUpdateWithoutCustomPapersInput, UserUncheckedUpdateWithoutCustomPapersInput>
    create: XOR<UserCreateWithoutCustomPapersInput, UserUncheckedCreateWithoutCustomPapersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomPapersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomPapersInput, UserUncheckedUpdateWithoutCustomPapersInput>
  }

  export type UserUpdateWithoutCustomPapersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    library?: LibraryUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomPapersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    library?: LibraryUncheckedUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUncheckedUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CustomPaperMessageUpsertWithWhereUniqueWithoutCustomPaperInput = {
    where: CustomPaperMessageWhereUniqueInput
    update: XOR<CustomPaperMessageUpdateWithoutCustomPaperInput, CustomPaperMessageUncheckedUpdateWithoutCustomPaperInput>
    create: XOR<CustomPaperMessageCreateWithoutCustomPaperInput, CustomPaperMessageUncheckedCreateWithoutCustomPaperInput>
  }

  export type CustomPaperMessageUpdateWithWhereUniqueWithoutCustomPaperInput = {
    where: CustomPaperMessageWhereUniqueInput
    data: XOR<CustomPaperMessageUpdateWithoutCustomPaperInput, CustomPaperMessageUncheckedUpdateWithoutCustomPaperInput>
  }

  export type CustomPaperMessageUpdateManyWithWhereWithoutCustomPaperInput = {
    where: CustomPaperMessageScalarWhereInput
    data: XOR<CustomPaperMessageUpdateManyMutationInput, CustomPaperMessageUncheckedUpdateManyWithoutCustomPaperInput>
  }

  export type OrderUpsertWithoutCustomPaperInput = {
    update: XOR<OrderUpdateWithoutCustomPaperInput, OrderUncheckedUpdateWithoutCustomPaperInput>
    create: XOR<OrderCreateWithoutCustomPaperInput, OrderUncheckedCreateWithoutCustomPaperInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutCustomPaperInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutCustomPaperInput, OrderUncheckedUpdateWithoutCustomPaperInput>
  }

  export type OrderUpdateWithoutCustomPaperInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerCpfCnpj?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomPaperInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerCpfCnpj?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type CustomPaperCreateWithoutMessagesInput = {
    id?: string
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    pageCount: number
    deadline: Date | string
    urgency: $Enums.CustomPaperUrgency
    requirements: string
    keywords?: string | null
    references?: string | null
    requirementFiles?: CustomPaperCreaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperCreatedeliveryFilesInput | string[]
    quotedPrice?: number | null
    finalPrice?: number | null
    paymentStatus?: $Enums.PaymentStatus
    status?: $Enums.CustomPaperStatus
    adminNotes?: string | null
    rejectionReason?: string | null
    requestedAt?: Date | string
    quotedAt?: Date | string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCustomPapersInput
    order?: OrderCreateNestedOneWithoutCustomPaperInput
  }

  export type CustomPaperUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId?: string | null
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    pageCount: number
    deadline: Date | string
    urgency: $Enums.CustomPaperUrgency
    requirements: string
    keywords?: string | null
    references?: string | null
    requirementFiles?: CustomPaperCreaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperCreatedeliveryFilesInput | string[]
    quotedPrice?: number | null
    finalPrice?: number | null
    paymentStatus?: $Enums.PaymentStatus
    status?: $Enums.CustomPaperStatus
    adminNotes?: string | null
    rejectionReason?: string | null
    requestedAt?: Date | string
    quotedAt?: Date | string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    orderId?: string | null
  }

  export type CustomPaperCreateOrConnectWithoutMessagesInput = {
    where: CustomPaperWhereUniqueInput
    create: XOR<CustomPaperCreateWithoutMessagesInput, CustomPaperUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutCustomPaperMessagesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    interviews?: InterviewCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    library?: LibraryCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperCreateNestedManyWithoutUserInput
    courseProgress?: CourseProgressCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCustomPaperMessagesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    library?: LibraryUncheckedCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperUncheckedCreateNestedManyWithoutUserInput
    courseProgress?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCustomPaperMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomPaperMessagesInput, UserUncheckedCreateWithoutCustomPaperMessagesInput>
  }

  export type CustomPaperUpsertWithoutMessagesInput = {
    update: XOR<CustomPaperUpdateWithoutMessagesInput, CustomPaperUncheckedUpdateWithoutMessagesInput>
    create: XOR<CustomPaperCreateWithoutMessagesInput, CustomPaperUncheckedCreateWithoutMessagesInput>
    where?: CustomPaperWhereInput
  }

  export type CustomPaperUpdateToOneWithWhereWithoutMessagesInput = {
    where?: CustomPaperWhereInput
    data: XOR<CustomPaperUpdateWithoutMessagesInput, CustomPaperUncheckedUpdateWithoutMessagesInput>
  }

  export type CustomPaperUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    pageCount?: IntFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    urgency?: EnumCustomPaperUrgencyFieldUpdateOperationsInput | $Enums.CustomPaperUrgency
    requirements?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    requirementFiles?: CustomPaperUpdaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperUpdatedeliveryFilesInput | string[]
    quotedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    status?: EnumCustomPaperStatusFieldUpdateOperationsInput | $Enums.CustomPaperStatus
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCustomPapersNestedInput
    order?: OrderUpdateOneWithoutCustomPaperNestedInput
  }

  export type CustomPaperUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    pageCount?: IntFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    urgency?: EnumCustomPaperUrgencyFieldUpdateOperationsInput | $Enums.CustomPaperUrgency
    requirements?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    requirementFiles?: CustomPaperUpdaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperUpdatedeliveryFilesInput | string[]
    quotedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    status?: EnumCustomPaperStatusFieldUpdateOperationsInput | $Enums.CustomPaperStatus
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutCustomPaperMessagesInput = {
    update: XOR<UserUpdateWithoutCustomPaperMessagesInput, UserUncheckedUpdateWithoutCustomPaperMessagesInput>
    create: XOR<UserCreateWithoutCustomPaperMessagesInput, UserUncheckedCreateWithoutCustomPaperMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomPaperMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomPaperMessagesInput, UserUncheckedUpdateWithoutCustomPaperMessagesInput>
  }

  export type UserUpdateWithoutCustomPaperMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    library?: LibraryUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUpdateManyWithoutUserNestedInput
    courseProgress?: CourseProgressUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomPaperMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    library?: LibraryUncheckedUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUncheckedUpdateManyWithoutUserNestedInput
    courseProgress?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseCreateWithoutModulesInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    instructorName: string
    instructorBio?: string | null
    price: number
    duration: number
    level?: $Enums.CourseLevel
    thumbnailUrl?: string | null
    videoUrl?: string | null
    status?: $Enums.CourseStatus
    isFeatured?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutModulesInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    instructorName: string
    instructorBio?: string | null
    price: number
    duration: number
    level?: $Enums.CourseLevel
    thumbnailUrl?: string | null
    videoUrl?: string | null
    status?: $Enums.CourseStatus
    isFeatured?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutModulesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
  }

  export type CourseLessonCreateWithoutModuleInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    order: number
    isEnabled?: boolean
    attachments?: CourseLessonCreateattachmentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: CourseProgressCreateNestedManyWithoutLessonInput
  }

  export type CourseLessonUncheckedCreateWithoutModuleInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    order: number
    isEnabled?: boolean
    attachments?: CourseLessonCreateattachmentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: CourseProgressUncheckedCreateNestedManyWithoutLessonInput
  }

  export type CourseLessonCreateOrConnectWithoutModuleInput = {
    where: CourseLessonWhereUniqueInput
    create: XOR<CourseLessonCreateWithoutModuleInput, CourseLessonUncheckedCreateWithoutModuleInput>
  }

  export type CourseLessonCreateManyModuleInputEnvelope = {
    data: CourseLessonCreateManyModuleInput | CourseLessonCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutModulesInput = {
    update: XOR<CourseUpdateWithoutModulesInput, CourseUncheckedUpdateWithoutModulesInput>
    create: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutModulesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutModulesInput, CourseUncheckedUpdateWithoutModulesInput>
  }

  export type CourseUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    instructorName?: StringFieldUpdateOperationsInput | string
    instructorBio?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    instructorName?: StringFieldUpdateOperationsInput | string
    instructorBio?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseLessonUpsertWithWhereUniqueWithoutModuleInput = {
    where: CourseLessonWhereUniqueInput
    update: XOR<CourseLessonUpdateWithoutModuleInput, CourseLessonUncheckedUpdateWithoutModuleInput>
    create: XOR<CourseLessonCreateWithoutModuleInput, CourseLessonUncheckedCreateWithoutModuleInput>
  }

  export type CourseLessonUpdateWithWhereUniqueWithoutModuleInput = {
    where: CourseLessonWhereUniqueInput
    data: XOR<CourseLessonUpdateWithoutModuleInput, CourseLessonUncheckedUpdateWithoutModuleInput>
  }

  export type CourseLessonUpdateManyWithWhereWithoutModuleInput = {
    where: CourseLessonScalarWhereInput
    data: XOR<CourseLessonUpdateManyMutationInput, CourseLessonUncheckedUpdateManyWithoutModuleInput>
  }

  export type CourseLessonScalarWhereInput = {
    AND?: CourseLessonScalarWhereInput | CourseLessonScalarWhereInput[]
    OR?: CourseLessonScalarWhereInput[]
    NOT?: CourseLessonScalarWhereInput | CourseLessonScalarWhereInput[]
    id?: StringFilter<"CourseLesson"> | string
    moduleId?: StringFilter<"CourseLesson"> | string
    title?: StringFilter<"CourseLesson"> | string
    description?: StringNullableFilter<"CourseLesson"> | string | null
    videoUrl?: StringNullableFilter<"CourseLesson"> | string | null
    content?: StringNullableFilter<"CourseLesson"> | string | null
    duration?: IntNullableFilter<"CourseLesson"> | number | null
    order?: IntFilter<"CourseLesson"> | number
    isEnabled?: BoolFilter<"CourseLesson"> | boolean
    attachments?: StringNullableListFilter<"CourseLesson">
    createdAt?: DateTimeFilter<"CourseLesson"> | Date | string
    updatedAt?: DateTimeFilter<"CourseLesson"> | Date | string
  }

  export type CourseModuleCreateWithoutLessonsInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutModulesInput
  }

  export type CourseModuleUncheckedCreateWithoutLessonsInput = {
    id?: string
    courseId: string
    title: string
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseModuleCreateOrConnectWithoutLessonsInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutLessonsInput, CourseModuleUncheckedCreateWithoutLessonsInput>
  }

  export type CourseProgressCreateWithoutLessonInput = {
    id?: string
    completed?: boolean
    watchTime?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCourseProgressInput
  }

  export type CourseProgressUncheckedCreateWithoutLessonInput = {
    id?: string
    userId: string
    completed?: boolean
    watchTime?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseProgressCreateOrConnectWithoutLessonInput = {
    where: CourseProgressWhereUniqueInput
    create: XOR<CourseProgressCreateWithoutLessonInput, CourseProgressUncheckedCreateWithoutLessonInput>
  }

  export type CourseProgressCreateManyLessonInputEnvelope = {
    data: CourseProgressCreateManyLessonInput | CourseProgressCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type CourseModuleUpsertWithoutLessonsInput = {
    update: XOR<CourseModuleUpdateWithoutLessonsInput, CourseModuleUncheckedUpdateWithoutLessonsInput>
    create: XOR<CourseModuleCreateWithoutLessonsInput, CourseModuleUncheckedCreateWithoutLessonsInput>
    where?: CourseModuleWhereInput
  }

  export type CourseModuleUpdateToOneWithWhereWithoutLessonsInput = {
    where?: CourseModuleWhereInput
    data: XOR<CourseModuleUpdateWithoutLessonsInput, CourseModuleUncheckedUpdateWithoutLessonsInput>
  }

  export type CourseModuleUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
  }

  export type CourseModuleUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseProgressUpsertWithWhereUniqueWithoutLessonInput = {
    where: CourseProgressWhereUniqueInput
    update: XOR<CourseProgressUpdateWithoutLessonInput, CourseProgressUncheckedUpdateWithoutLessonInput>
    create: XOR<CourseProgressCreateWithoutLessonInput, CourseProgressUncheckedCreateWithoutLessonInput>
  }

  export type CourseProgressUpdateWithWhereUniqueWithoutLessonInput = {
    where: CourseProgressWhereUniqueInput
    data: XOR<CourseProgressUpdateWithoutLessonInput, CourseProgressUncheckedUpdateWithoutLessonInput>
  }

  export type CourseProgressUpdateManyWithWhereWithoutLessonInput = {
    where: CourseProgressScalarWhereInput
    data: XOR<CourseProgressUpdateManyMutationInput, CourseProgressUncheckedUpdateManyWithoutLessonInput>
  }

  export type UserCreateWithoutCourseProgressInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    interviews?: InterviewCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    library?: LibraryCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageCreateNestedManyWithoutSenderInput
    courseEnrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCourseProgressInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    library?: LibraryUncheckedCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperUncheckedCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageUncheckedCreateNestedManyWithoutSenderInput
    courseEnrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCourseProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCourseProgressInput, UserUncheckedCreateWithoutCourseProgressInput>
  }

  export type CourseLessonCreateWithoutProgressInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    order: number
    isEnabled?: boolean
    attachments?: CourseLessonCreateattachmentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    module: CourseModuleCreateNestedOneWithoutLessonsInput
  }

  export type CourseLessonUncheckedCreateWithoutProgressInput = {
    id?: string
    moduleId: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    order: number
    isEnabled?: boolean
    attachments?: CourseLessonCreateattachmentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseLessonCreateOrConnectWithoutProgressInput = {
    where: CourseLessonWhereUniqueInput
    create: XOR<CourseLessonCreateWithoutProgressInput, CourseLessonUncheckedCreateWithoutProgressInput>
  }

  export type UserUpsertWithoutCourseProgressInput = {
    update: XOR<UserUpdateWithoutCourseProgressInput, UserUncheckedUpdateWithoutCourseProgressInput>
    create: XOR<UserCreateWithoutCourseProgressInput, UserUncheckedCreateWithoutCourseProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCourseProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCourseProgressInput, UserUncheckedUpdateWithoutCourseProgressInput>
  }

  export type UserUpdateWithoutCourseProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    library?: LibraryUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUpdateManyWithoutSenderNestedInput
    courseEnrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCourseProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    library?: LibraryUncheckedUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUncheckedUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUncheckedUpdateManyWithoutSenderNestedInput
    courseEnrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseLessonUpsertWithoutProgressInput = {
    update: XOR<CourseLessonUpdateWithoutProgressInput, CourseLessonUncheckedUpdateWithoutProgressInput>
    create: XOR<CourseLessonCreateWithoutProgressInput, CourseLessonUncheckedCreateWithoutProgressInput>
    where?: CourseLessonWhereInput
  }

  export type CourseLessonUpdateToOneWithWhereWithoutProgressInput = {
    where?: CourseLessonWhereInput
    data: XOR<CourseLessonUpdateWithoutProgressInput, CourseLessonUncheckedUpdateWithoutProgressInput>
  }

  export type CourseLessonUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    attachments?: CourseLessonUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: CourseModuleUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type CourseLessonUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    attachments?: CourseLessonUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutCourseEnrollmentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    interviews?: InterviewCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    library?: LibraryCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCourseEnrollmentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    library?: LibraryUncheckedCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperUncheckedCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageUncheckedCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCourseEnrollmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCourseEnrollmentsInput, UserUncheckedCreateWithoutCourseEnrollmentsInput>
  }

  export type CourseCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    instructorName: string
    instructorBio?: string | null
    price: number
    duration: number
    level?: $Enums.CourseLevel
    thumbnailUrl?: string | null
    videoUrl?: string | null
    status?: $Enums.CourseStatus
    isFeatured?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description: string
    academicArea: $Enums.AcademicArea
    instructorName: string
    instructorBio?: string | null
    price: number
    duration: number
    level?: $Enums.CourseLevel
    thumbnailUrl?: string | null
    videoUrl?: string | null
    status?: $Enums.CourseStatus
    isFeatured?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutEnrollmentsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
  }

  export type UserUpsertWithoutCourseEnrollmentsInput = {
    update: XOR<UserUpdateWithoutCourseEnrollmentsInput, UserUncheckedUpdateWithoutCourseEnrollmentsInput>
    create: XOR<UserCreateWithoutCourseEnrollmentsInput, UserUncheckedCreateWithoutCourseEnrollmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCourseEnrollmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCourseEnrollmentsInput, UserUncheckedUpdateWithoutCourseEnrollmentsInput>
  }

  export type UserUpdateWithoutCourseEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    library?: LibraryUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCourseEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    library?: LibraryUncheckedUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUncheckedUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUncheckedUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutEnrollmentsInput = {
    update: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    instructorName?: StringFieldUpdateOperationsInput | string
    instructorBio?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    instructorName?: StringFieldUpdateOperationsInput | string
    instructorBio?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type BlogPostCreateWithoutAnalyticsInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutBlogPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: BlogTagCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: LikeCreateNestedManyWithoutPostInput
    notifications?: PostNotificationCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    authorId: string
    categoryId?: string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: BlogTagUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    notifications?: PostNotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutAnalyticsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutAnalyticsInput, BlogPostUncheckedCreateWithoutAnalyticsInput>
  }

  export type BlogPostUpsertWithoutAnalyticsInput = {
    update: XOR<BlogPostUpdateWithoutAnalyticsInput, BlogPostUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<BlogPostCreateWithoutAnalyticsInput, BlogPostUncheckedCreateWithoutAnalyticsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutAnalyticsInput, BlogPostUncheckedUpdateWithoutAnalyticsInput>
  }

  export type BlogPostUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: BlogTagUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    notifications?: PostNotificationUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: BlogTagUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    notifications?: PostNotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type NewsletterSubscriptionCreateWithoutSubscriberInput = {
    createdAt?: Date | string
    category: CategoryCreateNestedOneWithoutSubscribersInput
  }

  export type NewsletterSubscriptionUncheckedCreateWithoutSubscriberInput = {
    categoryId: string
    createdAt?: Date | string
  }

  export type NewsletterSubscriptionCreateOrConnectWithoutSubscriberInput = {
    where: NewsletterSubscriptionWhereUniqueInput
    create: XOR<NewsletterSubscriptionCreateWithoutSubscriberInput, NewsletterSubscriptionUncheckedCreateWithoutSubscriberInput>
  }

  export type NewsletterSubscriptionCreateManySubscriberInputEnvelope = {
    data: NewsletterSubscriptionCreateManySubscriberInput | NewsletterSubscriptionCreateManySubscriberInput[]
    skipDuplicates?: boolean
  }

  export type NewsletterSubscriptionUpsertWithWhereUniqueWithoutSubscriberInput = {
    where: NewsletterSubscriptionWhereUniqueInput
    update: XOR<NewsletterSubscriptionUpdateWithoutSubscriberInput, NewsletterSubscriptionUncheckedUpdateWithoutSubscriberInput>
    create: XOR<NewsletterSubscriptionCreateWithoutSubscriberInput, NewsletterSubscriptionUncheckedCreateWithoutSubscriberInput>
  }

  export type NewsletterSubscriptionUpdateWithWhereUniqueWithoutSubscriberInput = {
    where: NewsletterSubscriptionWhereUniqueInput
    data: XOR<NewsletterSubscriptionUpdateWithoutSubscriberInput, NewsletterSubscriptionUncheckedUpdateWithoutSubscriberInput>
  }

  export type NewsletterSubscriptionUpdateManyWithWhereWithoutSubscriberInput = {
    where: NewsletterSubscriptionScalarWhereInput
    data: XOR<NewsletterSubscriptionUpdateManyMutationInput, NewsletterSubscriptionUncheckedUpdateManyWithoutSubscriberInput>
  }

  export type NewsletterSubscriberCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsletterSubscriberUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    name?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsletterSubscriberCreateOrConnectWithoutSubscriptionsInput = {
    where: NewsletterSubscriberWhereUniqueInput
    create: XOR<NewsletterSubscriberCreateWithoutSubscriptionsInput, NewsletterSubscriberUncheckedCreateWithoutSubscriptionsInput>
  }

  export type CategoryCreateWithoutSubscribersInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: BlogPostCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutSubscribersInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: BlogPostUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutSubscribersInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSubscribersInput, CategoryUncheckedCreateWithoutSubscribersInput>
  }

  export type NewsletterSubscriberUpsertWithoutSubscriptionsInput = {
    update: XOR<NewsletterSubscriberUpdateWithoutSubscriptionsInput, NewsletterSubscriberUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<NewsletterSubscriberCreateWithoutSubscriptionsInput, NewsletterSubscriberUncheckedCreateWithoutSubscriptionsInput>
    where?: NewsletterSubscriberWhereInput
  }

  export type NewsletterSubscriberUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: NewsletterSubscriberWhereInput
    data: XOR<NewsletterSubscriberUpdateWithoutSubscriptionsInput, NewsletterSubscriberUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type NewsletterSubscriberUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsletterSubscriberUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpsertWithoutSubscribersInput = {
    update: XOR<CategoryUpdateWithoutSubscribersInput, CategoryUncheckedUpdateWithoutSubscribersInput>
    create: XOR<CategoryCreateWithoutSubscribersInput, CategoryUncheckedCreateWithoutSubscribersInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutSubscribersInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutSubscribersInput, CategoryUncheckedUpdateWithoutSubscribersInput>
  }

  export type CategoryUpdateWithoutSubscribersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: BlogPostUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutSubscribersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: BlogPostUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type BlogPostCreateWithoutNotificationsInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutBlogPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: BlogTagCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: LikeCreateNestedManyWithoutPostInput
    analytics?: PostAnalyticsCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutNotificationsInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    authorId: string
    categoryId?: string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: BlogTagUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    analytics?: PostAnalyticsUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutNotificationsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutNotificationsInput, BlogPostUncheckedCreateWithoutNotificationsInput>
  }

  export type BlogPostUpsertWithoutNotificationsInput = {
    update: XOR<BlogPostUpdateWithoutNotificationsInput, BlogPostUncheckedUpdateWithoutNotificationsInput>
    create: XOR<BlogPostCreateWithoutNotificationsInput, BlogPostUncheckedCreateWithoutNotificationsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutNotificationsInput, BlogPostUncheckedUpdateWithoutNotificationsInput>
  }

  export type BlogPostUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: BlogTagUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    analytics?: PostAnalyticsUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: BlogTagUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    analytics?: PostAnalyticsUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CollaboratorApplicationCreateWithoutEvaluationsInput = {
    id?: string
    fullName: string
    email: string
    phone: string
    cpf?: string | null
    birthDate?: Date | string | null
    zipCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    area: string
    education?: string | null
    experience: string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability: string
    expectedSalary?: number | null
    resumeUrl?: string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: string | null
    github?: string | null
    status?: $Enums.ApplicationStatus
    stage?: $Enums.ApplicationStage
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    user: UserCreateNestedOneWithoutCollaboratorApplicationsInput
    notes?: NoteCreateNestedManyWithoutApplicationInput
    interviews?: InterviewCreateNestedManyWithoutApplicationInput
    reviewer?: UserCreateNestedOneWithoutReviewedApplicationsInput
  }

  export type CollaboratorApplicationUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    userId: string
    fullName: string
    email: string
    phone: string
    cpf?: string | null
    birthDate?: Date | string | null
    zipCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    area: string
    education?: string | null
    experience: string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability: string
    expectedSalary?: number | null
    resumeUrl?: string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: string | null
    github?: string | null
    status?: $Enums.ApplicationStatus
    stage?: $Enums.ApplicationStage
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    reviewerId?: string | null
    notes?: NoteUncheckedCreateNestedManyWithoutApplicationInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type CollaboratorApplicationCreateOrConnectWithoutEvaluationsInput = {
    where: CollaboratorApplicationWhereUniqueInput
    create: XOR<CollaboratorApplicationCreateWithoutEvaluationsInput, CollaboratorApplicationUncheckedCreateWithoutEvaluationsInput>
  }

  export type UserCreateWithoutEvaluationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationCreateNestedManyWithoutReviewerInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    interviews?: InterviewCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    library?: LibraryCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutReviewerInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    library?: LibraryUncheckedCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperUncheckedCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageUncheckedCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEvaluationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEvaluationsInput, UserUncheckedCreateWithoutEvaluationsInput>
  }

  export type CollaboratorApplicationUpsertWithoutEvaluationsInput = {
    update: XOR<CollaboratorApplicationUpdateWithoutEvaluationsInput, CollaboratorApplicationUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<CollaboratorApplicationCreateWithoutEvaluationsInput, CollaboratorApplicationUncheckedCreateWithoutEvaluationsInput>
    where?: CollaboratorApplicationWhereInput
  }

  export type CollaboratorApplicationUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: CollaboratorApplicationWhereInput
    data: XOR<CollaboratorApplicationUpdateWithoutEvaluationsInput, CollaboratorApplicationUncheckedUpdateWithoutEvaluationsInput>
  }

  export type CollaboratorApplicationUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: StringFieldUpdateOperationsInput | string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability?: StringFieldUpdateOperationsInput | string
    expectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFieldUpdateOperationsInput | $Enums.ApplicationStage
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCollaboratorApplicationsNestedInput
    notes?: NoteUpdateManyWithoutApplicationNestedInput
    interviews?: InterviewUpdateManyWithoutApplicationNestedInput
    reviewer?: UserUpdateOneWithoutReviewedApplicationsNestedInput
  }

  export type CollaboratorApplicationUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: StringFieldUpdateOperationsInput | string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability?: StringFieldUpdateOperationsInput | string
    expectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFieldUpdateOperationsInput | $Enums.ApplicationStage
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NoteUncheckedUpdateManyWithoutApplicationNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type UserUpsertWithoutEvaluationsInput = {
    update: XOR<UserUpdateWithoutEvaluationsInput, UserUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<UserCreateWithoutEvaluationsInput, UserUncheckedCreateWithoutEvaluationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEvaluationsInput, UserUncheckedUpdateWithoutEvaluationsInput>
  }

  export type UserUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUpdateManyWithoutReviewerNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    library?: LibraryUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    library?: LibraryUncheckedUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUncheckedUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUncheckedUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CollaboratorApplicationCreateWithoutNotesInput = {
    id?: string
    fullName: string
    email: string
    phone: string
    cpf?: string | null
    birthDate?: Date | string | null
    zipCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    area: string
    education?: string | null
    experience: string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability: string
    expectedSalary?: number | null
    resumeUrl?: string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: string | null
    github?: string | null
    status?: $Enums.ApplicationStatus
    stage?: $Enums.ApplicationStage
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    user: UserCreateNestedOneWithoutCollaboratorApplicationsInput
    evaluations?: EvaluationCreateNestedManyWithoutApplicationInput
    interviews?: InterviewCreateNestedManyWithoutApplicationInput
    reviewer?: UserCreateNestedOneWithoutReviewedApplicationsInput
  }

  export type CollaboratorApplicationUncheckedCreateWithoutNotesInput = {
    id?: string
    userId: string
    fullName: string
    email: string
    phone: string
    cpf?: string | null
    birthDate?: Date | string | null
    zipCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    area: string
    education?: string | null
    experience: string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability: string
    expectedSalary?: number | null
    resumeUrl?: string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: string | null
    github?: string | null
    status?: $Enums.ApplicationStatus
    stage?: $Enums.ApplicationStage
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    reviewerId?: string | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutApplicationInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type CollaboratorApplicationCreateOrConnectWithoutNotesInput = {
    where: CollaboratorApplicationWhereUniqueInput
    create: XOR<CollaboratorApplicationCreateWithoutNotesInput, CollaboratorApplicationUncheckedCreateWithoutNotesInput>
  }

  export type UserCreateWithoutNotesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    interviews?: InterviewCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    library?: LibraryCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutInterviewerInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    library?: LibraryUncheckedCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperUncheckedCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageUncheckedCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
  }

  export type CollaboratorApplicationUpsertWithoutNotesInput = {
    update: XOR<CollaboratorApplicationUpdateWithoutNotesInput, CollaboratorApplicationUncheckedUpdateWithoutNotesInput>
    create: XOR<CollaboratorApplicationCreateWithoutNotesInput, CollaboratorApplicationUncheckedCreateWithoutNotesInput>
    where?: CollaboratorApplicationWhereInput
  }

  export type CollaboratorApplicationUpdateToOneWithWhereWithoutNotesInput = {
    where?: CollaboratorApplicationWhereInput
    data: XOR<CollaboratorApplicationUpdateWithoutNotesInput, CollaboratorApplicationUncheckedUpdateWithoutNotesInput>
  }

  export type CollaboratorApplicationUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: StringFieldUpdateOperationsInput | string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability?: StringFieldUpdateOperationsInput | string
    expectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFieldUpdateOperationsInput | $Enums.ApplicationStage
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCollaboratorApplicationsNestedInput
    evaluations?: EvaluationUpdateManyWithoutApplicationNestedInput
    interviews?: InterviewUpdateManyWithoutApplicationNestedInput
    reviewer?: UserUpdateOneWithoutReviewedApplicationsNestedInput
  }

  export type CollaboratorApplicationUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: StringFieldUpdateOperationsInput | string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability?: StringFieldUpdateOperationsInput | string
    expectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFieldUpdateOperationsInput | $Enums.ApplicationStage
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutApplicationNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type UserUpsertWithoutNotesInput = {
    update: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    interviews?: InterviewUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    library?: LibraryUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutInterviewerNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    library?: LibraryUncheckedUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUncheckedUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUncheckedUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CollaboratorApplicationCreateWithoutInterviewsInput = {
    id?: string
    fullName: string
    email: string
    phone: string
    cpf?: string | null
    birthDate?: Date | string | null
    zipCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    area: string
    education?: string | null
    experience: string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability: string
    expectedSalary?: number | null
    resumeUrl?: string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: string | null
    github?: string | null
    status?: $Enums.ApplicationStatus
    stage?: $Enums.ApplicationStage
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    user: UserCreateNestedOneWithoutCollaboratorApplicationsInput
    evaluations?: EvaluationCreateNestedManyWithoutApplicationInput
    notes?: NoteCreateNestedManyWithoutApplicationInput
    reviewer?: UserCreateNestedOneWithoutReviewedApplicationsInput
  }

  export type CollaboratorApplicationUncheckedCreateWithoutInterviewsInput = {
    id?: string
    userId: string
    fullName: string
    email: string
    phone: string
    cpf?: string | null
    birthDate?: Date | string | null
    zipCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    area: string
    education?: string | null
    experience: string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability: string
    expectedSalary?: number | null
    resumeUrl?: string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: string | null
    github?: string | null
    status?: $Enums.ApplicationStatus
    stage?: $Enums.ApplicationStage
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    reviewerId?: string | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutApplicationInput
    notes?: NoteUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type CollaboratorApplicationCreateOrConnectWithoutInterviewsInput = {
    where: CollaboratorApplicationWhereUniqueInput
    create: XOR<CollaboratorApplicationCreateWithoutInterviewsInput, CollaboratorApplicationUncheckedCreateWithoutInterviewsInput>
  }

  export type UserCreateWithoutInterviewsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    library?: LibraryCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInterviewsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    verified?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phone?: string | null
    birthDate?: string | null
    profession?: string | null
    profileImageUrl?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    collaboratorApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedApplications?: CollaboratorApplicationUncheckedCreateNestedManyWithoutReviewerInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    library?: LibraryUncheckedCreateNestedManyWithoutUserInput
    customPapers?: CustomPaperUncheckedCreateNestedManyWithoutUserInput
    customPaperMessages?: CustomPaperMessageUncheckedCreateNestedManyWithoutSenderInput
    courseProgress?: CourseProgressUncheckedCreateNestedManyWithoutUserInput
    courseEnrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInterviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInterviewsInput, UserUncheckedCreateWithoutInterviewsInput>
  }

  export type CollaboratorApplicationUpsertWithoutInterviewsInput = {
    update: XOR<CollaboratorApplicationUpdateWithoutInterviewsInput, CollaboratorApplicationUncheckedUpdateWithoutInterviewsInput>
    create: XOR<CollaboratorApplicationCreateWithoutInterviewsInput, CollaboratorApplicationUncheckedCreateWithoutInterviewsInput>
    where?: CollaboratorApplicationWhereInput
  }

  export type CollaboratorApplicationUpdateToOneWithWhereWithoutInterviewsInput = {
    where?: CollaboratorApplicationWhereInput
    data: XOR<CollaboratorApplicationUpdateWithoutInterviewsInput, CollaboratorApplicationUncheckedUpdateWithoutInterviewsInput>
  }

  export type CollaboratorApplicationUpdateWithoutInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: StringFieldUpdateOperationsInput | string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability?: StringFieldUpdateOperationsInput | string
    expectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFieldUpdateOperationsInput | $Enums.ApplicationStage
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCollaboratorApplicationsNestedInput
    evaluations?: EvaluationUpdateManyWithoutApplicationNestedInput
    notes?: NoteUpdateManyWithoutApplicationNestedInput
    reviewer?: UserUpdateOneWithoutReviewedApplicationsNestedInput
  }

  export type CollaboratorApplicationUncheckedUpdateWithoutInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: StringFieldUpdateOperationsInput | string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability?: StringFieldUpdateOperationsInput | string
    expectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFieldUpdateOperationsInput | $Enums.ApplicationStage
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutApplicationNestedInput
    notes?: NoteUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type UserUpsertWithoutInterviewsInput = {
    update: XOR<UserUpdateWithoutInterviewsInput, UserUncheckedUpdateWithoutInterviewsInput>
    create: XOR<UserCreateWithoutInterviewsInput, UserUncheckedCreateWithoutInterviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInterviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInterviewsInput, UserUncheckedUpdateWithoutInterviewsInput>
  }

  export type UserUpdateWithoutInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    library?: LibraryUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    verified?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    collaboratorApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedApplications?: CollaboratorApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    library?: LibraryUncheckedUpdateManyWithoutUserNestedInput
    customPapers?: CustomPaperUncheckedUpdateManyWithoutUserNestedInput
    customPaperMessages?: CustomPaperMessageUncheckedUpdateManyWithoutSenderNestedInput
    courseProgress?: CourseProgressUncheckedUpdateManyWithoutUserNestedInput
    courseEnrollments?: CourseEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderCreateManyUserInput = {
    id?: string
    totalAmount: number
    status?: $Enums.OrderStatus
    paymentMethod?: $Enums.PaymentMethod | null
    paymentStatus?: $Enums.PaymentStatus
    customerName: string
    customerEmail: string
    customerCpfCnpj: string
    customerPhone?: string | null
    pixCode?: string | null
    boletoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollaboratorApplicationCreateManyUserInput = {
    id?: string
    fullName: string
    email: string
    phone: string
    cpf?: string | null
    birthDate?: Date | string | null
    zipCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    area: string
    education?: string | null
    experience: string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability: string
    expectedSalary?: number | null
    resumeUrl?: string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: string | null
    github?: string | null
    status?: $Enums.ApplicationStatus
    stage?: $Enums.ApplicationStage
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    reviewerId?: string | null
  }

  export type CollaboratorApplicationCreateManyReviewerInput = {
    id?: string
    userId: string
    fullName: string
    email: string
    phone: string
    cpf?: string | null
    birthDate?: Date | string | null
    zipCode?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    area: string
    education?: string | null
    experience: string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability: string
    expectedSalary?: number | null
    resumeUrl?: string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: string | null
    github?: string | null
    status?: $Enums.ApplicationStatus
    stage?: $Enums.ApplicationStage
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
  }

  export type EvaluationCreateManyEvaluatorInput = {
    id?: string
    applicationId: string
    experienceScore: number
    skillsScore: number
    educationScore: number
    culturalFitScore: number
    totalScore: number
    recommendation: $Enums.EvaluationRecommendation
    comments: string
    createdAt?: Date | string
  }

  export type NoteCreateManyAuthorInput = {
    id?: string
    applicationId: string
    content: string
    isPrivate?: boolean
    createdAt?: Date | string
  }

  export type InterviewCreateManyInterviewerInput = {
    id?: string
    applicationId: string
    scheduledAt: Date | string
    duration: number
    type: $Enums.InterviewType
    location?: string | null
    meetingUrl?: string | null
    status?: $Enums.InterviewStatus
    feedback?: string | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateCreateManyUserInput = {
    id?: string
    courseId: string
    certificateNumber: string
    grade: number
    completionDate: Date | string
    qrCodeUrl: string
    createdAt?: Date | string
  }

  export type LibraryCreateManyUserInput = {
    id?: string
    itemType: $Enums.LibraryItemType
    itemId: string
    downloadUrl: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CustomPaperCreateManyUserInput = {
    id?: string
    title: string
    description: string
    paperType: $Enums.PaperType
    academicArea: $Enums.AcademicArea
    pageCount: number
    deadline: Date | string
    urgency: $Enums.CustomPaperUrgency
    requirements: string
    keywords?: string | null
    references?: string | null
    requirementFiles?: CustomPaperCreaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperCreatedeliveryFilesInput | string[]
    quotedPrice?: number | null
    finalPrice?: number | null
    paymentStatus?: $Enums.PaymentStatus
    status?: $Enums.CustomPaperStatus
    adminNotes?: string | null
    rejectionReason?: string | null
    requestedAt?: Date | string
    quotedAt?: Date | string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    orderId?: string | null
  }

  export type CustomPaperMessageCreateManySenderInput = {
    id?: string
    customPaperId: string
    content: string
    attachments?: CustomPaperMessageCreateattachmentsInput | string[]
    isFromAdmin: boolean
    isRead?: boolean
    createdAt?: Date | string
  }

  export type CourseProgressCreateManyUserInput = {
    id?: string
    lessonId: string
    completed?: boolean
    watchTime?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseEnrollmentCreateManyUserInput = {
    id?: string
    courseId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
  }

  export type BlogPostCreateManyAuthorInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    categoryId?: string | null
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: string
    content: string
    postId: string
    parentId?: string | null
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateManyUserInput = {
    id?: string
    postId: string
    createdAt?: Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerCpfCnpj?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    customPaper?: CustomPaperUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerCpfCnpj?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    customPaper?: CustomPaperUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerCpfCnpj?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaboratorApplicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: StringFieldUpdateOperationsInput | string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability?: StringFieldUpdateOperationsInput | string
    expectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFieldUpdateOperationsInput | $Enums.ApplicationStage
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evaluations?: EvaluationUpdateManyWithoutApplicationNestedInput
    notes?: NoteUpdateManyWithoutApplicationNestedInput
    interviews?: InterviewUpdateManyWithoutApplicationNestedInput
    reviewer?: UserUpdateOneWithoutReviewedApplicationsNestedInput
  }

  export type CollaboratorApplicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: StringFieldUpdateOperationsInput | string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability?: StringFieldUpdateOperationsInput | string
    expectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFieldUpdateOperationsInput | $Enums.ApplicationStage
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutApplicationNestedInput
    notes?: NoteUncheckedUpdateManyWithoutApplicationNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type CollaboratorApplicationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: StringFieldUpdateOperationsInput | string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability?: StringFieldUpdateOperationsInput | string
    expectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFieldUpdateOperationsInput | $Enums.ApplicationStage
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CollaboratorApplicationUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: StringFieldUpdateOperationsInput | string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability?: StringFieldUpdateOperationsInput | string
    expectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFieldUpdateOperationsInput | $Enums.ApplicationStage
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCollaboratorApplicationsNestedInput
    evaluations?: EvaluationUpdateManyWithoutApplicationNestedInput
    notes?: NoteUpdateManyWithoutApplicationNestedInput
    interviews?: InterviewUpdateManyWithoutApplicationNestedInput
  }

  export type CollaboratorApplicationUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: StringFieldUpdateOperationsInput | string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability?: StringFieldUpdateOperationsInput | string
    expectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFieldUpdateOperationsInput | $Enums.ApplicationStage
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutApplicationNestedInput
    notes?: NoteUncheckedUpdateManyWithoutApplicationNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type CollaboratorApplicationUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: StringFieldUpdateOperationsInput | string
    skills?: NullableJsonNullValueInput | InputJsonValue
    availability?: StringFieldUpdateOperationsInput | string
    expectedSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrls?: NullableJsonNullValueInput | InputJsonValue
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    stage?: EnumApplicationStageFieldUpdateOperationsInput | $Enums.ApplicationStage
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluationUpdateWithoutEvaluatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceScore?: IntFieldUpdateOperationsInput | number
    skillsScore?: IntFieldUpdateOperationsInput | number
    educationScore?: IntFieldUpdateOperationsInput | number
    culturalFitScore?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    recommendation?: EnumEvaluationRecommendationFieldUpdateOperationsInput | $Enums.EvaluationRecommendation
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: CollaboratorApplicationUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutEvaluatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    experienceScore?: IntFieldUpdateOperationsInput | number
    skillsScore?: IntFieldUpdateOperationsInput | number
    educationScore?: IntFieldUpdateOperationsInput | number
    culturalFitScore?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    recommendation?: EnumEvaluationRecommendationFieldUpdateOperationsInput | $Enums.EvaluationRecommendation
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUncheckedUpdateManyWithoutEvaluatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    experienceScore?: IntFieldUpdateOperationsInput | number
    skillsScore?: IntFieldUpdateOperationsInput | number
    educationScore?: IntFieldUpdateOperationsInput | number
    culturalFitScore?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    recommendation?: EnumEvaluationRecommendationFieldUpdateOperationsInput | $Enums.EvaluationRecommendation
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: CollaboratorApplicationUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewUpdateWithoutInterviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: EnumInterviewTypeFieldUpdateOperationsInput | $Enums.InterviewType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: CollaboratorApplicationUpdateOneRequiredWithoutInterviewsNestedInput
  }

  export type InterviewUncheckedUpdateWithoutInterviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: EnumInterviewTypeFieldUpdateOperationsInput | $Enums.InterviewType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewUncheckedUpdateManyWithoutInterviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: EnumInterviewTypeFieldUpdateOperationsInput | $Enums.InterviewType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumLibraryItemTypeFieldUpdateOperationsInput | $Enums.LibraryItemType
    itemId?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumLibraryItemTypeFieldUpdateOperationsInput | $Enums.LibraryItemType
    itemId?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumLibraryItemTypeFieldUpdateOperationsInput | $Enums.LibraryItemType
    itemId?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPaperUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    pageCount?: IntFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    urgency?: EnumCustomPaperUrgencyFieldUpdateOperationsInput | $Enums.CustomPaperUrgency
    requirements?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    requirementFiles?: CustomPaperUpdaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperUpdatedeliveryFilesInput | string[]
    quotedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    status?: EnumCustomPaperStatusFieldUpdateOperationsInput | $Enums.CustomPaperStatus
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: CustomPaperMessageUpdateManyWithoutCustomPaperNestedInput
    order?: OrderUpdateOneWithoutCustomPaperNestedInput
  }

  export type CustomPaperUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    pageCount?: IntFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    urgency?: EnumCustomPaperUrgencyFieldUpdateOperationsInput | $Enums.CustomPaperUrgency
    requirements?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    requirementFiles?: CustomPaperUpdaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperUpdatedeliveryFilesInput | string[]
    quotedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    status?: EnumCustomPaperStatusFieldUpdateOperationsInput | $Enums.CustomPaperStatus
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: CustomPaperMessageUncheckedUpdateManyWithoutCustomPaperNestedInput
  }

  export type CustomPaperUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paperType?: EnumPaperTypeFieldUpdateOperationsInput | $Enums.PaperType
    academicArea?: EnumAcademicAreaFieldUpdateOperationsInput | $Enums.AcademicArea
    pageCount?: IntFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    urgency?: EnumCustomPaperUrgencyFieldUpdateOperationsInput | $Enums.CustomPaperUrgency
    requirements?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    requirementFiles?: CustomPaperUpdaterequirementFilesInput | string[]
    deliveryFiles?: CustomPaperUpdatedeliveryFilesInput | string[]
    quotedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    status?: EnumCustomPaperStatusFieldUpdateOperationsInput | $Enums.CustomPaperStatus
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomPaperMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: CustomPaperMessageUpdateattachmentsInput | string[]
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customPaper?: CustomPaperUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type CustomPaperMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    customPaperId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: CustomPaperMessageUpdateattachmentsInput | string[]
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPaperMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    customPaperId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: CustomPaperMessageUpdateattachmentsInput | string[]
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    watchTime?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: CourseLessonUpdateOneRequiredWithoutProgressNestedInput
  }

  export type CourseProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    watchTime?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    watchTime?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseEnrollmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type CourseEnrollmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type CourseEnrollmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type BlogPostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: BlogTagUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    analytics?: PostAnalyticsUpdateManyWithoutPostNestedInput
    notifications?: PostNotificationUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: BlogTagUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    analytics?: PostAnalyticsUncheckedUpdateManyWithoutPostNestedInput
    notifications?: PostNotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    paperId?: string | null
    courseId?: string | null
    ebookId?: string | null
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paper?: PaperUpdateOneWithoutOrderItemsNestedInput
    course?: CourseUpdateOneWithoutOrderItemsNestedInput
    ebook?: EbookUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paperId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    ebookId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paperId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    ebookId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyPaperInput = {
    id?: string
    orderId: string
    title: string
    description?: string | null
    price: number
    courseId?: string | null
    ebookId?: string | null
  }

  export type OrderItemUpdateWithoutPaperInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    course?: CourseUpdateOneWithoutOrderItemsNestedInput
    ebook?: EbookUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutPaperInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    ebookId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutPaperInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    ebookId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyCourseInput = {
    id?: string
    orderId: string
    title: string
    description?: string | null
    price: number
    paperId?: string | null
    ebookId?: string | null
  }

  export type CertificateCreateManyCourseInput = {
    id?: string
    userId: string
    certificateNumber: string
    grade: number
    completionDate: Date | string
    qrCodeUrl: string
    createdAt?: Date | string
  }

  export type CourseModuleCreateManyCourseInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseEnrollmentCreateManyCourseInput = {
    id?: string
    userId: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    progress?: number
  }

  export type OrderItemUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    paper?: PaperUpdateOneWithoutOrderItemsNestedInput
    ebook?: EbookUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paperId?: NullableStringFieldUpdateOperationsInput | string | null
    ebookId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paperId?: NullableStringFieldUpdateOperationsInput | string | null
    ebookId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificateUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCodeUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseModuleUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: CourseLessonUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: CourseLessonUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseEnrollmentUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutCourseEnrollmentsNestedInput
  }

  export type CourseEnrollmentUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type CourseEnrollmentUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type EbookFileCreateManyEbookInput = {
    id?: string
    fileUrl: string
    fileName: string
    fileSize?: number | null
    createdAt?: Date | string
  }

  export type OrderItemCreateManyEbookInput = {
    id?: string
    orderId: string
    title: string
    description?: string | null
    price: number
    paperId?: string | null
    courseId?: string | null
  }

  export type EbookFileUpdateWithoutEbookInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EbookFileUncheckedUpdateWithoutEbookInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EbookFileUncheckedUpdateManyWithoutEbookInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpdateWithoutEbookInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    paper?: PaperUpdateOneWithoutOrderItemsNestedInput
    course?: CourseUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutEbookInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paperId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutEbookInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paperId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlogPostCreateManyCategoryInput = {
    id?: string
    title: string
    content: string
    slug: string
    excerpt?: string | null
    coverImageUrl?: string | null
    published?: boolean
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    authorId: string
    views?: number
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: BlogPostCreatemetaKeywordsInput | string[]
    ogImage?: string | null
    canonicalUrl?: string | null
    readingTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsletterSubscriptionCreateManyCategoryInput = {
    subscriberId: string
    createdAt?: Date | string
  }

  export type BlogPostUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
    tags?: BlogTagUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    analytics?: PostAnalyticsUpdateManyWithoutPostNestedInput
    notifications?: PostNotificationUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: BlogTagUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    analytics?: PostAnalyticsUncheckedUpdateManyWithoutPostNestedInput
    notifications?: PostNotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: BlogPostUpdatemetaKeywordsInput | string[]
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsletterSubscriptionUpdateWithoutCategoryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriber?: NewsletterSubscriberUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type NewsletterSubscriptionUncheckedUpdateWithoutCategoryInput = {
    subscriberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsletterSubscriptionUncheckedUpdateManyWithoutCategoryInput = {
    subscriberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTagCreateManyTagInput = {
    postId: string
  }

  export type BlogTagUpdateWithoutTagInput = {
    post?: BlogPostUpdateOneRequiredWithoutTagsNestedInput
  }

  export type BlogTagUncheckedUpdateWithoutTagInput = {
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogTagUncheckedUpdateManyWithoutTagInput = {
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogTagCreateManyPostInput = {
    tagId: string
  }

  export type CommentCreateManyPostInput = {
    id?: string
    content: string
    userId: string
    parentId?: string | null
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateManyPostInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type PostAnalyticsCreateManyPostInput = {
    id?: string
    date: Date | string
    views?: number
    uniqueViews?: number
    shares?: number
    avgTimeOnPage?: number
    bounceRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostNotificationCreateManyPostInput = {
    id?: string
    sentAt?: Date | string | null
    subscriberCount?: number
    subject?: string | null
    emailContent?: string | null
    createdAt?: Date | string
  }

  export type BlogTagUpdateWithoutPostInput = {
    tag?: TagUpdateOneRequiredWithoutPostsNestedInput
  }

  export type BlogTagUncheckedUpdateWithoutPostInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogTagUncheckedUpdateManyWithoutPostInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAnalyticsUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    views?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    avgTimeOnPage?: IntFieldUpdateOperationsInput | number
    bounceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAnalyticsUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    views?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    avgTimeOnPage?: IntFieldUpdateOperationsInput | number
    bounceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAnalyticsUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    views?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    avgTimeOnPage?: IntFieldUpdateOperationsInput | number
    bounceRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostNotificationUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriberCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    emailContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostNotificationUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriberCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    emailContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostNotificationUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriberCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    emailContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentInput = {
    id?: string
    content: string
    postId: string
    userId: string
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationCreateManyApplicationInput = {
    id?: string
    evaluatorId: string
    experienceScore: number
    skillsScore: number
    educationScore: number
    culturalFitScore: number
    totalScore: number
    recommendation: $Enums.EvaluationRecommendation
    comments: string
    createdAt?: Date | string
  }

  export type NoteCreateManyApplicationInput = {
    id?: string
    authorId: string
    content: string
    isPrivate?: boolean
    createdAt?: Date | string
  }

  export type InterviewCreateManyApplicationInput = {
    id?: string
    scheduledAt: Date | string
    duration: number
    type: $Enums.InterviewType
    location?: string | null
    meetingUrl?: string | null
    interviewerId: string
    status?: $Enums.InterviewStatus
    feedback?: string | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceScore?: IntFieldUpdateOperationsInput | number
    skillsScore?: IntFieldUpdateOperationsInput | number
    educationScore?: IntFieldUpdateOperationsInput | number
    culturalFitScore?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    recommendation?: EnumEvaluationRecommendationFieldUpdateOperationsInput | $Enums.EvaluationRecommendation
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluator?: UserUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    experienceScore?: IntFieldUpdateOperationsInput | number
    skillsScore?: IntFieldUpdateOperationsInput | number
    educationScore?: IntFieldUpdateOperationsInput | number
    culturalFitScore?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    recommendation?: EnumEvaluationRecommendationFieldUpdateOperationsInput | $Enums.EvaluationRecommendation
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    experienceScore?: IntFieldUpdateOperationsInput | number
    skillsScore?: IntFieldUpdateOperationsInput | number
    educationScore?: IntFieldUpdateOperationsInput | number
    culturalFitScore?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    recommendation?: EnumEvaluationRecommendationFieldUpdateOperationsInput | $Enums.EvaluationRecommendation
    comments?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: EnumInterviewTypeFieldUpdateOperationsInput | $Enums.InterviewType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interviewer?: UserUpdateOneRequiredWithoutInterviewsNestedInput
  }

  export type InterviewUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: EnumInterviewTypeFieldUpdateOperationsInput | $Enums.InterviewType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    interviewerId?: StringFieldUpdateOperationsInput | string
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: EnumInterviewTypeFieldUpdateOperationsInput | $Enums.InterviewType
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    interviewerId?: StringFieldUpdateOperationsInput | string
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPaperMessageCreateManyCustomPaperInput = {
    id?: string
    senderId: string
    content: string
    attachments?: CustomPaperMessageCreateattachmentsInput | string[]
    isFromAdmin: boolean
    isRead?: boolean
    createdAt?: Date | string
  }

  export type CustomPaperMessageUpdateWithoutCustomPaperInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: CustomPaperMessageUpdateattachmentsInput | string[]
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutCustomPaperMessagesNestedInput
  }

  export type CustomPaperMessageUncheckedUpdateWithoutCustomPaperInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: CustomPaperMessageUpdateattachmentsInput | string[]
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomPaperMessageUncheckedUpdateManyWithoutCustomPaperInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: CustomPaperMessageUpdateattachmentsInput | string[]
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLessonCreateManyModuleInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl?: string | null
    content?: string | null
    duration?: number | null
    order: number
    isEnabled?: boolean
    attachments?: CourseLessonCreateattachmentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseLessonUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    attachments?: CourseLessonUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: CourseProgressUpdateManyWithoutLessonNestedInput
  }

  export type CourseLessonUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    attachments?: CourseLessonUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: CourseProgressUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type CourseLessonUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    attachments?: CourseLessonUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseProgressCreateManyLessonInput = {
    id?: string
    userId: string
    completed?: boolean
    watchTime?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseProgressUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    watchTime?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCourseProgressNestedInput
  }

  export type CourseProgressUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    watchTime?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseProgressUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    watchTime?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsletterSubscriptionCreateManySubscriberInput = {
    categoryId: string
    createdAt?: Date | string
  }

  export type NewsletterSubscriptionUpdateWithoutSubscriberInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutSubscribersNestedInput
  }

  export type NewsletterSubscriptionUncheckedUpdateWithoutSubscriberInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsletterSubscriptionUncheckedUpdateManyWithoutSubscriberInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaperCountOutputTypeDefaultArgs instead
     */
    export type PaperCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaperCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseCountOutputTypeDefaultArgs instead
     */
    export type CourseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EbookCountOutputTypeDefaultArgs instead
     */
    export type EbookCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EbookCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagCountOutputTypeDefaultArgs instead
     */
    export type TagCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogPostCountOutputTypeDefaultArgs instead
     */
    export type BlogPostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogPostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentCountOutputTypeDefaultArgs instead
     */
    export type CommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CollaboratorApplicationCountOutputTypeDefaultArgs instead
     */
    export type CollaboratorApplicationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CollaboratorApplicationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomPaperCountOutputTypeDefaultArgs instead
     */
    export type CustomPaperCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomPaperCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseModuleCountOutputTypeDefaultArgs instead
     */
    export type CourseModuleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseModuleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseLessonCountOutputTypeDefaultArgs instead
     */
    export type CourseLessonCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseLessonCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsletterSubscriberCountOutputTypeDefaultArgs instead
     */
    export type NewsletterSubscriberCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsletterSubscriberCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderItemDefaultArgs instead
     */
    export type OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaperDefaultArgs instead
     */
    export type PaperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaperDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseDefaultArgs instead
     */
    export type CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EbookDefaultArgs instead
     */
    export type EbookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EbookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EbookFileDefaultArgs instead
     */
    export type EbookFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EbookFileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CertificateDefaultArgs instead
     */
    export type CertificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CertificateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LibraryDefaultArgs instead
     */
    export type LibraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LibraryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagDefaultArgs instead
     */
    export type TagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogPostDefaultArgs instead
     */
    export type BlogPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogTagDefaultArgs instead
     */
    export type BlogTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogTagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LikeDefaultArgs instead
     */
    export type LikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LikeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CollaboratorApplicationDefaultArgs instead
     */
    export type CollaboratorApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CollaboratorApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LegalDocumentDefaultArgs instead
     */
    export type LegalDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LegalDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageTemplateDefaultArgs instead
     */
    export type MessageTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DownloadTrackingDefaultArgs instead
     */
    export type DownloadTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DownloadTrackingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomPaperDefaultArgs instead
     */
    export type CustomPaperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomPaperDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomPaperMessageDefaultArgs instead
     */
    export type CustomPaperMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomPaperMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseModuleDefaultArgs instead
     */
    export type CourseModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseModuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseLessonDefaultArgs instead
     */
    export type CourseLessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseLessonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseProgressDefaultArgs instead
     */
    export type CourseProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseEnrollmentDefaultArgs instead
     */
    export type CourseEnrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseEnrollmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostAnalyticsDefaultArgs instead
     */
    export type PostAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostAnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsletterSubscriberDefaultArgs instead
     */
    export type NewsletterSubscriberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsletterSubscriberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsletterSubscriptionDefaultArgs instead
     */
    export type NewsletterSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsletterSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostNotificationDefaultArgs instead
     */
    export type PostNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostNotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationDefaultArgs instead
     */
    export type EvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NoteDefaultArgs instead
     */
    export type NoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InterviewDefaultArgs instead
     */
    export type InterviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InterviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiIntegrationDefaultArgs instead
     */
    export type ApiIntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiIntegrationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}